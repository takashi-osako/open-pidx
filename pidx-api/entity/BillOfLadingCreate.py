#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 18 22:52:29 2013 by generateDS.py version 2.9a.
#

import sys
import getopt
import re as re_
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class BillOfLadingDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinishedProduct=None):
        if FinishedProduct is None:
            self.FinishedProduct = []
        else:
            self.FinishedProduct = FinishedProduct
    def factory(*args_, **kwargs_):
        if BillOfLadingDetailsType.subclass:
            return BillOfLadingDetailsType.subclass(*args_, **kwargs_)
        else:
            return BillOfLadingDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinishedProduct(self): return self.FinishedProduct
    def set_FinishedProduct(self, FinishedProduct): self.FinishedProduct = FinishedProduct
    def add_FinishedProduct(self, value): self.FinishedProduct.append(value)
    def insert_FinishedProduct(self, index, value): self.FinishedProduct[index] = value
    def hasContent_(self):
        if (
            self.FinishedProduct
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BillOfLadingDetailsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillOfLadingDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BillOfLadingDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BillOfLadingDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FinishedProduct_ in self.FinishedProduct:
            FinishedProduct_.export(outfile, level, namespace_, name_='FinishedProduct', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillOfLadingDetailsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FinishedProduct=[\n')
        level += 1
        for FinishedProduct_ in self.FinishedProduct:
            showIndent(outfile, level)
            outfile.write('model_.FinishedProduct(\n')
            FinishedProduct_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinishedProduct':
            obj_ = FinishedProductType.factory()
            obj_.build(child_)
            self.FinishedProduct.append(obj_)
# end class BillOfLadingDetailsType


class BillOfLadingHeaderType(GeneratedsSuper):
    """For real-time (PDXR) type authorizations, this is the number
    assigned/returned from the load authorizing application.An
    alpha-numeric field which identifies the consignee as it appears
    on the BOL. This field may include the following two data
    fields: 'Bill To ID' and (optionally) 'Ship To ID'.A system
    generated load verification numberThe date when the driver stops
    the load/transaction. Typically, this is when the driver is
    finished loading at the truck rack load lane and “cards
    out.”The time when the driver stops the load/transaction.
    Typically, this is when the driver is finished loading at the
    truck rack load lane and “cards out.”The date when the
    driver entered the terminal.The time when the driver entered the
    terminal.The date when the driver finished (either when carded
    out and did the BOL print, or when carded out to exit the
    terminal).The time when the driver finished (either when carded
    out and did the BOL print, or when carded out to exit the
    terminal).Identifies which lane or loading area the driver
    loaded the product.The date when the driver started the
    load/transaction. Typically, this is when the driver “cards
    in” at the truck rack load lane to begin loading.The time when
    the driver started the load/transaction. Typically, this is when
    the driver “cards in” at the truck rack load lane to begin
    loading.An alpha-numeric field, which contains the significant
    digits of the bill of lading number. Right justification and
    padding with leading zeros is not required."""
    subclass = None
    superclass = None
    def __init__(self, LoadSpot=None, AuthorizationCode=None, ExitTime=None, ExitDate=None, ConsigneeNumber=None, StartLoadDate=None, EndLoadTime=None, DispatchOrderNumber=None, EntryTime=None, BillOfLadingNumber=None, EntryDate=None, TransactionType=None, EndLoadDate=None, StartLoadTime=None, PurchaseOrderInformation=None, SupplierInformation=None, ExchangeOrThroughputPartnerInformation=None, ThirdParty=None, FinalShipper=None, TerminalInformation=None, CarrierInformation=None, BillToInformation=None, ShipToInformation=None):
        self.LoadSpot = _cast(None, LoadSpot)
        self.AuthorizationCode = _cast(None, AuthorizationCode)
        self.ExitTime = _cast(None, ExitTime)
        self.ExitDate = _cast(None, ExitDate)
        self.ConsigneeNumber = _cast(None, ConsigneeNumber)
        self.StartLoadDate = _cast(None, StartLoadDate)
        self.EndLoadTime = _cast(None, EndLoadTime)
        self.DispatchOrderNumber = _cast(None, DispatchOrderNumber)
        self.EntryTime = _cast(None, EntryTime)
        self.BillOfLadingNumber = _cast(None, BillOfLadingNumber)
        self.EntryDate = _cast(None, EntryDate)
        self.TransactionType = _cast(None, TransactionType)
        self.EndLoadDate = _cast(None, EndLoadDate)
        self.StartLoadTime = _cast(None, StartLoadTime)
        self.PurchaseOrderInformation = PurchaseOrderInformation
        self.SupplierInformation = SupplierInformation
        self.ExchangeOrThroughputPartnerInformation = ExchangeOrThroughputPartnerInformation
        if ThirdParty is None:
            self.ThirdParty = []
        else:
            self.ThirdParty = ThirdParty
        self.FinalShipper = FinalShipper
        self.TerminalInformation = TerminalInformation
        self.CarrierInformation = CarrierInformation
        self.BillToInformation = BillToInformation
        self.ShipToInformation = ShipToInformation
    def factory(*args_, **kwargs_):
        if BillOfLadingHeaderType.subclass:
            return BillOfLadingHeaderType.subclass(*args_, **kwargs_)
        else:
            return BillOfLadingHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PurchaseOrderInformation(self): return self.PurchaseOrderInformation
    def set_PurchaseOrderInformation(self, PurchaseOrderInformation): self.PurchaseOrderInformation = PurchaseOrderInformation
    def get_SupplierInformation(self): return self.SupplierInformation
    def set_SupplierInformation(self, SupplierInformation): self.SupplierInformation = SupplierInformation
    def get_ExchangeOrThroughputPartnerInformation(self): return self.ExchangeOrThroughputPartnerInformation
    def set_ExchangeOrThroughputPartnerInformation(self, ExchangeOrThroughputPartnerInformation): self.ExchangeOrThroughputPartnerInformation = ExchangeOrThroughputPartnerInformation
    def get_ThirdParty(self): return self.ThirdParty
    def set_ThirdParty(self, ThirdParty): self.ThirdParty = ThirdParty
    def add_ThirdParty(self, value): self.ThirdParty.append(value)
    def insert_ThirdParty(self, index, value): self.ThirdParty[index] = value
    def get_FinalShipper(self): return self.FinalShipper
    def set_FinalShipper(self, FinalShipper): self.FinalShipper = FinalShipper
    def get_TerminalInformation(self): return self.TerminalInformation
    def set_TerminalInformation(self, TerminalInformation): self.TerminalInformation = TerminalInformation
    def get_CarrierInformation(self): return self.CarrierInformation
    def set_CarrierInformation(self, CarrierInformation): self.CarrierInformation = CarrierInformation
    def get_BillToInformation(self): return self.BillToInformation
    def set_BillToInformation(self, BillToInformation): self.BillToInformation = BillToInformation
    def get_ShipToInformation(self): return self.ShipToInformation
    def set_ShipToInformation(self, ShipToInformation): self.ShipToInformation = ShipToInformation
    def get_LoadSpot(self): return self.LoadSpot
    def set_LoadSpot(self, LoadSpot): self.LoadSpot = LoadSpot
    def get_AuthorizationCode(self): return self.AuthorizationCode
    def set_AuthorizationCode(self, AuthorizationCode): self.AuthorizationCode = AuthorizationCode
    def get_ExitTime(self): return self.ExitTime
    def set_ExitTime(self, ExitTime): self.ExitTime = ExitTime
    def get_ExitDate(self): return self.ExitDate
    def set_ExitDate(self, ExitDate): self.ExitDate = ExitDate
    def get_ConsigneeNumber(self): return self.ConsigneeNumber
    def set_ConsigneeNumber(self, ConsigneeNumber): self.ConsigneeNumber = ConsigneeNumber
    def get_StartLoadDate(self): return self.StartLoadDate
    def set_StartLoadDate(self, StartLoadDate): self.StartLoadDate = StartLoadDate
    def get_EndLoadTime(self): return self.EndLoadTime
    def set_EndLoadTime(self, EndLoadTime): self.EndLoadTime = EndLoadTime
    def get_DispatchOrderNumber(self): return self.DispatchOrderNumber
    def set_DispatchOrderNumber(self, DispatchOrderNumber): self.DispatchOrderNumber = DispatchOrderNumber
    def get_EntryTime(self): return self.EntryTime
    def set_EntryTime(self, EntryTime): self.EntryTime = EntryTime
    def get_BillOfLadingNumber(self): return self.BillOfLadingNumber
    def set_BillOfLadingNumber(self, BillOfLadingNumber): self.BillOfLadingNumber = BillOfLadingNumber
    def get_EntryDate(self): return self.EntryDate
    def set_EntryDate(self, EntryDate): self.EntryDate = EntryDate
    def get_TransactionType(self): return self.TransactionType
    def set_TransactionType(self, TransactionType): self.TransactionType = TransactionType
    def get_EndLoadDate(self): return self.EndLoadDate
    def set_EndLoadDate(self, EndLoadDate): self.EndLoadDate = EndLoadDate
    def get_StartLoadTime(self): return self.StartLoadTime
    def set_StartLoadTime(self, StartLoadTime): self.StartLoadTime = StartLoadTime
    def hasContent_(self):
        if (
            self.PurchaseOrderInformation is not None or
            self.SupplierInformation is not None or
            self.ExchangeOrThroughputPartnerInformation is not None or
            self.ThirdParty or
            self.FinalShipper is not None or
            self.TerminalInformation is not None or
            self.CarrierInformation is not None or
            self.BillToInformation is not None or
            self.ShipToInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BillOfLadingHeaderType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillOfLadingHeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BillOfLadingHeaderType'):
        if self.LoadSpot is not None and 'LoadSpot' not in already_processed:
            already_processed.add('LoadSpot')
            outfile.write(' LoadSpot=%s' % (self.gds_format_string(quote_attrib(self.LoadSpot).encode(ExternalEncoding), input_name='LoadSpot'), ))
        if self.AuthorizationCode is not None and 'AuthorizationCode' not in already_processed:
            already_processed.add('AuthorizationCode')
            outfile.write(' AuthorizationCode=%s' % (self.gds_format_string(quote_attrib(self.AuthorizationCode).encode(ExternalEncoding), input_name='AuthorizationCode'), ))
        if self.ExitTime is not None and 'ExitTime' not in already_processed:
            already_processed.add('ExitTime')
            outfile.write(' ExitTime=%s' % (self.gds_format_string(quote_attrib(self.ExitTime).encode(ExternalEncoding), input_name='ExitTime'), ))
        if self.ExitDate is not None and 'ExitDate' not in already_processed:
            already_processed.add('ExitDate')
            outfile.write(' ExitDate="%s"' % self.gds_format_date(self.ExitDate, input_name='ExitDate'))
        if self.ConsigneeNumber is not None and 'ConsigneeNumber' not in already_processed:
            already_processed.add('ConsigneeNumber')
            outfile.write(' ConsigneeNumber=%s' % (self.gds_format_string(quote_attrib(self.ConsigneeNumber).encode(ExternalEncoding), input_name='ConsigneeNumber'), ))
        if self.StartLoadDate is not None and 'StartLoadDate' not in already_processed:
            already_processed.add('StartLoadDate')
            outfile.write(' StartLoadDate="%s"' % self.gds_format_date(self.StartLoadDate, input_name='StartLoadDate'))
        if self.EndLoadTime is not None and 'EndLoadTime' not in already_processed:
            already_processed.add('EndLoadTime')
            outfile.write(' EndLoadTime=%s' % (self.gds_format_string(quote_attrib(self.EndLoadTime).encode(ExternalEncoding), input_name='EndLoadTime'), ))
        if self.DispatchOrderNumber is not None and 'DispatchOrderNumber' not in already_processed:
            already_processed.add('DispatchOrderNumber')
            outfile.write(' DispatchOrderNumber=%s' % (self.gds_format_string(quote_attrib(self.DispatchOrderNumber).encode(ExternalEncoding), input_name='DispatchOrderNumber'), ))
        if self.EntryTime is not None and 'EntryTime' not in already_processed:
            already_processed.add('EntryTime')
            outfile.write(' EntryTime=%s' % (self.gds_format_string(quote_attrib(self.EntryTime).encode(ExternalEncoding), input_name='EntryTime'), ))
        if self.BillOfLadingNumber is not None and 'BillOfLadingNumber' not in already_processed:
            already_processed.add('BillOfLadingNumber')
            outfile.write(' BillOfLadingNumber=%s' % (self.gds_format_string(quote_attrib(self.BillOfLadingNumber).encode(ExternalEncoding), input_name='BillOfLadingNumber'), ))
        if self.EntryDate is not None and 'EntryDate' not in already_processed:
            already_processed.add('EntryDate')
            outfile.write(' EntryDate="%s"' % self.gds_format_date(self.EntryDate, input_name='EntryDate'))
        if self.TransactionType is not None and 'TransactionType' not in already_processed:
            already_processed.add('TransactionType')
            outfile.write(' TransactionType=%s' % (quote_attrib(self.TransactionType), ))
        if self.EndLoadDate is not None and 'EndLoadDate' not in already_processed:
            already_processed.add('EndLoadDate')
            outfile.write(' EndLoadDate="%s"' % self.gds_format_date(self.EndLoadDate, input_name='EndLoadDate'))
        if self.StartLoadTime is not None and 'StartLoadTime' not in already_processed:
            already_processed.add('StartLoadTime')
            outfile.write(' StartLoadTime=%s' % (self.gds_format_string(quote_attrib(self.StartLoadTime).encode(ExternalEncoding), input_name='StartLoadTime'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BillOfLadingHeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PurchaseOrderInformation is not None:
            self.PurchaseOrderInformation.export(outfile, level, namespace_, name_='PurchaseOrderInformation', pretty_print=pretty_print)
        if self.SupplierInformation is not None:
            self.SupplierInformation.export(outfile, level, namespace_, name_='SupplierInformation', pretty_print=pretty_print)
        if self.ExchangeOrThroughputPartnerInformation is not None:
            self.ExchangeOrThroughputPartnerInformation.export(outfile, level, namespace_, name_='ExchangeOrThroughputPartnerInformation', pretty_print=pretty_print)
        for ThirdParty_ in self.ThirdParty:
            ThirdParty_.export(outfile, level, namespace_, name_='ThirdParty', pretty_print=pretty_print)
        if self.FinalShipper is not None:
            self.FinalShipper.export(outfile, level, namespace_, name_='FinalShipper', pretty_print=pretty_print)
        if self.TerminalInformation is not None:
            self.TerminalInformation.export(outfile, level, namespace_, name_='TerminalInformation', pretty_print=pretty_print)
        if self.CarrierInformation is not None:
            self.CarrierInformation.export(outfile, level, namespace_, name_='CarrierInformation', pretty_print=pretty_print)
        if self.BillToInformation is not None:
            self.BillToInformation.export(outfile, level, namespace_, name_='BillToInformation', pretty_print=pretty_print)
        if self.ShipToInformation is not None:
            self.ShipToInformation.export(outfile, level, namespace_, name_='ShipToInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillOfLadingHeaderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LoadSpot is not None and 'LoadSpot' not in already_processed:
            already_processed.add('LoadSpot')
            showIndent(outfile, level)
            outfile.write('LoadSpot = "%s",\n' % (self.LoadSpot,))
        if self.AuthorizationCode is not None and 'AuthorizationCode' not in already_processed:
            already_processed.add('AuthorizationCode')
            showIndent(outfile, level)
            outfile.write('AuthorizationCode = "%s",\n' % (self.AuthorizationCode,))
        if self.ExitTime is not None and 'ExitTime' not in already_processed:
            already_processed.add('ExitTime')
            showIndent(outfile, level)
            outfile.write('ExitTime = "%s",\n' % (self.ExitTime,))
        if self.ExitDate is not None and 'ExitDate' not in already_processed:
            already_processed.add('ExitDate')
            showIndent(outfile, level)
            outfile.write('ExitDate = "%s",\n' % (self.ExitDate,))
        if self.ConsigneeNumber is not None and 'ConsigneeNumber' not in already_processed:
            already_processed.add('ConsigneeNumber')
            showIndent(outfile, level)
            outfile.write('ConsigneeNumber = "%s",\n' % (self.ConsigneeNumber,))
        if self.StartLoadDate is not None and 'StartLoadDate' not in already_processed:
            already_processed.add('StartLoadDate')
            showIndent(outfile, level)
            outfile.write('StartLoadDate = "%s",\n' % (self.StartLoadDate,))
        if self.EndLoadTime is not None and 'EndLoadTime' not in already_processed:
            already_processed.add('EndLoadTime')
            showIndent(outfile, level)
            outfile.write('EndLoadTime = "%s",\n' % (self.EndLoadTime,))
        if self.DispatchOrderNumber is not None and 'DispatchOrderNumber' not in already_processed:
            already_processed.add('DispatchOrderNumber')
            showIndent(outfile, level)
            outfile.write('DispatchOrderNumber = "%s",\n' % (self.DispatchOrderNumber,))
        if self.EntryTime is not None and 'EntryTime' not in already_processed:
            already_processed.add('EntryTime')
            showIndent(outfile, level)
            outfile.write('EntryTime = "%s",\n' % (self.EntryTime,))
        if self.BillOfLadingNumber is not None and 'BillOfLadingNumber' not in already_processed:
            already_processed.add('BillOfLadingNumber')
            showIndent(outfile, level)
            outfile.write('BillOfLadingNumber = "%s",\n' % (self.BillOfLadingNumber,))
        if self.EntryDate is not None and 'EntryDate' not in already_processed:
            already_processed.add('EntryDate')
            showIndent(outfile, level)
            outfile.write('EntryDate = "%s",\n' % (self.EntryDate,))
        if self.TransactionType is not None and 'TransactionType' not in already_processed:
            already_processed.add('TransactionType')
            showIndent(outfile, level)
            outfile.write('TransactionType = %s,\n' % (self.TransactionType,))
        if self.EndLoadDate is not None and 'EndLoadDate' not in already_processed:
            already_processed.add('EndLoadDate')
            showIndent(outfile, level)
            outfile.write('EndLoadDate = "%s",\n' % (self.EndLoadDate,))
        if self.StartLoadTime is not None and 'StartLoadTime' not in already_processed:
            already_processed.add('StartLoadTime')
            showIndent(outfile, level)
            outfile.write('StartLoadTime = "%s",\n' % (self.StartLoadTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PurchaseOrderInformation is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderInformation=model_.PurchaseOrderInformation(\n')
            self.PurchaseOrderInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SupplierInformation is not None:
            showIndent(outfile, level)
            outfile.write('SupplierInformation=model_.SupplierInformation(\n')
            self.SupplierInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExchangeOrThroughputPartnerInformation is not None:
            showIndent(outfile, level)
            outfile.write('ExchangeOrThroughputPartnerInformation=model_.ExchangeOrThroughputPartnerInformation(\n')
            self.ExchangeOrThroughputPartnerInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ThirdParty=[\n')
        level += 1
        for ThirdParty_ in self.ThirdParty:
            showIndent(outfile, level)
            outfile.write('model_.ThirdParty(\n')
            ThirdParty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FinalShipper is not None:
            showIndent(outfile, level)
            outfile.write('FinalShipper=model_.FinalShipper(\n')
            self.FinalShipper.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TerminalInformation is not None:
            showIndent(outfile, level)
            outfile.write('TerminalInformation=model_.TerminalInformation(\n')
            self.TerminalInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CarrierInformation is not None:
            showIndent(outfile, level)
            outfile.write('CarrierInformation=model_.CarrierInformation(\n')
            self.CarrierInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BillToInformation is not None:
            showIndent(outfile, level)
            outfile.write('BillToInformation=model_.BillToInformation(\n')
            self.BillToInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShipToInformation is not None:
            showIndent(outfile, level)
            outfile.write('ShipToInformation=model_.ShipToInformation(\n')
            self.ShipToInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LoadSpot', node)
        if value is not None and 'LoadSpot' not in already_processed:
            already_processed.add('LoadSpot')
            self.LoadSpot = value
        value = find_attr_value_('AuthorizationCode', node)
        if value is not None and 'AuthorizationCode' not in already_processed:
            already_processed.add('AuthorizationCode')
            self.AuthorizationCode = value
        value = find_attr_value_('ExitTime', node)
        if value is not None and 'ExitTime' not in already_processed:
            already_processed.add('ExitTime')
            self.ExitTime = value
        value = find_attr_value_('ExitDate', node)
        if value is not None and 'ExitDate' not in already_processed:
            already_processed.add('ExitDate')
            try:
                self.ExitDate = self.gds_parse_date(value, node, 'ExitDate')
            except ValueError, exp:
                raise ValueError('Bad date attribute (ExitDate): %s' % exp)
        value = find_attr_value_('ConsigneeNumber', node)
        if value is not None and 'ConsigneeNumber' not in already_processed:
            already_processed.add('ConsigneeNumber')
            self.ConsigneeNumber = value
        value = find_attr_value_('StartLoadDate', node)
        if value is not None and 'StartLoadDate' not in already_processed:
            already_processed.add('StartLoadDate')
            try:
                self.StartLoadDate = self.gds_parse_date(value, node, 'StartLoadDate')
            except ValueError, exp:
                raise ValueError('Bad date attribute (StartLoadDate): %s' % exp)
        value = find_attr_value_('EndLoadTime', node)
        if value is not None and 'EndLoadTime' not in already_processed:
            already_processed.add('EndLoadTime')
            self.EndLoadTime = value
        value = find_attr_value_('DispatchOrderNumber', node)
        if value is not None and 'DispatchOrderNumber' not in already_processed:
            already_processed.add('DispatchOrderNumber')
            self.DispatchOrderNumber = value
        value = find_attr_value_('EntryTime', node)
        if value is not None and 'EntryTime' not in already_processed:
            already_processed.add('EntryTime')
            self.EntryTime = value
        value = find_attr_value_('BillOfLadingNumber', node)
        if value is not None and 'BillOfLadingNumber' not in already_processed:
            already_processed.add('BillOfLadingNumber')
            self.BillOfLadingNumber = value
        value = find_attr_value_('EntryDate', node)
        if value is not None and 'EntryDate' not in already_processed:
            already_processed.add('EntryDate')
            try:
                self.EntryDate = self.gds_parse_date(value, node, 'EntryDate')
            except ValueError, exp:
                raise ValueError('Bad date attribute (EntryDate): %s' % exp)
        value = find_attr_value_('TransactionType', node)
        if value is not None and 'TransactionType' not in already_processed:
            already_processed.add('TransactionType')
            self.TransactionType = value
        value = find_attr_value_('EndLoadDate', node)
        if value is not None and 'EndLoadDate' not in already_processed:
            already_processed.add('EndLoadDate')
            try:
                self.EndLoadDate = self.gds_parse_date(value, node, 'EndLoadDate')
            except ValueError, exp:
                raise ValueError('Bad date attribute (EndLoadDate): %s' % exp)
        value = find_attr_value_('StartLoadTime', node)
        if value is not None and 'StartLoadTime' not in already_processed:
            already_processed.add('StartLoadTime')
            self.StartLoadTime = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PurchaseOrderInformation':
            obj_ = PurchaseOrderInformation.factory()
            obj_.build(child_)
            self.set_PurchaseOrderInformation(obj_)
        elif nodeName_ == 'SupplierInformation':
            obj_ = CompanyInformationType.factory()
            obj_.build(child_)
            self.set_SupplierInformation(obj_)
        elif nodeName_ == 'ExchangeOrThroughputPartnerInformation':
            obj_ = CompanyInformationType.factory()
            obj_.build(child_)
            self.set_ExchangeOrThroughputPartnerInformation(obj_)
        elif nodeName_ == 'ThirdParty':
            obj_ = CompanyInformationType.factory()
            obj_.build(child_)
            self.ThirdParty.append(obj_)
        elif nodeName_ == 'FinalShipper':
            obj_ = CompanyInformationType.factory()
            obj_.build(child_)
            self.set_FinalShipper(obj_)
        elif nodeName_ == 'TerminalInformation':
            obj_ = TerminalInformationType.factory()
            obj_.build(child_)
            self.set_TerminalInformation(obj_)
        elif nodeName_ == 'CarrierInformation':
            obj_ = CarrierInformationType.factory()
            obj_.build(child_)
            self.set_CarrierInformation(obj_)
        elif nodeName_ == 'BillToInformation':
            obj_ = BillToInformationType.factory()
            obj_.build(child_)
            self.set_BillToInformation(obj_)
        elif nodeName_ == 'ShipToInformation':
            obj_ = ShipToInformationType.factory()
            obj_.build(child_)
            self.set_ShipToInformation(obj_)
# end class BillOfLadingHeaderType


class BillOfLadingSummaryType(GeneratedsSuper):
    """Specifies the total number of finished products.The sum of the
    GrossQuantity element values directly beneath (one level below)
    the FinishedProduct elements – regardless of the UOM. This is
    used as a checksum for the document.The sum of the NetQuantity
    element values directly beneath (one level below) the
    FinishedProduct elements – regardless of the UOM. This is used
    as a checksum for the document."""
    subclass = None
    superclass = None
    def __init__(self, FinishedProductCount=None, GrossQuantityTotal=None, NetQuantityTotal=None):
        self.FinishedProductCount = _cast(int, FinishedProductCount)
        self.GrossQuantityTotal = _cast(float, GrossQuantityTotal)
        self.NetQuantityTotal = _cast(float, NetQuantityTotal)
        pass
    def factory(*args_, **kwargs_):
        if BillOfLadingSummaryType.subclass:
            return BillOfLadingSummaryType.subclass(*args_, **kwargs_)
        else:
            return BillOfLadingSummaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinishedProductCount(self): return self.FinishedProductCount
    def set_FinishedProductCount(self, FinishedProductCount): self.FinishedProductCount = FinishedProductCount
    def get_GrossQuantityTotal(self): return self.GrossQuantityTotal
    def set_GrossQuantityTotal(self, GrossQuantityTotal): self.GrossQuantityTotal = GrossQuantityTotal
    def get_NetQuantityTotal(self): return self.NetQuantityTotal
    def set_NetQuantityTotal(self, NetQuantityTotal): self.NetQuantityTotal = NetQuantityTotal
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BillOfLadingSummaryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillOfLadingSummaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BillOfLadingSummaryType'):
        if self.FinishedProductCount is not None and 'FinishedProductCount' not in already_processed:
            already_processed.add('FinishedProductCount')
            outfile.write(' FinishedProductCount="%s"' % self.gds_format_integer(self.FinishedProductCount, input_name='FinishedProductCount'))
        if self.GrossQuantityTotal is not None and 'GrossQuantityTotal' not in already_processed:
            already_processed.add('GrossQuantityTotal')
            outfile.write(' GrossQuantityTotal="%s"' % self.gds_format_float(self.GrossQuantityTotal, input_name='GrossQuantityTotal'))
        if self.NetQuantityTotal is not None and 'NetQuantityTotal' not in already_processed:
            already_processed.add('NetQuantityTotal')
            outfile.write(' NetQuantityTotal="%s"' % self.gds_format_float(self.NetQuantityTotal, input_name='NetQuantityTotal'))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BillOfLadingSummaryType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BillOfLadingSummaryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FinishedProductCount is not None and 'FinishedProductCount' not in already_processed:
            already_processed.add('FinishedProductCount')
            showIndent(outfile, level)
            outfile.write('FinishedProductCount = %d,\n' % (self.FinishedProductCount,))
        if self.GrossQuantityTotal is not None and 'GrossQuantityTotal' not in already_processed:
            already_processed.add('GrossQuantityTotal')
            showIndent(outfile, level)
            outfile.write('GrossQuantityTotal = %f,\n' % (self.GrossQuantityTotal,))
        if self.NetQuantityTotal is not None and 'NetQuantityTotal' not in already_processed:
            already_processed.add('NetQuantityTotal')
            showIndent(outfile, level)
            outfile.write('NetQuantityTotal = %f,\n' % (self.NetQuantityTotal,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FinishedProductCount', node)
        if value is not None and 'FinishedProductCount' not in already_processed:
            already_processed.add('FinishedProductCount')
            try:
                self.FinishedProductCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('GrossQuantityTotal', node)
        if value is not None and 'GrossQuantityTotal' not in already_processed:
            already_processed.add('GrossQuantityTotal')
            try:
                self.GrossQuantityTotal = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (GrossQuantityTotal): %s' % exp)
        value = find_attr_value_('NetQuantityTotal', node)
        if value is not None and 'NetQuantityTotal' not in already_processed:
            already_processed.add('NetQuantityTotal')
            try:
                self.NetQuantityTotal = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (NetQuantityTotal): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BillOfLadingSummaryType


class BillOfLadingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transactionPurposeIndicator=None, version=None, documentIdentifier=None, BillOfLadingHeader=None, BillOfLadingDetails=None, BillOfLadingSummary=None):
        self.transactionPurposeIndicator = _cast(None, transactionPurposeIndicator)
        self.version = _cast(None, version)
        self.documentIdentifier = _cast(None, documentIdentifier)
        self.BillOfLadingHeader = BillOfLadingHeader
        self.BillOfLadingDetails = BillOfLadingDetails
        self.BillOfLadingSummary = BillOfLadingSummary
    def factory(*args_, **kwargs_):
        if BillOfLadingType.subclass:
            return BillOfLadingType.subclass(*args_, **kwargs_)
        else:
            return BillOfLadingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BillOfLadingHeader(self): return self.BillOfLadingHeader
    def set_BillOfLadingHeader(self, BillOfLadingHeader): self.BillOfLadingHeader = BillOfLadingHeader
    def get_BillOfLadingDetails(self): return self.BillOfLadingDetails
    def set_BillOfLadingDetails(self, BillOfLadingDetails): self.BillOfLadingDetails = BillOfLadingDetails
    def get_BillOfLadingSummary(self): return self.BillOfLadingSummary
    def set_BillOfLadingSummary(self, BillOfLadingSummary): self.BillOfLadingSummary = BillOfLadingSummary
    def get_transactionPurposeIndicator(self): return self.transactionPurposeIndicator
    def set_transactionPurposeIndicator(self, transactionPurposeIndicator): self.transactionPurposeIndicator = transactionPurposeIndicator
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_documentIdentifier(self): return self.documentIdentifier
    def set_documentIdentifier(self, documentIdentifier): self.documentIdentifier = documentIdentifier
    def hasContent_(self):
        if (
            self.BillOfLadingHeader is not None or
            self.BillOfLadingDetails is not None or
            self.BillOfLadingSummary is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BillOfLadingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillOfLadingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BillOfLadingType'):
        if self.transactionPurposeIndicator is not None and 'transactionPurposeIndicator' not in already_processed:
            already_processed.add('transactionPurposeIndicator')
            outfile.write(' transactionPurposeIndicator=%s' % (self.gds_format_string(quote_attrib(self.transactionPurposeIndicator).encode(ExternalEncoding), input_name='transactionPurposeIndicator'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.documentIdentifier is not None and 'documentIdentifier' not in already_processed:
            already_processed.add('documentIdentifier')
            outfile.write(' documentIdentifier=%s' % (self.gds_format_string(quote_attrib(self.documentIdentifier).encode(ExternalEncoding), input_name='documentIdentifier'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BillOfLadingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BillOfLadingHeader is not None:
            self.BillOfLadingHeader.export(outfile, level, namespace_, name_='BillOfLadingHeader', pretty_print=pretty_print)
        if self.BillOfLadingDetails is not None:
            self.BillOfLadingDetails.export(outfile, level, namespace_, name_='BillOfLadingDetails', pretty_print=pretty_print)
        if self.BillOfLadingSummary is not None:
            self.BillOfLadingSummary.export(outfile, level, namespace_, name_='BillOfLadingSummary', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillOfLadingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transactionPurposeIndicator is not None and 'transactionPurposeIndicator' not in already_processed:
            already_processed.add('transactionPurposeIndicator')
            showIndent(outfile, level)
            outfile.write('transactionPurposeIndicator = "%s",\n' % (self.transactionPurposeIndicator,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.documentIdentifier is not None and 'documentIdentifier' not in already_processed:
            already_processed.add('documentIdentifier')
            showIndent(outfile, level)
            outfile.write('documentIdentifier = "%s",\n' % (self.documentIdentifier,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BillOfLadingHeader is not None:
            showIndent(outfile, level)
            outfile.write('BillOfLadingHeader=model_.BillOfLadingHeader(\n')
            self.BillOfLadingHeader.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BillOfLadingDetails is not None:
            showIndent(outfile, level)
            outfile.write('BillOfLadingDetails=model_.BillOfLadingDetails(\n')
            self.BillOfLadingDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BillOfLadingSummary is not None:
            showIndent(outfile, level)
            outfile.write('BillOfLadingSummary=model_.BillOfLadingSummary(\n')
            self.BillOfLadingSummary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transactionPurposeIndicator', node)
        if value is not None and 'transactionPurposeIndicator' not in already_processed:
            already_processed.add('transactionPurposeIndicator')
            self.transactionPurposeIndicator = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('documentIdentifier', node)
        if value is not None and 'documentIdentifier' not in already_processed:
            already_processed.add('documentIdentifier')
            self.documentIdentifier = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BillOfLadingHeader':
            obj_ = BillOfLadingHeaderType.factory()
            obj_.build(child_)
            self.set_BillOfLadingHeader(obj_)
        elif nodeName_ == 'BillOfLadingDetails':
            obj_ = BillOfLadingDetailsType.factory()
            obj_.build(child_)
            self.set_BillOfLadingDetails(obj_)
        elif nodeName_ == 'BillOfLadingSummary':
            obj_ = BillOfLadingSummaryType.factory()
            obj_.build(child_)
            self.set_BillOfLadingSummary(obj_)
# end class BillOfLadingType


class BillToInformationType(GeneratedsSuper):
    """2 numerics followed by a dash, followed by 7 digits."""
    subclass = None
    superclass = None
    def __init__(self, ContractID=None, BillToID=None, BillToFEIN=None, ContractName=None, BillToName=None, AddressInformation=None, ShipperInformation=None):
        self.ContractID = _cast(None, ContractID)
        self.BillToID = _cast(None, BillToID)
        self.BillToFEIN = _cast(None, BillToFEIN)
        self.ContractName = _cast(None, ContractName)
        self.BillToName = _cast(None, BillToName)
        self.AddressInformation = AddressInformation
        self.ShipperInformation = ShipperInformation
    def factory(*args_, **kwargs_):
        if BillToInformationType.subclass:
            return BillToInformationType.subclass(*args_, **kwargs_)
        else:
            return BillToInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_ShipperInformation(self): return self.ShipperInformation
    def set_ShipperInformation(self, ShipperInformation): self.ShipperInformation = ShipperInformation
    def get_ContractID(self): return self.ContractID
    def set_ContractID(self, ContractID): self.ContractID = ContractID
    def get_BillToID(self): return self.BillToID
    def set_BillToID(self, BillToID): self.BillToID = BillToID
    def get_BillToFEIN(self): return self.BillToFEIN
    def set_BillToFEIN(self, BillToFEIN): self.BillToFEIN = BillToFEIN
    def get_ContractName(self): return self.ContractName
    def set_ContractName(self, ContractName): self.ContractName = ContractName
    def get_BillToName(self): return self.BillToName
    def set_BillToName(self, BillToName): self.BillToName = BillToName
    def hasContent_(self):
        if (
            self.AddressInformation is not None or
            self.ShipperInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BillToInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillToInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BillToInformationType'):
        if self.ContractID is not None and 'ContractID' not in already_processed:
            already_processed.add('ContractID')
            outfile.write(' ContractID=%s' % (self.gds_format_string(quote_attrib(self.ContractID).encode(ExternalEncoding), input_name='ContractID'), ))
        if self.BillToID is not None and 'BillToID' not in already_processed:
            already_processed.add('BillToID')
            outfile.write(' BillToID=%s' % (self.gds_format_string(quote_attrib(self.BillToID).encode(ExternalEncoding), input_name='BillToID'), ))
        if self.BillToFEIN is not None and 'BillToFEIN' not in already_processed:
            already_processed.add('BillToFEIN')
            outfile.write(' BillToFEIN=%s' % (quote_attrib(self.BillToFEIN), ))
        if self.ContractName is not None and 'ContractName' not in already_processed:
            already_processed.add('ContractName')
            outfile.write(' ContractName=%s' % (self.gds_format_string(quote_attrib(self.ContractName).encode(ExternalEncoding), input_name='ContractName'), ))
        if self.BillToName is not None and 'BillToName' not in already_processed:
            already_processed.add('BillToName')
            outfile.write(' BillToName=%s' % (self.gds_format_string(quote_attrib(self.BillToName).encode(ExternalEncoding), input_name='BillToName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BillToInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.ShipperInformation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShipperInformation>%s</%sShipperInformation>%s' % (namespace_, self.gds_format_string(quote_xml(self.ShipperInformation).encode(ExternalEncoding), input_name='ShipperInformation'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BillToInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ContractID is not None and 'ContractID' not in already_processed:
            already_processed.add('ContractID')
            showIndent(outfile, level)
            outfile.write('ContractID = "%s",\n' % (self.ContractID,))
        if self.BillToID is not None and 'BillToID' not in already_processed:
            already_processed.add('BillToID')
            showIndent(outfile, level)
            outfile.write('BillToID = "%s",\n' % (self.BillToID,))
        if self.BillToFEIN is not None and 'BillToFEIN' not in already_processed:
            already_processed.add('BillToFEIN')
            showIndent(outfile, level)
            outfile.write('BillToFEIN = %s,\n' % (self.BillToFEIN,))
        if self.ContractName is not None and 'ContractName' not in already_processed:
            already_processed.add('ContractName')
            showIndent(outfile, level)
            outfile.write('ContractName = "%s",\n' % (self.ContractName,))
        if self.BillToName is not None and 'BillToName' not in already_processed:
            already_processed.add('BillToName')
            showIndent(outfile, level)
            outfile.write('BillToName = "%s",\n' % (self.BillToName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShipperInformation is not None:
            showIndent(outfile, level)
            outfile.write('ShipperInformation=%s,\n' % quote_python(self.ShipperInformation).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ContractID', node)
        if value is not None and 'ContractID' not in already_processed:
            already_processed.add('ContractID')
            self.ContractID = value
        value = find_attr_value_('BillToID', node)
        if value is not None and 'BillToID' not in already_processed:
            already_processed.add('BillToID')
            self.BillToID = value
        value = find_attr_value_('BillToFEIN', node)
        if value is not None and 'BillToFEIN' not in already_processed:
            already_processed.add('BillToFEIN')
            self.BillToFEIN = value
        value = find_attr_value_('ContractName', node)
        if value is not None and 'ContractName' not in already_processed:
            already_processed.add('ContractName')
            self.ContractName = value
        value = find_attr_value_('BillToName', node)
        if value is not None and 'BillToName' not in already_processed:
            already_processed.add('BillToName')
            self.BillToName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'ShipperInformation':
            ShipperInformation_ = child_.text
            ShipperInformation_ = self.gds_validate_string(ShipperInformation_, node, 'ShipperInformation')
            self.ShipperInformation = ShipperInformation_
# end class BillToInformationType


class CarrierInformationType(GeneratedsSuper):
    """2 numerics followed by a dash, followed by 7 digits.A number or code
    used by the terminal automation system to uniquely identify the
    carrier of the product.SCAC stands for Standard Carrier Alpha
    Code.Specifies whether a truck is loaded at multiple lanes at
    the terminal truck rack."""
    subclass = None
    superclass = None
    def __init__(self, SplitLoading=None, CarrierSCAC=None, CarrierID=None, CarrierFEIN=None, CarrierName=None, AddressInformation=None, DriverInformation=None, VehicleInformation=None):
        self.SplitLoading = _cast(bool, SplitLoading)
        self.CarrierSCAC = _cast(None, CarrierSCAC)
        self.CarrierID = _cast(None, CarrierID)
        self.CarrierFEIN = _cast(None, CarrierFEIN)
        self.CarrierName = _cast(None, CarrierName)
        self.AddressInformation = AddressInformation
        self.DriverInformation = DriverInformation
        if VehicleInformation is None:
            self.VehicleInformation = []
        else:
            self.VehicleInformation = VehicleInformation
    def factory(*args_, **kwargs_):
        if CarrierInformationType.subclass:
            return CarrierInformationType.subclass(*args_, **kwargs_)
        else:
            return CarrierInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_DriverInformation(self): return self.DriverInformation
    def set_DriverInformation(self, DriverInformation): self.DriverInformation = DriverInformation
    def get_VehicleInformation(self): return self.VehicleInformation
    def set_VehicleInformation(self, VehicleInformation): self.VehicleInformation = VehicleInformation
    def add_VehicleInformation(self, value): self.VehicleInformation.append(value)
    def insert_VehicleInformation(self, index, value): self.VehicleInformation[index] = value
    def get_SplitLoading(self): return self.SplitLoading
    def set_SplitLoading(self, SplitLoading): self.SplitLoading = SplitLoading
    def get_CarrierSCAC(self): return self.CarrierSCAC
    def set_CarrierSCAC(self, CarrierSCAC): self.CarrierSCAC = CarrierSCAC
    def get_CarrierID(self): return self.CarrierID
    def set_CarrierID(self, CarrierID): self.CarrierID = CarrierID
    def get_CarrierFEIN(self): return self.CarrierFEIN
    def set_CarrierFEIN(self, CarrierFEIN): self.CarrierFEIN = CarrierFEIN
    def get_CarrierName(self): return self.CarrierName
    def set_CarrierName(self, CarrierName): self.CarrierName = CarrierName
    def hasContent_(self):
        if (
            self.AddressInformation is not None or
            self.DriverInformation is not None or
            self.VehicleInformation
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CarrierInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CarrierInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CarrierInformationType'):
        if self.SplitLoading is not None and 'SplitLoading' not in already_processed:
            already_processed.add('SplitLoading')
            outfile.write(' SplitLoading="%s"' % self.gds_format_boolean(self.SplitLoading, input_name='SplitLoading'))
        if self.CarrierSCAC is not None and 'CarrierSCAC' not in already_processed:
            already_processed.add('CarrierSCAC')
            outfile.write(' CarrierSCAC=%s' % (self.gds_format_string(quote_attrib(self.CarrierSCAC).encode(ExternalEncoding), input_name='CarrierSCAC'), ))
        if self.CarrierID is not None and 'CarrierID' not in already_processed:
            already_processed.add('CarrierID')
            outfile.write(' CarrierID=%s' % (self.gds_format_string(quote_attrib(self.CarrierID).encode(ExternalEncoding), input_name='CarrierID'), ))
        if self.CarrierFEIN is not None and 'CarrierFEIN' not in already_processed:
            already_processed.add('CarrierFEIN')
            outfile.write(' CarrierFEIN=%s' % (quote_attrib(self.CarrierFEIN), ))
        if self.CarrierName is not None and 'CarrierName' not in already_processed:
            already_processed.add('CarrierName')
            outfile.write(' CarrierName=%s' % (self.gds_format_string(quote_attrib(self.CarrierName).encode(ExternalEncoding), input_name='CarrierName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CarrierInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.DriverInformation is not None:
            self.DriverInformation.export(outfile, level, namespace_, name_='DriverInformation', pretty_print=pretty_print)
        for VehicleInformation_ in self.VehicleInformation:
            VehicleInformation_.export(outfile, level, namespace_, name_='VehicleInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CarrierInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SplitLoading is not None and 'SplitLoading' not in already_processed:
            already_processed.add('SplitLoading')
            showIndent(outfile, level)
            outfile.write('SplitLoading = %s,\n' % (self.SplitLoading,))
        if self.CarrierSCAC is not None and 'CarrierSCAC' not in already_processed:
            already_processed.add('CarrierSCAC')
            showIndent(outfile, level)
            outfile.write('CarrierSCAC = "%s",\n' % (self.CarrierSCAC,))
        if self.CarrierID is not None and 'CarrierID' not in already_processed:
            already_processed.add('CarrierID')
            showIndent(outfile, level)
            outfile.write('CarrierID = "%s",\n' % (self.CarrierID,))
        if self.CarrierFEIN is not None and 'CarrierFEIN' not in already_processed:
            already_processed.add('CarrierFEIN')
            showIndent(outfile, level)
            outfile.write('CarrierFEIN = %s,\n' % (self.CarrierFEIN,))
        if self.CarrierName is not None and 'CarrierName' not in already_processed:
            already_processed.add('CarrierName')
            showIndent(outfile, level)
            outfile.write('CarrierName = "%s",\n' % (self.CarrierName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DriverInformation is not None:
            showIndent(outfile, level)
            outfile.write('DriverInformation=model_.DriverInformation(\n')
            self.DriverInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('VehicleInformation=[\n')
        level += 1
        for VehicleInformation_ in self.VehicleInformation:
            showIndent(outfile, level)
            outfile.write('model_.VehicleInformation(\n')
            VehicleInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SplitLoading', node)
        if value is not None and 'SplitLoading' not in already_processed:
            already_processed.add('SplitLoading')
            if value in ('true', '1'):
                self.SplitLoading = True
            elif value in ('false', '0'):
                self.SplitLoading = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CarrierSCAC', node)
        if value is not None and 'CarrierSCAC' not in already_processed:
            already_processed.add('CarrierSCAC')
            self.CarrierSCAC = value
        value = find_attr_value_('CarrierID', node)
        if value is not None and 'CarrierID' not in already_processed:
            already_processed.add('CarrierID')
            self.CarrierID = value
        value = find_attr_value_('CarrierFEIN', node)
        if value is not None and 'CarrierFEIN' not in already_processed:
            already_processed.add('CarrierFEIN')
            self.CarrierFEIN = value
        value = find_attr_value_('CarrierName', node)
        if value is not None and 'CarrierName' not in already_processed:
            already_processed.add('CarrierName')
            self.CarrierName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'DriverInformation':
            obj_ = DriverInformationType.factory()
            obj_.build(child_)
            self.set_DriverInformation(obj_)
        elif nodeName_ == 'VehicleInformation':
            obj_ = VehicleInformation.factory()
            obj_.build(child_)
            self.VehicleInformation.append(obj_)
# end class CarrierInformationType


class DriverInformationType(GeneratedsSuper):
    """Data that belongs to the Terminal Automation System."""
    subclass = None
    superclass = None
    def __init__(self, DriverID=None, DriverName=None, Signature=None, SecondaryDriverID=None):
        self.DriverID = _cast(None, DriverID)
        self.DriverName = _cast(None, DriverName)
        self.Signature = _cast(None, Signature)
        self.SecondaryDriverID = SecondaryDriverID
    def factory(*args_, **kwargs_):
        if DriverInformationType.subclass:
            return DriverInformationType.subclass(*args_, **kwargs_)
        else:
            return DriverInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SecondaryDriverID(self): return self.SecondaryDriverID
    def set_SecondaryDriverID(self, SecondaryDriverID): self.SecondaryDriverID = SecondaryDriverID
    def get_DriverID(self): return self.DriverID
    def set_DriverID(self, DriverID): self.DriverID = DriverID
    def get_DriverName(self): return self.DriverName
    def set_DriverName(self, DriverName): self.DriverName = DriverName
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.SecondaryDriverID is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='DriverInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DriverInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='DriverInformationType'):
        if self.DriverID is not None and 'DriverID' not in already_processed:
            already_processed.add('DriverID')
            outfile.write(' DriverID=%s' % (self.gds_format_string(quote_attrib(self.DriverID).encode(ExternalEncoding), input_name='DriverID'), ))
        if self.DriverName is not None and 'DriverName' not in already_processed:
            already_processed.add('DriverName')
            outfile.write(' DriverName=%s' % (self.gds_format_string(quote_attrib(self.DriverName).encode(ExternalEncoding), input_name='DriverName'), ))
        if self.Signature is not None and 'Signature' not in already_processed:
            already_processed.add('Signature')
            outfile.write(' Signature=%s' % (self.gds_format_string(quote_attrib(self.Signature).encode(ExternalEncoding), input_name='Signature'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='DriverInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SecondaryDriverID is not None:
            self.SecondaryDriverID.export(outfile, level, namespace_, name_='SecondaryDriverID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DriverInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DriverID is not None and 'DriverID' not in already_processed:
            already_processed.add('DriverID')
            showIndent(outfile, level)
            outfile.write('DriverID = "%s",\n' % (self.DriverID,))
        if self.DriverName is not None and 'DriverName' not in already_processed:
            already_processed.add('DriverName')
            showIndent(outfile, level)
            outfile.write('DriverName = "%s",\n' % (self.DriverName,))
        if self.Signature is not None and 'Signature' not in already_processed:
            already_processed.add('Signature')
            showIndent(outfile, level)
            outfile.write('Signature = "%s",\n' % (self.Signature,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SecondaryDriverID is not None:
            showIndent(outfile, level)
            outfile.write('SecondaryDriverID=model_.SecondaryDriverID(\n')
            self.SecondaryDriverID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DriverID', node)
        if value is not None and 'DriverID' not in already_processed:
            already_processed.add('DriverID')
            self.DriverID = value
        value = find_attr_value_('DriverName', node)
        if value is not None and 'DriverName' not in already_processed:
            already_processed.add('DriverName')
            self.DriverName = value
        value = find_attr_value_('Signature', node)
        if value is not None and 'Signature' not in already_processed:
            already_processed.add('Signature')
            self.Signature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SecondaryDriverID':
            obj_ = SecondaryDriverIDType.factory()
            obj_.build(child_)
            self.set_SecondaryDriverID(obj_)
# end class DriverInformationType


class SecondaryDriverIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Issuer=None, IdentType=None):
        self.Issuer = _cast(None, Issuer)
        self.IdentType = _cast(None, IdentType)
        pass
    def factory(*args_, **kwargs_):
        if SecondaryDriverIDType.subclass:
            return SecondaryDriverIDType.subclass(*args_, **kwargs_)
        else:
            return SecondaryDriverIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Issuer(self): return self.Issuer
    def set_Issuer(self, Issuer): self.Issuer = Issuer
    def get_IdentType(self): return self.IdentType
    def set_IdentType(self, IdentType): self.IdentType = IdentType
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SecondaryDriverIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondaryDriverIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SecondaryDriverIDType'):
        if self.Issuer is not None and 'Issuer' not in already_processed:
            already_processed.add('Issuer')
            outfile.write(' Issuer=%s' % (self.gds_format_string(quote_attrib(self.Issuer).encode(ExternalEncoding), input_name='Issuer'), ))
        if self.IdentType is not None and 'IdentType' not in already_processed:
            already_processed.add('IdentType')
            outfile.write(' IdentType=%s' % (self.gds_format_string(quote_attrib(self.IdentType).encode(ExternalEncoding), input_name='IdentType'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SecondaryDriverIDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SecondaryDriverIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Issuer is not None and 'Issuer' not in already_processed:
            already_processed.add('Issuer')
            showIndent(outfile, level)
            outfile.write('Issuer = "%s",\n' % (self.Issuer,))
        if self.IdentType is not None and 'IdentType' not in already_processed:
            already_processed.add('IdentType')
            showIndent(outfile, level)
            outfile.write('IdentType = "%s",\n' % (self.IdentType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Issuer', node)
        if value is not None and 'Issuer' not in already_processed:
            already_processed.add('Issuer')
            self.Issuer = value
        value = find_attr_value_('IdentType', node)
        if value is not None and 'IdentType' not in already_processed:
            already_processed.add('IdentType')
            self.IdentType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SecondaryDriverIDType


class ShipToInformationType(GeneratedsSuper):
    """Refers to PDXB v3: DestinationCountyCodeSpecifies the name of a
    receiver of a product. In some cases this may be the marketer.
    In other cases, this may be the end location.Specifies the state
    to which goods are shipped."""
    subclass = None
    superclass = None
    def __init__(self, ShipToStateCode=None, ShipToCityCode=None, ShipToCountyCode=None, ShipToName=None, ShipToID=None, AddressInformation=None):
        self.ShipToStateCode = _cast(None, ShipToStateCode)
        self.ShipToCityCode = _cast(None, ShipToCityCode)
        self.ShipToCountyCode = _cast(None, ShipToCountyCode)
        self.ShipToName = _cast(None, ShipToName)
        self.ShipToID = _cast(None, ShipToID)
        self.AddressInformation = AddressInformation
    def factory(*args_, **kwargs_):
        if ShipToInformationType.subclass:
            return ShipToInformationType.subclass(*args_, **kwargs_)
        else:
            return ShipToInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_ShipToStateCode(self): return self.ShipToStateCode
    def set_ShipToStateCode(self, ShipToStateCode): self.ShipToStateCode = ShipToStateCode
    def get_ShipToCityCode(self): return self.ShipToCityCode
    def set_ShipToCityCode(self, ShipToCityCode): self.ShipToCityCode = ShipToCityCode
    def get_ShipToCountyCode(self): return self.ShipToCountyCode
    def set_ShipToCountyCode(self, ShipToCountyCode): self.ShipToCountyCode = ShipToCountyCode
    def get_ShipToName(self): return self.ShipToName
    def set_ShipToName(self, ShipToName): self.ShipToName = ShipToName
    def get_ShipToID(self): return self.ShipToID
    def set_ShipToID(self, ShipToID): self.ShipToID = ShipToID
    def hasContent_(self):
        if (
            self.AddressInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ShipToInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipToInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ShipToInformationType'):
        if self.ShipToStateCode is not None and 'ShipToStateCode' not in already_processed:
            already_processed.add('ShipToStateCode')
            outfile.write(' ShipToStateCode=%s' % (self.gds_format_string(quote_attrib(self.ShipToStateCode).encode(ExternalEncoding), input_name='ShipToStateCode'), ))
        if self.ShipToCityCode is not None and 'ShipToCityCode' not in already_processed:
            already_processed.add('ShipToCityCode')
            outfile.write(' ShipToCityCode=%s' % (self.gds_format_string(quote_attrib(self.ShipToCityCode).encode(ExternalEncoding), input_name='ShipToCityCode'), ))
        if self.ShipToCountyCode is not None and 'ShipToCountyCode' not in already_processed:
            already_processed.add('ShipToCountyCode')
            outfile.write(' ShipToCountyCode=%s' % (self.gds_format_string(quote_attrib(self.ShipToCountyCode).encode(ExternalEncoding), input_name='ShipToCountyCode'), ))
        if self.ShipToName is not None and 'ShipToName' not in already_processed:
            already_processed.add('ShipToName')
            outfile.write(' ShipToName=%s' % (self.gds_format_string(quote_attrib(self.ShipToName).encode(ExternalEncoding), input_name='ShipToName'), ))
        if self.ShipToID is not None and 'ShipToID' not in already_processed:
            already_processed.add('ShipToID')
            outfile.write(' ShipToID=%s' % (self.gds_format_string(quote_attrib(self.ShipToID).encode(ExternalEncoding), input_name='ShipToID'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ShipToInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ShipToInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ShipToStateCode is not None and 'ShipToStateCode' not in already_processed:
            already_processed.add('ShipToStateCode')
            showIndent(outfile, level)
            outfile.write('ShipToStateCode = "%s",\n' % (self.ShipToStateCode,))
        if self.ShipToCityCode is not None and 'ShipToCityCode' not in already_processed:
            already_processed.add('ShipToCityCode')
            showIndent(outfile, level)
            outfile.write('ShipToCityCode = "%s",\n' % (self.ShipToCityCode,))
        if self.ShipToCountyCode is not None and 'ShipToCountyCode' not in already_processed:
            already_processed.add('ShipToCountyCode')
            showIndent(outfile, level)
            outfile.write('ShipToCountyCode = "%s",\n' % (self.ShipToCountyCode,))
        if self.ShipToName is not None and 'ShipToName' not in already_processed:
            already_processed.add('ShipToName')
            showIndent(outfile, level)
            outfile.write('ShipToName = "%s",\n' % (self.ShipToName,))
        if self.ShipToID is not None and 'ShipToID' not in already_processed:
            already_processed.add('ShipToID')
            showIndent(outfile, level)
            outfile.write('ShipToID = "%s",\n' % (self.ShipToID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ShipToStateCode', node)
        if value is not None and 'ShipToStateCode' not in already_processed:
            already_processed.add('ShipToStateCode')
            self.ShipToStateCode = value
        value = find_attr_value_('ShipToCityCode', node)
        if value is not None and 'ShipToCityCode' not in already_processed:
            already_processed.add('ShipToCityCode')
            self.ShipToCityCode = value
        value = find_attr_value_('ShipToCountyCode', node)
        if value is not None and 'ShipToCountyCode' not in already_processed:
            already_processed.add('ShipToCountyCode')
            self.ShipToCountyCode = value
        value = find_attr_value_('ShipToName', node)
        if value is not None and 'ShipToName' not in already_processed:
            already_processed.add('ShipToName')
            self.ShipToName = value
        value = find_attr_value_('ShipToID', node)
        if value is not None and 'ShipToID' not in already_processed:
            already_processed.add('ShipToID')
            self.ShipToID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
# end class ShipToInformationType


class VehicleInformationType(GeneratedsSuper):
    """An identifier used for the vehicle/transport involved."""
    subclass = None
    superclass = None
    def __init__(self, VehicleType=None, VehicleNumber=None, extensiontype_=None):
        self.VehicleType = _cast(None, VehicleType)
        self.VehicleNumber = _cast(None, VehicleNumber)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VehicleInformationType.subclass:
            return VehicleInformationType.subclass(*args_, **kwargs_)
        else:
            return VehicleInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VehicleType(self): return self.VehicleType
    def set_VehicleType(self, VehicleType): self.VehicleType = VehicleType
    def get_VehicleNumber(self): return self.VehicleNumber
    def set_VehicleNumber(self, VehicleNumber): self.VehicleNumber = VehicleNumber
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='VehicleInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VehicleInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='VehicleInformationType'):
        if self.VehicleType is not None and 'VehicleType' not in already_processed:
            already_processed.add('VehicleType')
            outfile.write(' VehicleType=%s' % (quote_attrib(self.VehicleType), ))
        if self.VehicleNumber is not None and 'VehicleNumber' not in already_processed:
            already_processed.add('VehicleNumber')
            outfile.write(' VehicleNumber=%s' % (self.gds_format_string(quote_attrib(self.VehicleNumber).encode(ExternalEncoding), input_name='VehicleNumber'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='VehicleInformationType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VehicleInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VehicleType is not None and 'VehicleType' not in already_processed:
            already_processed.add('VehicleType')
            showIndent(outfile, level)
            outfile.write('VehicleType = %s,\n' % (self.VehicleType,))
        if self.VehicleNumber is not None and 'VehicleNumber' not in already_processed:
            already_processed.add('VehicleNumber')
            showIndent(outfile, level)
            outfile.write('VehicleNumber = "%s",\n' % (self.VehicleNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('VehicleType', node)
        if value is not None and 'VehicleType' not in already_processed:
            already_processed.add('VehicleType')
            self.VehicleType = value
        value = find_attr_value_('VehicleNumber', node)
        if value is not None and 'VehicleNumber' not in already_processed:
            already_processed.add('VehicleNumber')
            self.VehicleNumber = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VehicleInformationType


class AccountInformation(GeneratedsSuper):
    """Structure which contains information about the accounts involved in
    the transaction."""
    subclass = None
    superclass = None
    def __init__(self, AccountHolderName=None, AccountNumber=None, FinancialInstitution=None, FinancialInstitutionDFINumber=None, CreditCardNumber=None, CreditCardType=None, ExpireDate=None):
        self.AccountHolderName = AccountHolderName
        self.AccountNumber = AccountNumber
        self.FinancialInstitution = FinancialInstitution
        self.FinancialInstitutionDFINumber = FinancialInstitutionDFINumber
        self.CreditCardNumber = CreditCardNumber
        self.CreditCardType = CreditCardType
        self.ExpireDate = ExpireDate
    def factory(*args_, **kwargs_):
        if AccountInformation.subclass:
            return AccountInformation.subclass(*args_, **kwargs_)
        else:
            return AccountInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountHolderName(self): return self.AccountHolderName
    def set_AccountHolderName(self, AccountHolderName): self.AccountHolderName = AccountHolderName
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    def get_FinancialInstitution(self): return self.FinancialInstitution
    def set_FinancialInstitution(self, FinancialInstitution): self.FinancialInstitution = FinancialInstitution
    def get_FinancialInstitutionDFINumber(self): return self.FinancialInstitutionDFINumber
    def set_FinancialInstitutionDFINumber(self, FinancialInstitutionDFINumber): self.FinancialInstitutionDFINumber = FinancialInstitutionDFINumber
    def get_CreditCardNumber(self): return self.CreditCardNumber
    def set_CreditCardNumber(self, CreditCardNumber): self.CreditCardNumber = CreditCardNumber
    def get_CreditCardType(self): return self.CreditCardType
    def set_CreditCardType(self, CreditCardType): self.CreditCardType = CreditCardType
    def get_ExpireDate(self): return self.ExpireDate
    def set_ExpireDate(self, ExpireDate): self.ExpireDate = ExpireDate
    def hasContent_(self):
        if (
            self.AccountHolderName is not None or
            self.AccountNumber is not None or
            self.FinancialInstitution is not None or
            self.FinancialInstitutionDFINumber is not None or
            self.CreditCardNumber is not None or
            self.CreditCardType is not None or
            self.ExpireDate is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AccountInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AccountInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AccountInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountHolderName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccountHolderName>%s</%sAccountHolderName>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccountHolderName).encode(ExternalEncoding), input_name='AccountHolderName'), namespace_, eol_))
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccountNumber>%s</%sAccountNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccountNumber).encode(ExternalEncoding), input_name='AccountNumber'), namespace_, eol_))
        if self.FinancialInstitution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFinancialInstitution>%s</%sFinancialInstitution>%s' % (namespace_, self.gds_format_string(quote_xml(self.FinancialInstitution).encode(ExternalEncoding), input_name='FinancialInstitution'), namespace_, eol_))
        if self.FinancialInstitutionDFINumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFinancialInstitutionDFINumber>%s</%sFinancialInstitutionDFINumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.FinancialInstitutionDFINumber).encode(ExternalEncoding), input_name='FinancialInstitutionDFINumber'), namespace_, eol_))
        if self.CreditCardNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreditCardNumber>%s</%sCreditCardNumber>%s' % (namespace_, self.gds_format_integer(self.CreditCardNumber, input_name='CreditCardNumber'), namespace_, eol_))
        if self.CreditCardType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreditCardType>%s</%sCreditCardType>%s' % (namespace_, self.gds_format_string(quote_xml(self.CreditCardType).encode(ExternalEncoding), input_name='CreditCardType'), namespace_, eol_))
        if self.ExpireDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExpireDate>%s</%sExpireDate>%s' % (namespace_, self.gds_format_datetime(self.ExpireDate, input_name='ExpireDate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AccountInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AccountHolderName is not None:
            showIndent(outfile, level)
            outfile.write('AccountHolderName=%s,\n' % quote_python(self.AccountHolderName).encode(ExternalEncoding))
        if self.AccountNumber is not None:
            showIndent(outfile, level)
            outfile.write('AccountNumber=%s,\n' % quote_python(self.AccountNumber).encode(ExternalEncoding))
        if self.FinancialInstitution is not None:
            showIndent(outfile, level)
            outfile.write('FinancialInstitution=%s,\n' % quote_python(self.FinancialInstitution).encode(ExternalEncoding))
        if self.FinancialInstitutionDFINumber is not None:
            showIndent(outfile, level)
            outfile.write('FinancialInstitutionDFINumber=%s,\n' % quote_python(self.FinancialInstitutionDFINumber).encode(ExternalEncoding))
        if self.CreditCardNumber is not None:
            showIndent(outfile, level)
            outfile.write('CreditCardNumber=%d,\n' % self.CreditCardNumber)
        if self.CreditCardType is not None:
            showIndent(outfile, level)
            outfile.write('CreditCardType=%s,\n' % quote_python(self.CreditCardType).encode(ExternalEncoding))
        if self.ExpireDate is not None:
            showIndent(outfile, level)
            outfile.write('ExpireDate=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.ExpireDate, input_name='ExpireDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountHolderName':
            AccountHolderName_ = child_.text
            AccountHolderName_ = self.gds_validate_string(AccountHolderName_, node, 'AccountHolderName')
            self.AccountHolderName = AccountHolderName_
        elif nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
        elif nodeName_ == 'FinancialInstitution':
            FinancialInstitution_ = child_.text
            FinancialInstitution_ = self.gds_validate_string(FinancialInstitution_, node, 'FinancialInstitution')
            self.FinancialInstitution = FinancialInstitution_
        elif nodeName_ == 'FinancialInstitutionDFINumber':
            FinancialInstitutionDFINumber_ = child_.text
            FinancialInstitutionDFINumber_ = self.gds_validate_string(FinancialInstitutionDFINumber_, node, 'FinancialInstitutionDFINumber')
            self.FinancialInstitutionDFINumber = FinancialInstitutionDFINumber_
        elif nodeName_ == 'CreditCardNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CreditCardNumber')
            self.CreditCardNumber = ival_
        elif nodeName_ == 'CreditCardType':
            CreditCardType_ = child_.text
            CreditCardType_ = self.gds_validate_string(CreditCardType_, node, 'CreditCardType')
            self.CreditCardType = CreditCardType_
        elif nodeName_ == 'ExpireDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'ExpireDate')
            self.ExpireDate = dval_
# end class AccountInformation


class AddressInformation(GeneratedsSuper):
    """Structure which contains complete address information.Unique
    definitions defined previously in OFSP-Lib begin with:
    PostBoxNumber"""
    subclass = None
    superclass = None
    def __init__(self, POBoxNumber=None, BuildingHouseNumber=None, StreetName=None, AddressLine=None, CityName=None, StateProvince=None, PostalCode=None, PostalCountry=None, CountyName=None, LocationIdentifier=None, StreetDirection=None, RegionName=None, LocationCode=None, Comment=None):
        self.POBoxNumber = POBoxNumber
        self.BuildingHouseNumber = BuildingHouseNumber
        self.StreetName = StreetName
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.CityName = CityName
        self.StateProvince = StateProvince
        self.PostalCode = PostalCode
        self.PostalCountry = PostalCountry
        self.CountyName = CountyName
        self.LocationIdentifier = LocationIdentifier
        self.StreetDirection = StreetDirection
        self.RegionName = RegionName
        self.LocationCode = LocationCode
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AddressInformation.subclass:
            return AddressInformation.subclass(*args_, **kwargs_)
        else:
            return AddressInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_POBoxNumber(self): return self.POBoxNumber
    def set_POBoxNumber(self, POBoxNumber): self.POBoxNumber = POBoxNumber
    def get_BuildingHouseNumber(self): return self.BuildingHouseNumber
    def set_BuildingHouseNumber(self, BuildingHouseNumber): self.BuildingHouseNumber = BuildingHouseNumber
    def get_StreetName(self): return self.StreetName
    def set_StreetName(self, StreetName): self.StreetName = StreetName
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine(self, index, value): self.AddressLine[index] = value
    def get_CityName(self): return self.CityName
    def set_CityName(self, CityName): self.CityName = CityName
    def get_StateProvince(self): return self.StateProvince
    def set_StateProvince(self, StateProvince): self.StateProvince = StateProvince
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_PostalCountry(self): return self.PostalCountry
    def set_PostalCountry(self, PostalCountry): self.PostalCountry = PostalCountry
    def get_CountyName(self): return self.CountyName
    def set_CountyName(self, CountyName): self.CountyName = CountyName
    def get_LocationIdentifier(self): return self.LocationIdentifier
    def set_LocationIdentifier(self, LocationIdentifier): self.LocationIdentifier = LocationIdentifier
    def get_StreetDirection(self): return self.StreetDirection
    def set_StreetDirection(self, StreetDirection): self.StreetDirection = StreetDirection
    def get_RegionName(self): return self.RegionName
    def set_RegionName(self, RegionName): self.RegionName = RegionName
    def get_LocationCode(self): return self.LocationCode
    def set_LocationCode(self, LocationCode): self.LocationCode = LocationCode
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.POBoxNumber is not None or
            self.BuildingHouseNumber is not None or
            self.StreetName is not None or
            self.AddressLine or
            self.CityName is not None or
            self.StateProvince is not None or
            self.PostalCode is not None or
            self.PostalCountry is not None or
            self.CountyName is not None or
            self.LocationIdentifier is not None or
            self.StreetDirection is not None or
            self.RegionName is not None or
            self.LocationCode is not None or
            self.Comment
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AddressInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AddressInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AddressInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.POBoxNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOBoxNumber>%s</%sPOBoxNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.POBoxNumber).encode(ExternalEncoding), input_name='POBoxNumber'), namespace_, eol_))
        if self.BuildingHouseNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuildingHouseNumber>%s</%sBuildingHouseNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.BuildingHouseNumber).encode(ExternalEncoding), input_name='BuildingHouseNumber'), namespace_, eol_))
        if self.StreetName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetName>%s</%sStreetName>%s' % (namespace_, self.gds_format_string(quote_xml(self.StreetName).encode(ExternalEncoding), input_name='StreetName'), namespace_, eol_))
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddressLine>%s</%sAddressLine>%s' % (namespace_, self.gds_format_string(quote_xml(AddressLine_).encode(ExternalEncoding), input_name='AddressLine'), namespace_, eol_))
        if self.CityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCityName>%s</%sCityName>%s' % (namespace_, self.gds_format_string(quote_xml(self.CityName).encode(ExternalEncoding), input_name='CityName'), namespace_, eol_))
        if self.StateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStateProvince>%s</%sStateProvince>%s' % (namespace_, self.gds_format_string(quote_xml(self.StateProvince).encode(ExternalEncoding), input_name='StateProvince'), namespace_, eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostalCode>%s</%sPostalCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.PostalCode).encode(ExternalEncoding), input_name='PostalCode'), namespace_, eol_))
        if self.PostalCountry is not None:
            self.PostalCountry.export(outfile, level, namespace_, name_='PostalCountry', pretty_print=pretty_print)
        if self.CountyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountyName>%s</%sCountyName>%s' % (namespace_, self.gds_format_string(quote_xml(self.CountyName).encode(ExternalEncoding), input_name='CountyName'), namespace_, eol_))
        if self.LocationIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationIdentifier>%s</%sLocationIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationIdentifier).encode(ExternalEncoding), input_name='LocationIdentifier'), namespace_, eol_))
        if self.StreetDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetDirection>%s</%sStreetDirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.StreetDirection).encode(ExternalEncoding), input_name='StreetDirection'), namespace_, eol_))
        if self.RegionName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegionName>%s</%sRegionName>%s' % (namespace_, self.gds_format_string(quote_xml(self.RegionName).encode(ExternalEncoding), input_name='RegionName'), namespace_, eol_))
        if self.LocationCode is not None:
            self.LocationCode.export(outfile, level, namespace_, name_='LocationCode', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(Comment_).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AddressInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.POBoxNumber is not None:
            showIndent(outfile, level)
            outfile.write('POBoxNumber=%s,\n' % quote_python(self.POBoxNumber).encode(ExternalEncoding))
        if self.BuildingHouseNumber is not None:
            showIndent(outfile, level)
            outfile.write('BuildingHouseNumber=%s,\n' % quote_python(self.BuildingHouseNumber).encode(ExternalEncoding))
        if self.StreetName is not None:
            showIndent(outfile, level)
            outfile.write('StreetName=%s,\n' % quote_python(self.StreetName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AddressLine=[\n')
        level += 1
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AddressLine_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CityName is not None:
            showIndent(outfile, level)
            outfile.write('CityName=%s,\n' % quote_python(self.CityName).encode(ExternalEncoding))
        if self.StateProvince is not None:
            showIndent(outfile, level)
            outfile.write('StateProvince=%s,\n' % quote_python(self.StateProvince).encode(ExternalEncoding))
        if self.PostalCode is not None:
            showIndent(outfile, level)
            outfile.write('PostalCode=%s,\n' % quote_python(self.PostalCode).encode(ExternalEncoding))
        if self.PostalCountry is not None:
            showIndent(outfile, level)
            outfile.write('PostalCountry=model_.PostalCountry(\n')
            self.PostalCountry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CountyName is not None:
            showIndent(outfile, level)
            outfile.write('CountyName=%s,\n' % quote_python(self.CountyName).encode(ExternalEncoding))
        if self.LocationIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('LocationIdentifier=%s,\n' % quote_python(self.LocationIdentifier).encode(ExternalEncoding))
        if self.StreetDirection is not None:
            showIndent(outfile, level)
            outfile.write('StreetDirection=%s,\n' % quote_python(self.StreetDirection).encode(ExternalEncoding))
        if self.RegionName is not None:
            showIndent(outfile, level)
            outfile.write('RegionName=%s,\n' % quote_python(self.RegionName).encode(ExternalEncoding))
        if self.LocationCode is not None:
            showIndent(outfile, level)
            outfile.write('LocationCode=model_.LocationCode(\n')
            self.LocationCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'POBoxNumber':
            POBoxNumber_ = child_.text
            POBoxNumber_ = self.gds_validate_string(POBoxNumber_, node, 'POBoxNumber')
            self.POBoxNumber = POBoxNumber_
        elif nodeName_ == 'BuildingHouseNumber':
            BuildingHouseNumber_ = child_.text
            BuildingHouseNumber_ = self.gds_validate_string(BuildingHouseNumber_, node, 'BuildingHouseNumber')
            self.BuildingHouseNumber = BuildingHouseNumber_
        elif nodeName_ == 'StreetName':
            StreetName_ = child_.text
            StreetName_ = self.gds_validate_string(StreetName_, node, 'StreetName')
            self.StreetName = StreetName_
        elif nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
        elif nodeName_ == 'CityName':
            CityName_ = child_.text
            CityName_ = self.gds_validate_string(CityName_, node, 'CityName')
            self.CityName = CityName_
        elif nodeName_ == 'StateProvince':
            StateProvince_ = child_.text
            StateProvince_ = self.gds_validate_string(StateProvince_, node, 'StateProvince')
            self.StateProvince = StateProvince_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'PostalCountry':
            obj_ = PostalCountry.factory()
            obj_.build(child_)
            self.set_PostalCountry(obj_)
        elif nodeName_ == 'CountyName':
            CountyName_ = child_.text
            CountyName_ = self.gds_validate_string(CountyName_, node, 'CountyName')
            self.CountyName = CountyName_
        elif nodeName_ == 'LocationIdentifier':
            LocationIdentifier_ = child_.text
            LocationIdentifier_ = self.gds_validate_string(LocationIdentifier_, node, 'LocationIdentifier')
            self.LocationIdentifier = LocationIdentifier_
        elif nodeName_ == 'StreetDirection':
            StreetDirection_ = child_.text
            StreetDirection_ = self.gds_validate_string(StreetDirection_, node, 'StreetDirection')
            self.StreetDirection = StreetDirection_
        elif nodeName_ == 'RegionName':
            RegionName_ = child_.text
            RegionName_ = self.gds_validate_string(RegionName_, node, 'RegionName')
            self.RegionName = RegionName_
        elif nodeName_ == 'LocationCode':
            obj_ = LocationCode.factory()
            obj_.build(child_)
            self.set_LocationCode(obj_)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment.append(Comment_)
# end class AddressInformation


class AdditiveTypeIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifierIndicator=None, valueOf_=None):
        self.identifierIndicator = _cast(None, identifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AdditiveTypeIdentifier.subclass:
            return AdditiveTypeIdentifier.subclass(*args_, **kwargs_)
        else:
            return AdditiveTypeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifierIndicator(self): return self.identifierIndicator
    def set_identifierIndicator(self, identifierIndicator): self.identifierIndicator = identifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AdditiveTypeIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditiveTypeIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AdditiveTypeIdentifier'):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            outfile.write(' identifierIndicator=%s' % (quote_attrib(self.identifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AdditiveTypeIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AdditiveTypeIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            showIndent(outfile, level)
            outfile.write('identifierIndicator = %s,\n' % (self.identifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('identifierIndicator', node)
        if value is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            self.identifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AdditiveTypeIdentifier


class AllowanceOrCharge(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, allowanceOrChargeIndicator=None, AllowanceOrChargeTotalAmount=None, AllowanceOrChargeRate=None, AllowanceOrChargePercent=None, AllowanceOrChargeNumber=None, AllowanceOrChargeTypeCode=None, MethodOfHandlingCode=None, AllowanceOrChargeDescription=None, AllowanceOrChargeQuantity=None):
        self.allowanceOrChargeIndicator = _cast(None, allowanceOrChargeIndicator)
        self.AllowanceOrChargeTotalAmount = AllowanceOrChargeTotalAmount
        self.AllowanceOrChargeRate = AllowanceOrChargeRate
        self.AllowanceOrChargePercent = AllowanceOrChargePercent
        self.AllowanceOrChargeNumber = AllowanceOrChargeNumber
        self.AllowanceOrChargeTypeCode = AllowanceOrChargeTypeCode
        self.MethodOfHandlingCode = MethodOfHandlingCode
        self.AllowanceOrChargeDescription = AllowanceOrChargeDescription
        self.AllowanceOrChargeQuantity = AllowanceOrChargeQuantity
    def factory(*args_, **kwargs_):
        if AllowanceOrCharge.subclass:
            return AllowanceOrCharge.subclass(*args_, **kwargs_)
        else:
            return AllowanceOrCharge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllowanceOrChargeTotalAmount(self): return self.AllowanceOrChargeTotalAmount
    def set_AllowanceOrChargeTotalAmount(self, AllowanceOrChargeTotalAmount): self.AllowanceOrChargeTotalAmount = AllowanceOrChargeTotalAmount
    def get_AllowanceOrChargeRate(self): return self.AllowanceOrChargeRate
    def set_AllowanceOrChargeRate(self, AllowanceOrChargeRate): self.AllowanceOrChargeRate = AllowanceOrChargeRate
    def get_AllowanceOrChargePercent(self): return self.AllowanceOrChargePercent
    def set_AllowanceOrChargePercent(self, AllowanceOrChargePercent): self.AllowanceOrChargePercent = AllowanceOrChargePercent
    def get_AllowanceOrChargeNumber(self): return self.AllowanceOrChargeNumber
    def set_AllowanceOrChargeNumber(self, AllowanceOrChargeNumber): self.AllowanceOrChargeNumber = AllowanceOrChargeNumber
    def get_AllowanceOrChargeTypeCode(self): return self.AllowanceOrChargeTypeCode
    def set_AllowanceOrChargeTypeCode(self, AllowanceOrChargeTypeCode): self.AllowanceOrChargeTypeCode = AllowanceOrChargeTypeCode
    def get_MethodOfHandlingCode(self): return self.MethodOfHandlingCode
    def set_MethodOfHandlingCode(self, MethodOfHandlingCode): self.MethodOfHandlingCode = MethodOfHandlingCode
    def get_AllowanceOrChargeDescription(self): return self.AllowanceOrChargeDescription
    def set_AllowanceOrChargeDescription(self, AllowanceOrChargeDescription): self.AllowanceOrChargeDescription = AllowanceOrChargeDescription
    def get_AllowanceOrChargeQuantity(self): return self.AllowanceOrChargeQuantity
    def set_AllowanceOrChargeQuantity(self, AllowanceOrChargeQuantity): self.AllowanceOrChargeQuantity = AllowanceOrChargeQuantity
    def get_allowanceOrChargeIndicator(self): return self.allowanceOrChargeIndicator
    def set_allowanceOrChargeIndicator(self, allowanceOrChargeIndicator): self.allowanceOrChargeIndicator = allowanceOrChargeIndicator
    def hasContent_(self):
        if (
            self.AllowanceOrChargeTotalAmount is not None or
            self.AllowanceOrChargeRate is not None or
            self.AllowanceOrChargePercent is not None or
            self.AllowanceOrChargeNumber is not None or
            self.AllowanceOrChargeTypeCode is not None or
            self.MethodOfHandlingCode is not None or
            self.AllowanceOrChargeDescription is not None or
            self.AllowanceOrChargeQuantity is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AllowanceOrCharge', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowanceOrCharge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AllowanceOrCharge'):
        if self.allowanceOrChargeIndicator is not None and 'allowanceOrChargeIndicator' not in already_processed:
            already_processed.add('allowanceOrChargeIndicator')
            outfile.write(' allowanceOrChargeIndicator=%s' % (quote_attrib(self.allowanceOrChargeIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AllowanceOrCharge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllowanceOrChargeTotalAmount is not None:
            self.AllowanceOrChargeTotalAmount.export(outfile, level, namespace_, name_='AllowanceOrChargeTotalAmount', pretty_print=pretty_print)
        if self.AllowanceOrChargeRate is not None:
            self.AllowanceOrChargeRate.export(outfile, level, namespace_, name_='AllowanceOrChargeRate', pretty_print=pretty_print)
        if self.AllowanceOrChargePercent is not None:
            self.AllowanceOrChargePercent.export(outfile, level, namespace_, name_='AllowanceOrChargePercent', pretty_print=pretty_print)
        if self.AllowanceOrChargeNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllowanceOrChargeNumber>%s</%sAllowanceOrChargeNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.AllowanceOrChargeNumber).encode(ExternalEncoding), input_name='AllowanceOrChargeNumber'), namespace_, eol_))
        if self.AllowanceOrChargeTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllowanceOrChargeTypeCode>%s</%sAllowanceOrChargeTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.AllowanceOrChargeTypeCode).encode(ExternalEncoding), input_name='AllowanceOrChargeTypeCode'), namespace_, eol_))
        if self.MethodOfHandlingCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMethodOfHandlingCode>%s</%sMethodOfHandlingCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.MethodOfHandlingCode).encode(ExternalEncoding), input_name='MethodOfHandlingCode'), namespace_, eol_))
        if self.AllowanceOrChargeDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllowanceOrChargeDescription>%s</%sAllowanceOrChargeDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.AllowanceOrChargeDescription).encode(ExternalEncoding), input_name='AllowanceOrChargeDescription'), namespace_, eol_))
        if self.AllowanceOrChargeQuantity is not None:
            self.AllowanceOrChargeQuantity.export(outfile, level, namespace_, name_='AllowanceOrChargeQuantity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AllowanceOrCharge'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.allowanceOrChargeIndicator is not None and 'allowanceOrChargeIndicator' not in already_processed:
            already_processed.add('allowanceOrChargeIndicator')
            showIndent(outfile, level)
            outfile.write('allowanceOrChargeIndicator = %s,\n' % (self.allowanceOrChargeIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AllowanceOrChargeTotalAmount is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargeTotalAmount=model_.AllowanceOrChargeTotalAmount(\n')
            self.AllowanceOrChargeTotalAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllowanceOrChargeRate is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargeRate=model_.AllowanceOrChargeRate(\n')
            self.AllowanceOrChargeRate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllowanceOrChargePercent is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargePercent=model_.AllowanceOrChargePercent(\n')
            self.AllowanceOrChargePercent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllowanceOrChargeNumber is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargeNumber=%s,\n' % quote_python(self.AllowanceOrChargeNumber).encode(ExternalEncoding))
        if self.AllowanceOrChargeTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargeTypeCode=%s,\n' % quote_python(self.AllowanceOrChargeTypeCode).encode(ExternalEncoding))
        if self.MethodOfHandlingCode is not None:
            showIndent(outfile, level)
            outfile.write('MethodOfHandlingCode=%s,\n' % quote_python(self.MethodOfHandlingCode).encode(ExternalEncoding))
        if self.AllowanceOrChargeDescription is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargeDescription=%s,\n' % quote_python(self.AllowanceOrChargeDescription).encode(ExternalEncoding))
        if self.AllowanceOrChargeQuantity is not None:
            showIndent(outfile, level)
            outfile.write('AllowanceOrChargeQuantity=model_.AllowanceOrChargeQuantity(\n')
            self.AllowanceOrChargeQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allowanceOrChargeIndicator', node)
        if value is not None and 'allowanceOrChargeIndicator' not in already_processed:
            already_processed.add('allowanceOrChargeIndicator')
            self.allowanceOrChargeIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllowanceOrChargeTotalAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_AllowanceOrChargeTotalAmount(obj_)
        elif nodeName_ == 'AllowanceOrChargeRate':
            obj_ = AllowanceOrChargeRate.factory()
            obj_.build(child_)
            self.set_AllowanceOrChargeRate(obj_)
        elif nodeName_ == 'AllowanceOrChargePercent':
            obj_ = AllowanceOrChargePercent.factory()
            obj_.build(child_)
            self.set_AllowanceOrChargePercent(obj_)
        elif nodeName_ == 'AllowanceOrChargeNumber':
            AllowanceOrChargeNumber_ = child_.text
            AllowanceOrChargeNumber_ = self.gds_validate_string(AllowanceOrChargeNumber_, node, 'AllowanceOrChargeNumber')
            self.AllowanceOrChargeNumber = AllowanceOrChargeNumber_
        elif nodeName_ == 'AllowanceOrChargeTypeCode':
            AllowanceOrChargeTypeCode_ = child_.text
            AllowanceOrChargeTypeCode_ = self.gds_validate_string(AllowanceOrChargeTypeCode_, node, 'AllowanceOrChargeTypeCode')
            self.AllowanceOrChargeTypeCode = AllowanceOrChargeTypeCode_
        elif nodeName_ == 'MethodOfHandlingCode':
            MethodOfHandlingCode_ = child_.text
            MethodOfHandlingCode_ = self.gds_validate_string(MethodOfHandlingCode_, node, 'MethodOfHandlingCode')
            self.MethodOfHandlingCode = MethodOfHandlingCode_
        elif nodeName_ == 'AllowanceOrChargeDescription':
            AllowanceOrChargeDescription_ = child_.text
            AllowanceOrChargeDescription_ = self.gds_validate_string(AllowanceOrChargeDescription_, node, 'AllowanceOrChargeDescription')
            self.AllowanceOrChargeDescription = AllowanceOrChargeDescription_
        elif nodeName_ == 'AllowanceOrChargeQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_AllowanceOrChargeQuantity(obj_)
# end class AllowanceOrCharge


class AllowanceOrChargePercent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, percentIndicator=None, valueOf_=None):
        self.percentIndicator = _cast(None, percentIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AllowanceOrChargePercent.subclass:
            return AllowanceOrChargePercent.subclass(*args_, **kwargs_)
        else:
            return AllowanceOrChargePercent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_percentIndicator(self): return self.percentIndicator
    def set_percentIndicator(self, percentIndicator): self.percentIndicator = percentIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AllowanceOrChargePercent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowanceOrChargePercent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AllowanceOrChargePercent'):
        if self.percentIndicator is not None and 'percentIndicator' not in already_processed:
            already_processed.add('percentIndicator')
            outfile.write(' percentIndicator=%s' % (self.gds_format_string(quote_attrib(self.percentIndicator).encode(ExternalEncoding), input_name='percentIndicator'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AllowanceOrChargePercent', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AllowanceOrChargePercent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentIndicator is not None and 'percentIndicator' not in already_processed:
            already_processed.add('percentIndicator')
            showIndent(outfile, level)
            outfile.write('percentIndicator = "%s",\n' % (self.percentIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentIndicator', node)
        if value is not None and 'percentIndicator' not in already_processed:
            already_processed.add('percentIndicator')
            self.percentIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AllowanceOrChargePercent


class AllowanceOrChargeRate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MonetaryAmount=None, UnitOfMeasureCode=None, CurrencyCode=None):
        self.MonetaryAmount = MonetaryAmount
        self.UnitOfMeasureCode = UnitOfMeasureCode
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if AllowanceOrChargeRate.subclass:
            return AllowanceOrChargeRate.subclass(*args_, **kwargs_)
        else:
            return AllowanceOrChargeRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MonetaryAmount(self): return self.MonetaryAmount
    def set_MonetaryAmount(self, MonetaryAmount): self.MonetaryAmount = MonetaryAmount
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.MonetaryAmount is not None or
            self.UnitOfMeasureCode is not None or
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AllowanceOrChargeRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowanceOrChargeRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AllowanceOrChargeRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AllowanceOrChargeRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MonetaryAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMonetaryAmount>%s</%sMonetaryAmount>%s' % (namespace_, self.gds_format_float(self.MonetaryAmount, input_name='MonetaryAmount'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AllowanceOrChargeRate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MonetaryAmount is not None:
            showIndent(outfile, level)
            outfile.write('MonetaryAmount=%f,\n' % self.MonetaryAmount)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MonetaryAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MonetaryAmount')
            self.MonetaryAmount = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class AllowanceOrChargeRate


class AlternativeCommunicationMethod(GeneratedsSuper):
    """Additional methods of communication, ie., fax, printer, cell phone,
    in addition to those specifically listed elsewhere in contact or
    address information.Unique definitions defined previously in
    OFSP-Lib begin with: communicationMethodTypeIdentifies which
    kind of communication is beging given.Identifies what "Other" is
    if chosen from an attribute enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, communicationMethodType=None, definitionOfOther=None, alternativeCommunicationMethodIndicator=None, valueOf_=None):
        self.communicationMethodType = _cast(None, communicationMethodType)
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.alternativeCommunicationMethodIndicator = _cast(None, alternativeCommunicationMethodIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AlternativeCommunicationMethod.subclass:
            return AlternativeCommunicationMethod.subclass(*args_, **kwargs_)
        else:
            return AlternativeCommunicationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_communicationMethodType(self): return self.communicationMethodType
    def set_communicationMethodType(self, communicationMethodType): self.communicationMethodType = communicationMethodType
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_alternativeCommunicationMethodIndicator(self): return self.alternativeCommunicationMethodIndicator
    def set_alternativeCommunicationMethodIndicator(self, alternativeCommunicationMethodIndicator): self.alternativeCommunicationMethodIndicator = alternativeCommunicationMethodIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AlternativeCommunicationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternativeCommunicationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AlternativeCommunicationMethod'):
        if self.communicationMethodType is not None and 'communicationMethodType' not in already_processed:
            already_processed.add('communicationMethodType')
            outfile.write(' communicationMethodType=%s' % (quote_attrib(self.communicationMethodType), ))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
        if self.alternativeCommunicationMethodIndicator is not None and 'alternativeCommunicationMethodIndicator' not in already_processed:
            already_processed.add('alternativeCommunicationMethodIndicator')
            outfile.write(' alternativeCommunicationMethodIndicator=%s' % (quote_attrib(self.alternativeCommunicationMethodIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AlternativeCommunicationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AlternativeCommunicationMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.communicationMethodType is not None and 'communicationMethodType' not in already_processed:
            already_processed.add('communicationMethodType')
            showIndent(outfile, level)
            outfile.write('communicationMethodType = %s,\n' % (self.communicationMethodType,))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
        if self.alternativeCommunicationMethodIndicator is not None and 'alternativeCommunicationMethodIndicator' not in already_processed:
            already_processed.add('alternativeCommunicationMethodIndicator')
            showIndent(outfile, level)
            outfile.write('alternativeCommunicationMethodIndicator = %s,\n' % (self.alternativeCommunicationMethodIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('communicationMethodType', node)
        if value is not None and 'communicationMethodType' not in already_processed:
            already_processed.add('communicationMethodType')
            self.communicationMethodType = value
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
        value = find_attr_value_('alternativeCommunicationMethodIndicator', node)
        if value is not None and 'alternativeCommunicationMethodIndicator' not in already_processed:
            already_processed.add('alternativeCommunicationMethodIndicator')
            self.alternativeCommunicationMethodIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AlternativeCommunicationMethod


class AmbientTemperature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Temperature=None, UnitOfMeasureCode=None):
        self.Temperature = Temperature
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if AmbientTemperature.subclass:
            return AmbientTemperature.subclass(*args_, **kwargs_)
        else:
            return AmbientTemperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Temperature is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AmbientTemperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmbientTemperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AmbientTemperature'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AmbientTemperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AmbientTemperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Temperature is not None:
            showIndent(outfile, level)
            outfile.write('Temperature=model_.Temperature(\n')
            self.Temperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.set_Temperature(obj_)
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class AmbientTemperature


class Attachment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AttachmentPurposeCode=None, FileName=None, AttachmentTitle=None, AttachmentDescription=None, FileType=None, AttachmentLocation=None):
        self.AttachmentPurposeCode = AttachmentPurposeCode
        self.FileName = FileName
        self.AttachmentTitle = AttachmentTitle
        self.AttachmentDescription = AttachmentDescription
        self.FileType = FileType
        self.AttachmentLocation = AttachmentLocation
    def factory(*args_, **kwargs_):
        if Attachment.subclass:
            return Attachment.subclass(*args_, **kwargs_)
        else:
            return Attachment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttachmentPurposeCode(self): return self.AttachmentPurposeCode
    def set_AttachmentPurposeCode(self, AttachmentPurposeCode): self.AttachmentPurposeCode = AttachmentPurposeCode
    def get_FileName(self): return self.FileName
    def set_FileName(self, FileName): self.FileName = FileName
    def get_AttachmentTitle(self): return self.AttachmentTitle
    def set_AttachmentTitle(self, AttachmentTitle): self.AttachmentTitle = AttachmentTitle
    def get_AttachmentDescription(self): return self.AttachmentDescription
    def set_AttachmentDescription(self, AttachmentDescription): self.AttachmentDescription = AttachmentDescription
    def get_FileType(self): return self.FileType
    def set_FileType(self, FileType): self.FileType = FileType
    def get_AttachmentLocation(self): return self.AttachmentLocation
    def set_AttachmentLocation(self, AttachmentLocation): self.AttachmentLocation = AttachmentLocation
    def hasContent_(self):
        if (
            self.AttachmentPurposeCode is not None or
            self.FileName is not None or
            self.AttachmentTitle is not None or
            self.AttachmentDescription is not None or
            self.FileType is not None or
            self.AttachmentLocation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Attachment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attachment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Attachment'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Attachment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttachmentPurposeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentPurposeCode>%s</%sAttachmentPurposeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.AttachmentPurposeCode).encode(ExternalEncoding), input_name='AttachmentPurposeCode'), namespace_, eol_))
        if self.FileName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFileName>%s</%sFileName>%s' % (namespace_, self.gds_format_string(quote_xml(self.FileName).encode(ExternalEncoding), input_name='FileName'), namespace_, eol_))
        if self.AttachmentTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentTitle>%s</%sAttachmentTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.AttachmentTitle).encode(ExternalEncoding), input_name='AttachmentTitle'), namespace_, eol_))
        if self.AttachmentDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentDescription>%s</%sAttachmentDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.AttachmentDescription).encode(ExternalEncoding), input_name='AttachmentDescription'), namespace_, eol_))
        if self.FileType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFileType>%s</%sFileType>%s' % (namespace_, self.gds_format_string(quote_xml(self.FileType).encode(ExternalEncoding), input_name='FileType'), namespace_, eol_))
        if self.AttachmentLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentLocation>%s</%sAttachmentLocation>%s' % (namespace_, self.gds_format_string(quote_xml(self.AttachmentLocation).encode(ExternalEncoding), input_name='AttachmentLocation'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Attachment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AttachmentPurposeCode is not None:
            showIndent(outfile, level)
            outfile.write('AttachmentPurposeCode=%s,\n' % quote_python(self.AttachmentPurposeCode).encode(ExternalEncoding))
        if self.FileName is not None:
            showIndent(outfile, level)
            outfile.write('FileName=%s,\n' % quote_python(self.FileName).encode(ExternalEncoding))
        if self.AttachmentTitle is not None:
            showIndent(outfile, level)
            outfile.write('AttachmentTitle=%s,\n' % quote_python(self.AttachmentTitle).encode(ExternalEncoding))
        if self.AttachmentDescription is not None:
            showIndent(outfile, level)
            outfile.write('AttachmentDescription=%s,\n' % quote_python(self.AttachmentDescription).encode(ExternalEncoding))
        if self.FileType is not None:
            showIndent(outfile, level)
            outfile.write('FileType=%s,\n' % quote_python(self.FileType).encode(ExternalEncoding))
        if self.AttachmentLocation is not None:
            showIndent(outfile, level)
            outfile.write('AttachmentLocation=%s,\n' % quote_python(self.AttachmentLocation).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttachmentPurposeCode':
            AttachmentPurposeCode_ = child_.text
            AttachmentPurposeCode_ = self.gds_validate_string(AttachmentPurposeCode_, node, 'AttachmentPurposeCode')
            self.AttachmentPurposeCode = AttachmentPurposeCode_
        elif nodeName_ == 'FileName':
            FileName_ = child_.text
            FileName_ = self.gds_validate_string(FileName_, node, 'FileName')
            self.FileName = FileName_
        elif nodeName_ == 'AttachmentTitle':
            AttachmentTitle_ = child_.text
            AttachmentTitle_ = self.gds_validate_string(AttachmentTitle_, node, 'AttachmentTitle')
            self.AttachmentTitle = AttachmentTitle_
        elif nodeName_ == 'AttachmentDescription':
            AttachmentDescription_ = child_.text
            AttachmentDescription_ = self.gds_validate_string(AttachmentDescription_, node, 'AttachmentDescription')
            self.AttachmentDescription = AttachmentDescription_
        elif nodeName_ == 'FileType':
            FileType_ = child_.text
            FileType_ = self.gds_validate_string(FileType_, node, 'FileType')
            self.FileType = FileType_
        elif nodeName_ == 'AttachmentLocation':
            AttachmentLocation_ = child_.text
            AttachmentLocation_ = self.gds_validate_string(AttachmentLocation_, node, 'AttachmentLocation')
            self.AttachmentLocation = AttachmentLocation_
# end class Attachment


class AveragePressure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Pressure=None, UnitOfMeasureCode=None):
        self.Pressure = Pressure
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if AveragePressure.subclass:
            return AveragePressure.subclass(*args_, **kwargs_)
        else:
            return AveragePressure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pressure(self): return self.Pressure
    def set_Pressure(self, Pressure): self.Pressure = Pressure
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Pressure is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AveragePressure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragePressure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AveragePressure'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AveragePressure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Pressure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPressure>%s</%sPressure>%s' % (namespace_, self.gds_format_float(self.Pressure, input_name='Pressure'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AveragePressure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Pressure is not None:
            showIndent(outfile, level)
            outfile.write('Pressure=%f,\n' % self.Pressure)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pressure':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Pressure')
            self.Pressure = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class AveragePressure


class AverageTemperature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Temperature=None, UnitOfMeasureCode=None):
        self.Temperature = Temperature
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if AverageTemperature.subclass:
            return AverageTemperature.subclass(*args_, **kwargs_)
        else:
            return AverageTemperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Temperature is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AverageTemperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AverageTemperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AverageTemperature'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AverageTemperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AverageTemperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Temperature is not None:
            showIndent(outfile, level)
            outfile.write('Temperature=model_.Temperature(\n')
            self.Temperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.set_Temperature(obj_)
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class AverageTemperature


class BatchNumber(GeneratedsSuper):
    """Identification by a manufacturer or seller for a homogeneous
    quantity/quality of product sharing the same factors of
    production. Identifies the creator of the batch
    number.Identifies what "Other" is if chosen from an attribute
    enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, batchNumberCreator=None, definitionOfOther=None, valueOf_=None):
        self.batchNumberCreator = _cast(None, batchNumberCreator)
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if BatchNumber.subclass:
            return BatchNumber.subclass(*args_, **kwargs_)
        else:
            return BatchNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_batchNumberCreator(self): return self.batchNumberCreator
    def set_batchNumberCreator(self, batchNumberCreator): self.batchNumberCreator = batchNumberCreator
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BatchNumber', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BatchNumber')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BatchNumber'):
        if self.batchNumberCreator is not None and 'batchNumberCreator' not in already_processed:
            already_processed.add('batchNumberCreator')
            outfile.write(' batchNumberCreator=%s' % (quote_attrib(self.batchNumberCreator), ))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BatchNumber', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BatchNumber'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.batchNumberCreator is not None and 'batchNumberCreator' not in already_processed:
            already_processed.add('batchNumberCreator')
            showIndent(outfile, level)
            outfile.write('batchNumberCreator = %s,\n' % (self.batchNumberCreator,))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('batchNumberCreator', node)
        if value is not None and 'batchNumberCreator' not in already_processed:
            already_processed.add('batchNumberCreator')
            self.batchNumberCreator = value
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BatchNumber


class Block(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BlockName=None, OCSGNumber=None, StateLease=None):
        self.BlockName = BlockName
        self.OCSGNumber = OCSGNumber
        self.StateLease = StateLease
    def factory(*args_, **kwargs_):
        if Block.subclass:
            return Block.subclass(*args_, **kwargs_)
        else:
            return Block(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BlockName(self): return self.BlockName
    def set_BlockName(self, BlockName): self.BlockName = BlockName
    def get_OCSGNumber(self): return self.OCSGNumber
    def set_OCSGNumber(self, OCSGNumber): self.OCSGNumber = OCSGNumber
    def get_StateLease(self): return self.StateLease
    def set_StateLease(self, StateLease): self.StateLease = StateLease
    def hasContent_(self):
        if (
            self.BlockName is not None or
            self.OCSGNumber is not None or
            self.StateLease is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Block', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Block')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Block'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Block', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BlockName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBlockName>%s</%sBlockName>%s' % (namespace_, self.gds_format_string(quote_xml(self.BlockName).encode(ExternalEncoding), input_name='BlockName'), namespace_, eol_))
        if self.OCSGNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOCSGNumber>%s</%sOCSGNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.OCSGNumber).encode(ExternalEncoding), input_name='OCSGNumber'), namespace_, eol_))
        if self.StateLease is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStateLease>%s</%sStateLease>%s' % (namespace_, self.gds_format_string(quote_xml(self.StateLease).encode(ExternalEncoding), input_name='StateLease'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Block'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BlockName is not None:
            showIndent(outfile, level)
            outfile.write('BlockName=%s,\n' % quote_python(self.BlockName).encode(ExternalEncoding))
        if self.OCSGNumber is not None:
            showIndent(outfile, level)
            outfile.write('OCSGNumber=%s,\n' % quote_python(self.OCSGNumber).encode(ExternalEncoding))
        if self.StateLease is not None:
            showIndent(outfile, level)
            outfile.write('StateLease=%s,\n' % quote_python(self.StateLease).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BlockName':
            BlockName_ = child_.text
            BlockName_ = self.gds_validate_string(BlockName_, node, 'BlockName')
            self.BlockName = BlockName_
        elif nodeName_ == 'OCSGNumber':
            OCSGNumber_ = child_.text
            OCSGNumber_ = self.gds_validate_string(OCSGNumber_, node, 'OCSGNumber')
            self.OCSGNumber = OCSGNumber_
        elif nodeName_ == 'StateLease':
            StateLease_ = child_.text
            StateLease_ = self.gds_validate_string(StateLease_, node, 'StateLease')
            self.StateLease = StateLease_
# end class Block


class BuyersCurrency(GeneratedsSuper):
    """Indicates the currency of the buyer."""
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None):
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if BuyersCurrency.subclass:
            return BuyersCurrency.subclass(*args_, **kwargs_)
        else:
            return BuyersCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='BuyersCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuyersCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='BuyersCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='BuyersCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BuyersCurrency'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class BuyersCurrency


class ChangeOrderInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OrderChangeNumber=None, OrderChangeDate=None, PurchaseOrderTypeCode=None, SalesOrderNumber=None, SequenceNumber=None):
        self.OrderChangeNumber = OrderChangeNumber
        self.OrderChangeDate = OrderChangeDate
        self.PurchaseOrderTypeCode = PurchaseOrderTypeCode
        self.SalesOrderNumber = SalesOrderNumber
        self.SequenceNumber = SequenceNumber
    def factory(*args_, **kwargs_):
        if ChangeOrderInformation.subclass:
            return ChangeOrderInformation.subclass(*args_, **kwargs_)
        else:
            return ChangeOrderInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrderChangeNumber(self): return self.OrderChangeNumber
    def set_OrderChangeNumber(self, OrderChangeNumber): self.OrderChangeNumber = OrderChangeNumber
    def get_OrderChangeDate(self): return self.OrderChangeDate
    def set_OrderChangeDate(self, OrderChangeDate): self.OrderChangeDate = OrderChangeDate
    def get_PurchaseOrderTypeCode(self): return self.PurchaseOrderTypeCode
    def set_PurchaseOrderTypeCode(self, PurchaseOrderTypeCode): self.PurchaseOrderTypeCode = PurchaseOrderTypeCode
    def get_SalesOrderNumber(self): return self.SalesOrderNumber
    def set_SalesOrderNumber(self, SalesOrderNumber): self.SalesOrderNumber = SalesOrderNumber
    def get_SequenceNumber(self): return self.SequenceNumber
    def set_SequenceNumber(self, SequenceNumber): self.SequenceNumber = SequenceNumber
    def hasContent_(self):
        if (
            self.OrderChangeNumber is not None or
            self.OrderChangeDate is not None or
            self.PurchaseOrderTypeCode is not None or
            self.SalesOrderNumber is not None or
            self.SequenceNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ChangeOrderInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChangeOrderInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ChangeOrderInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ChangeOrderInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrderChangeNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrderChangeNumber>%s</%sOrderChangeNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrderChangeNumber).encode(ExternalEncoding), input_name='OrderChangeNumber'), namespace_, eol_))
        if self.OrderChangeDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrderChangeDate>%s</%sOrderChangeDate>%s' % (namespace_, self.gds_format_date(self.OrderChangeDate, input_name='OrderChangeDate'), namespace_, eol_))
        if self.PurchaseOrderTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurchaseOrderTypeCode>%s</%sPurchaseOrderTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.PurchaseOrderTypeCode).encode(ExternalEncoding), input_name='PurchaseOrderTypeCode'), namespace_, eol_))
        if self.SalesOrderNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSalesOrderNumber>%s</%sSalesOrderNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.SalesOrderNumber).encode(ExternalEncoding), input_name='SalesOrderNumber'), namespace_, eol_))
        if self.SequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequenceNumber>%s</%sSequenceNumber>%s' % (namespace_, self.gds_format_integer(self.SequenceNumber, input_name='SequenceNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ChangeOrderInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OrderChangeNumber is not None:
            showIndent(outfile, level)
            outfile.write('OrderChangeNumber=%s,\n' % quote_python(self.OrderChangeNumber).encode(ExternalEncoding))
        if self.OrderChangeDate is not None:
            showIndent(outfile, level)
            outfile.write('OrderChangeDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.OrderChangeDate, input_name='OrderChangeDate'))
        if self.PurchaseOrderTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderTypeCode=%s,\n' % quote_python(self.PurchaseOrderTypeCode).encode(ExternalEncoding))
        if self.SalesOrderNumber is not None:
            showIndent(outfile, level)
            outfile.write('SalesOrderNumber=%s,\n' % quote_python(self.SalesOrderNumber).encode(ExternalEncoding))
        if self.SequenceNumber is not None:
            showIndent(outfile, level)
            outfile.write('SequenceNumber=%d,\n' % self.SequenceNumber)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrderChangeNumber':
            OrderChangeNumber_ = child_.text
            OrderChangeNumber_ = self.gds_validate_string(OrderChangeNumber_, node, 'OrderChangeNumber')
            self.OrderChangeNumber = OrderChangeNumber_
        elif nodeName_ == 'OrderChangeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'OrderChangeDate')
            self.OrderChangeDate = dval_
        elif nodeName_ == 'PurchaseOrderTypeCode':
            PurchaseOrderTypeCode_ = child_.text
            PurchaseOrderTypeCode_ = self.gds_validate_string(PurchaseOrderTypeCode_, node, 'PurchaseOrderTypeCode')
            self.PurchaseOrderTypeCode = PurchaseOrderTypeCode_
        elif nodeName_ == 'SalesOrderNumber':
            SalesOrderNumber_ = child_.text
            SalesOrderNumber_ = self.gds_validate_string(SalesOrderNumber_, node, 'SalesOrderNumber')
            self.SalesOrderNumber = SalesOrderNumber_
        elif nodeName_ == 'SequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceNumber')
            self.SequenceNumber = ival_
# end class ChangeOrderInformation


class CommodityCode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, agencyIndicator=None, valueOf_=None):
        self.agencyIndicator = _cast(None, agencyIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CommodityCode.subclass:
            return CommodityCode.subclass(*args_, **kwargs_)
        else:
            return CommodityCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agencyIndicator(self): return self.agencyIndicator
    def set_agencyIndicator(self, agencyIndicator): self.agencyIndicator = agencyIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CommodityCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CommodityCode'):
        if self.agencyIndicator is not None and 'agencyIndicator' not in already_processed:
            already_processed.add('agencyIndicator')
            outfile.write(' agencyIndicator=%s' % (self.gds_format_string(quote_attrib(self.agencyIndicator).encode(ExternalEncoding), input_name='agencyIndicator'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CommodityCode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CommodityCode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyIndicator is not None and 'agencyIndicator' not in already_processed:
            already_processed.add('agencyIndicator')
            showIndent(outfile, level)
            outfile.write('agencyIndicator = "%s",\n' % (self.agencyIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyIndicator', node)
        if value is not None and 'agencyIndicator' not in already_processed:
            already_processed.add('agencyIndicator')
            self.agencyIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityCode


class ContactIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, contactIdentifierIndicator=None, valueOf_=None):
        self.contactIdentifierIndicator = _cast(None, contactIdentifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ContactIdentifier.subclass:
            return ContactIdentifier.subclass(*args_, **kwargs_)
        else:
            return ContactIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contactIdentifierIndicator(self): return self.contactIdentifierIndicator
    def set_contactIdentifierIndicator(self, contactIdentifierIndicator): self.contactIdentifierIndicator = contactIdentifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ContactIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ContactIdentifier'):
        if self.contactIdentifierIndicator is not None and 'contactIdentifierIndicator' not in already_processed:
            already_processed.add('contactIdentifierIndicator')
            outfile.write(' contactIdentifierIndicator=%s' % (quote_attrib(self.contactIdentifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ContactIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ContactIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.contactIdentifierIndicator is not None and 'contactIdentifierIndicator' not in already_processed:
            already_processed.add('contactIdentifierIndicator')
            showIndent(outfile, level)
            outfile.write('contactIdentifierIndicator = %s,\n' % (self.contactIdentifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contactIdentifierIndicator', node)
        if value is not None and 'contactIdentifierIndicator' not in already_processed:
            already_processed.add('contactIdentifierIndicator')
            self.contactIdentifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactIdentifier


class ContactInformation(GeneratedsSuper):
    """Structure which contains the information for contacting a person,
    organization or business."""
    subclass = None
    superclass = None
    def __init__(self, contactInformationIndicator=None, ContactIdentifier=None, ContactName=None, ContactDescription=None, Telephone=None, EmailAddress=None, AlternativeCommunicationMethod=None, LanguageCode=None):
        self.contactInformationIndicator = _cast(None, contactInformationIndicator)
        self.ContactIdentifier = ContactIdentifier
        self.ContactName = ContactName
        self.ContactDescription = ContactDescription
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        if EmailAddress is None:
            self.EmailAddress = []
        else:
            self.EmailAddress = EmailAddress
        if AlternativeCommunicationMethod is None:
            self.AlternativeCommunicationMethod = []
        else:
            self.AlternativeCommunicationMethod = AlternativeCommunicationMethod
        self.LanguageCode = LanguageCode
    def factory(*args_, **kwargs_):
        if ContactInformation.subclass:
            return ContactInformation.subclass(*args_, **kwargs_)
        else:
            return ContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactIdentifier(self): return self.ContactIdentifier
    def set_ContactIdentifier(self, ContactIdentifier): self.ContactIdentifier = ContactIdentifier
    def get_ContactName(self): return self.ContactName
    def set_ContactName(self, ContactName): self.ContactName = ContactName
    def get_ContactDescription(self): return self.ContactDescription
    def set_ContactDescription(self, ContactDescription): self.ContactDescription = ContactDescription
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone(self, index, value): self.Telephone[index] = value
    def get_EmailAddress(self): return self.EmailAddress
    def set_EmailAddress(self, EmailAddress): self.EmailAddress = EmailAddress
    def add_EmailAddress(self, value): self.EmailAddress.append(value)
    def insert_EmailAddress(self, index, value): self.EmailAddress[index] = value
    def get_AlternativeCommunicationMethod(self): return self.AlternativeCommunicationMethod
    def set_AlternativeCommunicationMethod(self, AlternativeCommunicationMethod): self.AlternativeCommunicationMethod = AlternativeCommunicationMethod
    def add_AlternativeCommunicationMethod(self, value): self.AlternativeCommunicationMethod.append(value)
    def insert_AlternativeCommunicationMethod(self, index, value): self.AlternativeCommunicationMethod[index] = value
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_contactInformationIndicator(self): return self.contactInformationIndicator
    def set_contactInformationIndicator(self, contactInformationIndicator): self.contactInformationIndicator = contactInformationIndicator
    def hasContent_(self):
        if (
            self.ContactIdentifier is not None or
            self.ContactName is not None or
            self.ContactDescription is not None or
            self.Telephone or
            self.EmailAddress or
            self.AlternativeCommunicationMethod or
            self.LanguageCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ContactInformation'):
        if self.contactInformationIndicator is not None and 'contactInformationIndicator' not in already_processed:
            already_processed.add('contactInformationIndicator')
            outfile.write(' contactInformationIndicator=%s' % (quote_attrib(self.contactInformationIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactIdentifier is not None:
            self.ContactIdentifier.export(outfile, level, namespace_, name_='ContactIdentifier', pretty_print=pretty_print)
        if self.ContactName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactName>%s</%sContactName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactName).encode(ExternalEncoding), input_name='ContactName'), namespace_, eol_))
        if self.ContactDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactDescription>%s</%sContactDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.ContactDescription).encode(ExternalEncoding), input_name='ContactDescription'), namespace_, eol_))
        for Telephone_ in self.Telephone:
            Telephone_.export(outfile, level, namespace_, name_='Telephone', pretty_print=pretty_print)
        for EmailAddress_ in self.EmailAddress:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmailAddress>%s</%sEmailAddress>%s' % (namespace_, self.gds_format_string(quote_xml(EmailAddress_).encode(ExternalEncoding), input_name='EmailAddress'), namespace_, eol_))
        for AlternativeCommunicationMethod_ in self.AlternativeCommunicationMethod:
            AlternativeCommunicationMethod_.export(outfile, level, namespace_, name_='AlternativeCommunicationMethod', pretty_print=pretty_print)
        if self.LanguageCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLanguageCode>%s</%sLanguageCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ContactInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.contactInformationIndicator is not None and 'contactInformationIndicator' not in already_processed:
            already_processed.add('contactInformationIndicator')
            showIndent(outfile, level)
            outfile.write('contactInformationIndicator = %s,\n' % (self.contactInformationIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContactIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('ContactIdentifier=model_.ContactIdentifier(\n')
            self.ContactIdentifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactName is not None:
            showIndent(outfile, level)
            outfile.write('ContactName=%s,\n' % quote_python(self.ContactName).encode(ExternalEncoding))
        if self.ContactDescription is not None:
            showIndent(outfile, level)
            outfile.write('ContactDescription=%s,\n' % quote_python(self.ContactDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('model_.Telephone(\n')
            Telephone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EmailAddress=[\n')
        level += 1
        for EmailAddress_ in self.EmailAddress:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EmailAddress_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AlternativeCommunicationMethod=[\n')
        level += 1
        for AlternativeCommunicationMethod_ in self.AlternativeCommunicationMethod:
            showIndent(outfile, level)
            outfile.write('model_.AlternativeCommunicationMethod(\n')
            AlternativeCommunicationMethod_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LanguageCode is not None:
            showIndent(outfile, level)
            outfile.write('LanguageCode=%s,\n' % quote_python(self.LanguageCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contactInformationIndicator', node)
        if value is not None and 'contactInformationIndicator' not in already_processed:
            already_processed.add('contactInformationIndicator')
            self.contactInformationIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactIdentifier':
            obj_ = ContactIdentifier.factory()
            obj_.build(child_)
            self.set_ContactIdentifier(obj_)
        elif nodeName_ == 'ContactName':
            ContactName_ = child_.text
            ContactName_ = self.gds_validate_string(ContactName_, node, 'ContactName')
            self.ContactName = ContactName_
        elif nodeName_ == 'ContactDescription':
            ContactDescription_ = child_.text
            ContactDescription_ = self.gds_validate_string(ContactDescription_, node, 'ContactDescription')
            self.ContactDescription = ContactDescription_
        elif nodeName_ == 'Telephone':
            obj_ = Telephone.factory()
            obj_.build(child_)
            self.Telephone.append(obj_)
        elif nodeName_ == 'EmailAddress':
            EmailAddress_ = child_.text
            EmailAddress_ = self.gds_validate_string(EmailAddress_, node, 'EmailAddress')
            self.EmailAddress.append(EmailAddress_)
        elif nodeName_ == 'AlternativeCommunicationMethod':
            obj_ = AlternativeCommunicationMethod.factory()
            obj_.build(child_)
            self.AlternativeCommunicationMethod.append(obj_)
        elif nodeName_ == 'LanguageCode':
            LanguageCode_ = child_.text
            LanguageCode_ = self.gds_validate_string(LanguageCode_, node, 'LanguageCode')
            self.LanguageCode = LanguageCode_
# end class ContactInformation


class ConveyanceInformation(GeneratedsSuper):
    """Structure containing transportation and shipping information."""
    subclass = None
    superclass = None
    def __init__(self, ConveyanceIdentifier=None, VoyageTripNumber=None, VoyageTripDateTimeRange=None, EstimatedDateTimeOfArrival=None):
        self.ConveyanceIdentifier = ConveyanceIdentifier
        self.VoyageTripNumber = VoyageTripNumber
        self.VoyageTripDateTimeRange = VoyageTripDateTimeRange
        self.EstimatedDateTimeOfArrival = EstimatedDateTimeOfArrival
    def factory(*args_, **kwargs_):
        if ConveyanceInformation.subclass:
            return ConveyanceInformation.subclass(*args_, **kwargs_)
        else:
            return ConveyanceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConveyanceIdentifier(self): return self.ConveyanceIdentifier
    def set_ConveyanceIdentifier(self, ConveyanceIdentifier): self.ConveyanceIdentifier = ConveyanceIdentifier
    def get_VoyageTripNumber(self): return self.VoyageTripNumber
    def set_VoyageTripNumber(self, VoyageTripNumber): self.VoyageTripNumber = VoyageTripNumber
    def get_VoyageTripDateTimeRange(self): return self.VoyageTripDateTimeRange
    def set_VoyageTripDateTimeRange(self, VoyageTripDateTimeRange): self.VoyageTripDateTimeRange = VoyageTripDateTimeRange
    def get_EstimatedDateTimeOfArrival(self): return self.EstimatedDateTimeOfArrival
    def set_EstimatedDateTimeOfArrival(self, EstimatedDateTimeOfArrival): self.EstimatedDateTimeOfArrival = EstimatedDateTimeOfArrival
    def hasContent_(self):
        if (
            self.ConveyanceIdentifier is not None or
            self.VoyageTripNumber is not None or
            self.VoyageTripDateTimeRange is not None or
            self.EstimatedDateTimeOfArrival is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ConveyanceInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConveyanceInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ConveyanceInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ConveyanceInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConveyanceIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConveyanceIdentifier>%s</%sConveyanceIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConveyanceIdentifier).encode(ExternalEncoding), input_name='ConveyanceIdentifier'), namespace_, eol_))
        if self.VoyageTripNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVoyageTripNumber>%s</%sVoyageTripNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.VoyageTripNumber).encode(ExternalEncoding), input_name='VoyageTripNumber'), namespace_, eol_))
        if self.VoyageTripDateTimeRange is not None:
            self.VoyageTripDateTimeRange.export(outfile, level, namespace_, name_='VoyageTripDateTimeRange', pretty_print=pretty_print)
        if self.EstimatedDateTimeOfArrival is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEstimatedDateTimeOfArrival>%s</%sEstimatedDateTimeOfArrival>%s' % (namespace_, self.gds_format_datetime(self.EstimatedDateTimeOfArrival, input_name='EstimatedDateTimeOfArrival'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConveyanceInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConveyanceIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('ConveyanceIdentifier=%s,\n' % quote_python(self.ConveyanceIdentifier).encode(ExternalEncoding))
        if self.VoyageTripNumber is not None:
            showIndent(outfile, level)
            outfile.write('VoyageTripNumber=%s,\n' % quote_python(self.VoyageTripNumber).encode(ExternalEncoding))
        if self.VoyageTripDateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('VoyageTripDateTimeRange=model_.VoyageTripDateTimeRange(\n')
            self.VoyageTripDateTimeRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EstimatedDateTimeOfArrival is not None:
            showIndent(outfile, level)
            outfile.write('EstimatedDateTimeOfArrival=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.EstimatedDateTimeOfArrival, input_name='EstimatedDateTimeOfArrival'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConveyanceIdentifier':
            ConveyanceIdentifier_ = child_.text
            ConveyanceIdentifier_ = self.gds_validate_string(ConveyanceIdentifier_, node, 'ConveyanceIdentifier')
            self.ConveyanceIdentifier = ConveyanceIdentifier_
        elif nodeName_ == 'VoyageTripNumber':
            VoyageTripNumber_ = child_.text
            VoyageTripNumber_ = self.gds_validate_string(VoyageTripNumber_, node, 'VoyageTripNumber')
            self.VoyageTripNumber = VoyageTripNumber_
        elif nodeName_ == 'VoyageTripDateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_VoyageTripDateTimeRange(obj_)
        elif nodeName_ == 'EstimatedDateTimeOfArrival':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'EstimatedDateTimeOfArrival')
            self.EstimatedDateTimeOfArrival = dval_
# end class ConveyanceInformation


class CountryOfFinalDestination(GeneratedsSuper):
    """The country where product is ultimately delivered or is deemed to
    have been delivered."""
    subclass = None
    superclass = None
    def __init__(self, CountryCode=None):
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CountryOfFinalDestination.subclass:
            return CountryOfFinalDestination.subclass(*args_, **kwargs_)
        else:
            return CountryOfFinalDestination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.CountryCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CountryOfFinalDestination', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryOfFinalDestination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CountryOfFinalDestination'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CountryOfFinalDestination', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountryCode>%s</%sCountryCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CountryCode).encode(ExternalEncoding), input_name='CountryCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CountryOfFinalDestination'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CountryCode is not None:
            showIndent(outfile, level)
            outfile.write('CountryCode=%s,\n' % quote_python(self.CountryCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class CountryOfFinalDestination


class CountryOfOrigin(GeneratedsSuper):
    """The country where product originates or is deemed to have
    originated."""
    subclass = None
    superclass = None
    def __init__(self, CountryCode=None):
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CountryOfOrigin.subclass:
            return CountryOfOrigin.subclass(*args_, **kwargs_)
        else:
            return CountryOfOrigin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.CountryCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CountryOfOrigin', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryOfOrigin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CountryOfOrigin'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CountryOfOrigin', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountryCode>%s</%sCountryCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CountryCode).encode(ExternalEncoding), input_name='CountryCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CountryOfOrigin'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CountryCode is not None:
            showIndent(outfile, level)
            outfile.write('CountryCode=%s,\n' % quote_python(self.CountryCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class CountryOfOrigin


class CreditCardInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CreditCardNumber=None, CardHolderName=None, CreditCardType=None, CreditCardExpirationDate=None, CardAuthorizationCode=None, CardReferenceNumber=None):
        self.CreditCardNumber = CreditCardNumber
        self.CardHolderName = CardHolderName
        self.CreditCardType = CreditCardType
        self.CreditCardExpirationDate = CreditCardExpirationDate
        self.CardAuthorizationCode = CardAuthorizationCode
        self.CardReferenceNumber = CardReferenceNumber
    def factory(*args_, **kwargs_):
        if CreditCardInformation.subclass:
            return CreditCardInformation.subclass(*args_, **kwargs_)
        else:
            return CreditCardInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CreditCardNumber(self): return self.CreditCardNumber
    def set_CreditCardNumber(self, CreditCardNumber): self.CreditCardNumber = CreditCardNumber
    def get_CardHolderName(self): return self.CardHolderName
    def set_CardHolderName(self, CardHolderName): self.CardHolderName = CardHolderName
    def get_CreditCardType(self): return self.CreditCardType
    def set_CreditCardType(self, CreditCardType): self.CreditCardType = CreditCardType
    def get_CreditCardExpirationDate(self): return self.CreditCardExpirationDate
    def set_CreditCardExpirationDate(self, CreditCardExpirationDate): self.CreditCardExpirationDate = CreditCardExpirationDate
    def get_CardAuthorizationCode(self): return self.CardAuthorizationCode
    def set_CardAuthorizationCode(self, CardAuthorizationCode): self.CardAuthorizationCode = CardAuthorizationCode
    def get_CardReferenceNumber(self): return self.CardReferenceNumber
    def set_CardReferenceNumber(self, CardReferenceNumber): self.CardReferenceNumber = CardReferenceNumber
    def hasContent_(self):
        if (
            self.CreditCardNumber is not None or
            self.CardHolderName is not None or
            self.CreditCardType is not None or
            self.CreditCardExpirationDate is not None or
            self.CardAuthorizationCode is not None or
            self.CardReferenceNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CreditCardInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditCardInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CreditCardInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CreditCardInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CreditCardNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreditCardNumber>%s</%sCreditCardNumber>%s' % (namespace_, self.gds_format_integer(self.CreditCardNumber, input_name='CreditCardNumber'), namespace_, eol_))
        if self.CardHolderName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCardHolderName>%s</%sCardHolderName>%s' % (namespace_, self.gds_format_string(quote_xml(self.CardHolderName).encode(ExternalEncoding), input_name='CardHolderName'), namespace_, eol_))
        if self.CreditCardType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreditCardType>%s</%sCreditCardType>%s' % (namespace_, self.gds_format_string(quote_xml(self.CreditCardType).encode(ExternalEncoding), input_name='CreditCardType'), namespace_, eol_))
        if self.CreditCardExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreditCardExpirationDate>%s</%sCreditCardExpirationDate>%s' % (namespace_, self.gds_format_date(self.CreditCardExpirationDate, input_name='CreditCardExpirationDate'), namespace_, eol_))
        if self.CardAuthorizationCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCardAuthorizationCode>%s</%sCardAuthorizationCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CardAuthorizationCode).encode(ExternalEncoding), input_name='CardAuthorizationCode'), namespace_, eol_))
        if self.CardReferenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCardReferenceNumber>%s</%sCardReferenceNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.CardReferenceNumber).encode(ExternalEncoding), input_name='CardReferenceNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CreditCardInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CreditCardNumber is not None:
            showIndent(outfile, level)
            outfile.write('CreditCardNumber=%d,\n' % self.CreditCardNumber)
        if self.CardHolderName is not None:
            showIndent(outfile, level)
            outfile.write('CardHolderName=%s,\n' % quote_python(self.CardHolderName).encode(ExternalEncoding))
        if self.CreditCardType is not None:
            showIndent(outfile, level)
            outfile.write('CreditCardType=%s,\n' % quote_python(self.CreditCardType).encode(ExternalEncoding))
        if self.CreditCardExpirationDate is not None:
            showIndent(outfile, level)
            outfile.write('CreditCardExpirationDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.CreditCardExpirationDate, input_name='CreditCardExpirationDate'))
        if self.CardAuthorizationCode is not None:
            showIndent(outfile, level)
            outfile.write('CardAuthorizationCode=%s,\n' % quote_python(self.CardAuthorizationCode).encode(ExternalEncoding))
        if self.CardReferenceNumber is not None:
            showIndent(outfile, level)
            outfile.write('CardReferenceNumber=%s,\n' % quote_python(self.CardReferenceNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CreditCardNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CreditCardNumber')
            self.CreditCardNumber = ival_
        elif nodeName_ == 'CardHolderName':
            CardHolderName_ = child_.text
            CardHolderName_ = self.gds_validate_string(CardHolderName_, node, 'CardHolderName')
            self.CardHolderName = CardHolderName_
        elif nodeName_ == 'CreditCardType':
            CreditCardType_ = child_.text
            CreditCardType_ = self.gds_validate_string(CreditCardType_, node, 'CreditCardType')
            self.CreditCardType = CreditCardType_
        elif nodeName_ == 'CreditCardExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'CreditCardExpirationDate')
            self.CreditCardExpirationDate = dval_
        elif nodeName_ == 'CardAuthorizationCode':
            CardAuthorizationCode_ = child_.text
            CardAuthorizationCode_ = self.gds_validate_string(CardAuthorizationCode_, node, 'CardAuthorizationCode')
            self.CardAuthorizationCode = CardAuthorizationCode_
        elif nodeName_ == 'CardReferenceNumber':
            CardReferenceNumber_ = child_.text
            CardReferenceNumber_ = self.gds_validate_string(CardReferenceNumber_, node, 'CardReferenceNumber')
            self.CardReferenceNumber = CardReferenceNumber_
# end class CreditCardInformation


class CurrencyRates(GeneratedsSuper):
    """Structure which contains information about the rates at which
    currency is exchanged."""
    subclass = None
    superclass = None
    def __init__(self, SellersCurrency=None, BuyersCurrency=None, ExchangeRate=None):
        self.SellersCurrency = SellersCurrency
        self.BuyersCurrency = BuyersCurrency
        self.ExchangeRate = ExchangeRate
    def factory(*args_, **kwargs_):
        if CurrencyRates.subclass:
            return CurrencyRates.subclass(*args_, **kwargs_)
        else:
            return CurrencyRates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SellersCurrency(self): return self.SellersCurrency
    def set_SellersCurrency(self, SellersCurrency): self.SellersCurrency = SellersCurrency
    def get_BuyersCurrency(self): return self.BuyersCurrency
    def set_BuyersCurrency(self, BuyersCurrency): self.BuyersCurrency = BuyersCurrency
    def get_ExchangeRate(self): return self.ExchangeRate
    def set_ExchangeRate(self, ExchangeRate): self.ExchangeRate = ExchangeRate
    def hasContent_(self):
        if (
            self.SellersCurrency is not None or
            self.BuyersCurrency is not None or
            self.ExchangeRate is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CurrencyRates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrencyRates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CurrencyRates'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CurrencyRates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SellersCurrency is not None:
            self.SellersCurrency.export(outfile, level, namespace_, name_='SellersCurrency', pretty_print=pretty_print)
        if self.BuyersCurrency is not None:
            self.BuyersCurrency.export(outfile, level, namespace_, name_='BuyersCurrency', pretty_print=pretty_print)
        if self.ExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExchangeRate>%s</%sExchangeRate>%s' % (namespace_, self.gds_format_float(self.ExchangeRate, input_name='ExchangeRate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CurrencyRates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SellersCurrency is not None:
            showIndent(outfile, level)
            outfile.write('SellersCurrency=model_.SellersCurrency(\n')
            self.SellersCurrency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BuyersCurrency is not None:
            showIndent(outfile, level)
            outfile.write('BuyersCurrency=model_.BuyersCurrency(\n')
            self.BuyersCurrency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExchangeRate is not None:
            showIndent(outfile, level)
            outfile.write('ExchangeRate=%f,\n' % self.ExchangeRate)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SellersCurrency':
            obj_ = SellersCurrency.factory()
            obj_.build(child_)
            self.set_SellersCurrency(obj_)
        elif nodeName_ == 'BuyersCurrency':
            obj_ = BuyersCurrency.factory()
            obj_.build(child_)
            self.set_BuyersCurrency(obj_)
        elif nodeName_ == 'ExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ExchangeRate')
            self.ExchangeRate = fval_
# end class CurrencyRates


class CustodyLocationIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifierIndicator=None, valueOf_=None):
        self.identifierIndicator = _cast(None, identifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CustodyLocationIdentifier.subclass:
            return CustodyLocationIdentifier.subclass(*args_, **kwargs_)
        else:
            return CustodyLocationIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifierIndicator(self): return self.identifierIndicator
    def set_identifierIndicator(self, identifierIndicator): self.identifierIndicator = identifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyLocationIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyLocationIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyLocationIdentifier'):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            outfile.write(' identifierIndicator=%s' % (quote_attrib(self.identifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyLocationIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CustodyLocationIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            showIndent(outfile, level)
            outfile.write('identifierIndicator = %s,\n' % (self.identifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('identifierIndicator', node)
        if value is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            self.identifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CustodyLocationIdentifier


class CustodyLocationInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustodyLocationIdentifier=None, CustodyLocationDescription=None, AddressInformation=None, GeographicalInformation=None):
        if CustodyLocationIdentifier is None:
            self.CustodyLocationIdentifier = []
        else:
            self.CustodyLocationIdentifier = CustodyLocationIdentifier
        self.CustodyLocationDescription = CustodyLocationDescription
        self.AddressInformation = AddressInformation
        self.GeographicalInformation = GeographicalInformation
    def factory(*args_, **kwargs_):
        if CustodyLocationInformation.subclass:
            return CustodyLocationInformation.subclass(*args_, **kwargs_)
        else:
            return CustodyLocationInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustodyLocationIdentifier(self): return self.CustodyLocationIdentifier
    def set_CustodyLocationIdentifier(self, CustodyLocationIdentifier): self.CustodyLocationIdentifier = CustodyLocationIdentifier
    def add_CustodyLocationIdentifier(self, value): self.CustodyLocationIdentifier.append(value)
    def insert_CustodyLocationIdentifier(self, index, value): self.CustodyLocationIdentifier[index] = value
    def get_CustodyLocationDescription(self): return self.CustodyLocationDescription
    def set_CustodyLocationDescription(self, CustodyLocationDescription): self.CustodyLocationDescription = CustodyLocationDescription
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_GeographicalInformation(self): return self.GeographicalInformation
    def set_GeographicalInformation(self, GeographicalInformation): self.GeographicalInformation = GeographicalInformation
    def hasContent_(self):
        if (
            self.CustodyLocationIdentifier or
            self.CustodyLocationDescription is not None or
            self.AddressInformation is not None or
            self.GeographicalInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyLocationInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyLocationInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyLocationInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyLocationInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustodyLocationIdentifier_ in self.CustodyLocationIdentifier:
            CustodyLocationIdentifier_.export(outfile, level, namespace_, name_='CustodyLocationIdentifier', pretty_print=pretty_print)
        if self.CustodyLocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustodyLocationDescription>%s</%sCustodyLocationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.CustodyLocationDescription).encode(ExternalEncoding), input_name='CustodyLocationDescription'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.GeographicalInformation is not None:
            self.GeographicalInformation.export(outfile, level, namespace_, name_='GeographicalInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustodyLocationInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CustodyLocationIdentifier=[\n')
        level += 1
        for CustodyLocationIdentifier_ in self.CustodyLocationIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.CustodyLocationIdentifier(\n')
            CustodyLocationIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CustodyLocationDescription is not None:
            showIndent(outfile, level)
            outfile.write('CustodyLocationDescription=%s,\n' % quote_python(self.CustodyLocationDescription).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeographicalInformation is not None:
            showIndent(outfile, level)
            outfile.write('GeographicalInformation=model_.GeographicalInformation(\n')
            self.GeographicalInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustodyLocationIdentifier':
            obj_ = CustodyLocationIdentifier.factory()
            obj_.build(child_)
            self.CustodyLocationIdentifier.append(obj_)
        elif nodeName_ == 'CustodyLocationDescription':
            CustodyLocationDescription_ = child_.text
            CustodyLocationDescription_ = self.gds_validate_string(CustodyLocationDescription_, node, 'CustodyLocationDescription')
            self.CustodyLocationDescription = CustodyLocationDescription_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'GeographicalInformation':
            obj_ = GeographicalInformation.factory()
            obj_.build(child_)
            self.set_GeographicalInformation(obj_)
# end class CustodyLocationInformation


class CustodyTicketInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, custodyTicketType=None, thirdPartyTicketIndicator=None, CustodyTicketNumber=None, CustodyTicketDateTime=None, CustodyTransferStartDateTime=None, CustodyTransferStopDateTime=None, RevisionNumber=None, CustodySupercedeTicketNumber=None, ConnectingCarrierTicketNumber=None):
        self.custodyTicketType = _cast(None, custodyTicketType)
        self.thirdPartyTicketIndicator = _cast(None, thirdPartyTicketIndicator)
        self.CustodyTicketNumber = CustodyTicketNumber
        self.CustodyTicketDateTime = CustodyTicketDateTime
        self.CustodyTransferStartDateTime = CustodyTransferStartDateTime
        self.CustodyTransferStopDateTime = CustodyTransferStopDateTime
        self.RevisionNumber = RevisionNumber
        self.CustodySupercedeTicketNumber = CustodySupercedeTicketNumber
        self.ConnectingCarrierTicketNumber = ConnectingCarrierTicketNumber
    def factory(*args_, **kwargs_):
        if CustodyTicketInformation.subclass:
            return CustodyTicketInformation.subclass(*args_, **kwargs_)
        else:
            return CustodyTicketInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustodyTicketNumber(self): return self.CustodyTicketNumber
    def set_CustodyTicketNumber(self, CustodyTicketNumber): self.CustodyTicketNumber = CustodyTicketNumber
    def get_CustodyTicketDateTime(self): return self.CustodyTicketDateTime
    def set_CustodyTicketDateTime(self, CustodyTicketDateTime): self.CustodyTicketDateTime = CustodyTicketDateTime
    def get_CustodyTransferStartDateTime(self): return self.CustodyTransferStartDateTime
    def set_CustodyTransferStartDateTime(self, CustodyTransferStartDateTime): self.CustodyTransferStartDateTime = CustodyTransferStartDateTime
    def get_CustodyTransferStopDateTime(self): return self.CustodyTransferStopDateTime
    def set_CustodyTransferStopDateTime(self, CustodyTransferStopDateTime): self.CustodyTransferStopDateTime = CustodyTransferStopDateTime
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def get_CustodySupercedeTicketNumber(self): return self.CustodySupercedeTicketNumber
    def set_CustodySupercedeTicketNumber(self, CustodySupercedeTicketNumber): self.CustodySupercedeTicketNumber = CustodySupercedeTicketNumber
    def get_ConnectingCarrierTicketNumber(self): return self.ConnectingCarrierTicketNumber
    def set_ConnectingCarrierTicketNumber(self, ConnectingCarrierTicketNumber): self.ConnectingCarrierTicketNumber = ConnectingCarrierTicketNumber
    def get_custodyTicketType(self): return self.custodyTicketType
    def set_custodyTicketType(self, custodyTicketType): self.custodyTicketType = custodyTicketType
    def get_thirdPartyTicketIndicator(self): return self.thirdPartyTicketIndicator
    def set_thirdPartyTicketIndicator(self, thirdPartyTicketIndicator): self.thirdPartyTicketIndicator = thirdPartyTicketIndicator
    def hasContent_(self):
        if (
            self.CustodyTicketNumber is not None or
            self.CustodyTicketDateTime is not None or
            self.CustodyTransferStartDateTime is not None or
            self.CustodyTransferStopDateTime is not None or
            self.RevisionNumber is not None or
            self.CustodySupercedeTicketNumber is not None or
            self.ConnectingCarrierTicketNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyTicketInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyTicketInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyTicketInformation'):
        if self.custodyTicketType is not None and 'custodyTicketType' not in already_processed:
            already_processed.add('custodyTicketType')
            outfile.write(' custodyTicketType=%s' % (quote_attrib(self.custodyTicketType), ))
        if self.thirdPartyTicketIndicator is not None and 'thirdPartyTicketIndicator' not in already_processed:
            already_processed.add('thirdPartyTicketIndicator')
            outfile.write(' thirdPartyTicketIndicator=%s' % (quote_attrib(self.thirdPartyTicketIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyTicketInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustodyTicketNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustodyTicketNumber>%s</%sCustodyTicketNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.CustodyTicketNumber).encode(ExternalEncoding), input_name='CustodyTicketNumber'), namespace_, eol_))
        if self.CustodyTicketDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustodyTicketDateTime>%s</%sCustodyTicketDateTime>%s' % (namespace_, self.gds_format_datetime(self.CustodyTicketDateTime, input_name='CustodyTicketDateTime'), namespace_, eol_))
        if self.CustodyTransferStartDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustodyTransferStartDateTime>%s</%sCustodyTransferStartDateTime>%s' % (namespace_, self.gds_format_datetime(self.CustodyTransferStartDateTime, input_name='CustodyTransferStartDateTime'), namespace_, eol_))
        if self.CustodyTransferStopDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustodyTransferStopDateTime>%s</%sCustodyTransferStopDateTime>%s' % (namespace_, self.gds_format_datetime(self.CustodyTransferStopDateTime, input_name='CustodyTransferStopDateTime'), namespace_, eol_))
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
        if self.CustodySupercedeTicketNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustodySupercedeTicketNumber>%s</%sCustodySupercedeTicketNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.CustodySupercedeTicketNumber).encode(ExternalEncoding), input_name='CustodySupercedeTicketNumber'), namespace_, eol_))
        if self.ConnectingCarrierTicketNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConnectingCarrierTicketNumber>%s</%sConnectingCarrierTicketNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConnectingCarrierTicketNumber).encode(ExternalEncoding), input_name='ConnectingCarrierTicketNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CustodyTicketInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.custodyTicketType is not None and 'custodyTicketType' not in already_processed:
            already_processed.add('custodyTicketType')
            showIndent(outfile, level)
            outfile.write('custodyTicketType = %s,\n' % (self.custodyTicketType,))
        if self.thirdPartyTicketIndicator is not None and 'thirdPartyTicketIndicator' not in already_processed:
            already_processed.add('thirdPartyTicketIndicator')
            showIndent(outfile, level)
            outfile.write('thirdPartyTicketIndicator = %s,\n' % (self.thirdPartyTicketIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CustodyTicketNumber is not None:
            showIndent(outfile, level)
            outfile.write('CustodyTicketNumber=%s,\n' % quote_python(self.CustodyTicketNumber).encode(ExternalEncoding))
        if self.CustodyTicketDateTime is not None:
            showIndent(outfile, level)
            outfile.write('CustodyTicketDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.CustodyTicketDateTime, input_name='CustodyTicketDateTime'))
        if self.CustodyTransferStartDateTime is not None:
            showIndent(outfile, level)
            outfile.write('CustodyTransferStartDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.CustodyTransferStartDateTime, input_name='CustodyTransferStartDateTime'))
        if self.CustodyTransferStopDateTime is not None:
            showIndent(outfile, level)
            outfile.write('CustodyTransferStopDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.CustodyTransferStopDateTime, input_name='CustodyTransferStopDateTime'))
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
        if self.CustodySupercedeTicketNumber is not None:
            showIndent(outfile, level)
            outfile.write('CustodySupercedeTicketNumber=%s,\n' % quote_python(self.CustodySupercedeTicketNumber).encode(ExternalEncoding))
        if self.ConnectingCarrierTicketNumber is not None:
            showIndent(outfile, level)
            outfile.write('ConnectingCarrierTicketNumber=%s,\n' % quote_python(self.ConnectingCarrierTicketNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('custodyTicketType', node)
        if value is not None and 'custodyTicketType' not in already_processed:
            already_processed.add('custodyTicketType')
            self.custodyTicketType = value
        value = find_attr_value_('thirdPartyTicketIndicator', node)
        if value is not None and 'thirdPartyTicketIndicator' not in already_processed:
            already_processed.add('thirdPartyTicketIndicator')
            self.thirdPartyTicketIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustodyTicketNumber':
            CustodyTicketNumber_ = child_.text
            CustodyTicketNumber_ = self.gds_validate_string(CustodyTicketNumber_, node, 'CustodyTicketNumber')
            self.CustodyTicketNumber = CustodyTicketNumber_
        elif nodeName_ == 'CustodyTicketDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'CustodyTicketDateTime')
            self.CustodyTicketDateTime = dval_
        elif nodeName_ == 'CustodyTransferStartDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'CustodyTransferStartDateTime')
            self.CustodyTransferStartDateTime = dval_
        elif nodeName_ == 'CustodyTransferStopDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'CustodyTransferStopDateTime')
            self.CustodyTransferStopDateTime = dval_
        elif nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
        elif nodeName_ == 'CustodySupercedeTicketNumber':
            CustodySupercedeTicketNumber_ = child_.text
            CustodySupercedeTicketNumber_ = self.gds_validate_string(CustodySupercedeTicketNumber_, node, 'CustodySupercedeTicketNumber')
            self.CustodySupercedeTicketNumber = CustodySupercedeTicketNumber_
        elif nodeName_ == 'ConnectingCarrierTicketNumber':
            ConnectingCarrierTicketNumber_ = child_.text
            ConnectingCarrierTicketNumber_ = self.gds_validate_string(ConnectingCarrierTicketNumber_, node, 'ConnectingCarrierTicketNumber')
            self.ConnectingCarrierTicketNumber = ConnectingCarrierTicketNumber_
# end class CustodyTicketInformation


class CustodyTicketTimeLog(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustodyTicketTimeLogEntry=None):
        if CustodyTicketTimeLogEntry is None:
            self.CustodyTicketTimeLogEntry = []
        else:
            self.CustodyTicketTimeLogEntry = CustodyTicketTimeLogEntry
    def factory(*args_, **kwargs_):
        if CustodyTicketTimeLog.subclass:
            return CustodyTicketTimeLog.subclass(*args_, **kwargs_)
        else:
            return CustodyTicketTimeLog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustodyTicketTimeLogEntry(self): return self.CustodyTicketTimeLogEntry
    def set_CustodyTicketTimeLogEntry(self, CustodyTicketTimeLogEntry): self.CustodyTicketTimeLogEntry = CustodyTicketTimeLogEntry
    def add_CustodyTicketTimeLogEntry(self, value): self.CustodyTicketTimeLogEntry.append(value)
    def insert_CustodyTicketTimeLogEntry(self, index, value): self.CustodyTicketTimeLogEntry[index] = value
    def hasContent_(self):
        if (
            self.CustodyTicketTimeLogEntry
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyTicketTimeLog', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyTicketTimeLog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyTicketTimeLog'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyTicketTimeLog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustodyTicketTimeLogEntry_ in self.CustodyTicketTimeLogEntry:
            CustodyTicketTimeLogEntry_.export(outfile, level, namespace_, name_='CustodyTicketTimeLogEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustodyTicketTimeLog'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CustodyTicketTimeLogEntry=[\n')
        level += 1
        for CustodyTicketTimeLogEntry_ in self.CustodyTicketTimeLogEntry:
            showIndent(outfile, level)
            outfile.write('model_.CustodyTicketTimeLogEntry(\n')
            CustodyTicketTimeLogEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustodyTicketTimeLogEntry':
            obj_ = CustodyTicketTimeLogEntry.factory()
            obj_.build(child_)
            self.CustodyTicketTimeLogEntry.append(obj_)
# end class CustodyTicketTimeLog


class CustodyTicketTimeLogEntry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TimeLogDateTime=None, TimeLogActivity=None):
        self.TimeLogDateTime = TimeLogDateTime
        if TimeLogActivity is None:
            self.TimeLogActivity = []
        else:
            self.TimeLogActivity = TimeLogActivity
    def factory(*args_, **kwargs_):
        if CustodyTicketTimeLogEntry.subclass:
            return CustodyTicketTimeLogEntry.subclass(*args_, **kwargs_)
        else:
            return CustodyTicketTimeLogEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeLogDateTime(self): return self.TimeLogDateTime
    def set_TimeLogDateTime(self, TimeLogDateTime): self.TimeLogDateTime = TimeLogDateTime
    def get_TimeLogActivity(self): return self.TimeLogActivity
    def set_TimeLogActivity(self, TimeLogActivity): self.TimeLogActivity = TimeLogActivity
    def add_TimeLogActivity(self, value): self.TimeLogActivity.append(value)
    def insert_TimeLogActivity(self, index, value): self.TimeLogActivity[index] = value
    def hasContent_(self):
        if (
            self.TimeLogDateTime is not None or
            self.TimeLogActivity
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyTicketTimeLogEntry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyTicketTimeLogEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyTicketTimeLogEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyTicketTimeLogEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeLogDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeLogDateTime>%s</%sTimeLogDateTime>%s' % (namespace_, self.gds_format_datetime(self.TimeLogDateTime, input_name='TimeLogDateTime'), namespace_, eol_))
        for TimeLogActivity_ in self.TimeLogActivity:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeLogActivity>%s</%sTimeLogActivity>%s' % (namespace_, self.gds_format_string(quote_xml(TimeLogActivity_).encode(ExternalEncoding), input_name='TimeLogActivity'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CustodyTicketTimeLogEntry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeLogDateTime is not None:
            showIndent(outfile, level)
            outfile.write('TimeLogDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.TimeLogDateTime, input_name='TimeLogDateTime'))
        showIndent(outfile, level)
        outfile.write('TimeLogActivity=[\n')
        level += 1
        for TimeLogActivity_ in self.TimeLogActivity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TimeLogActivity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeLogDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'TimeLogDateTime')
            self.TimeLogDateTime = dval_
        elif nodeName_ == 'TimeLogActivity':
            TimeLogActivity_ = child_.text
            TimeLogActivity_ = self.gds_validate_string(TimeLogActivity_, node, 'TimeLogActivity')
            self.TimeLogActivity.append(TimeLogActivity_)
# end class CustodyTicketTimeLogEntry


class CustodyTransferInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FromPartner=None, ToPartner=None):
        self.FromPartner = FromPartner
        self.ToPartner = ToPartner
    def factory(*args_, **kwargs_):
        if CustodyTransferInformation.subclass:
            return CustodyTransferInformation.subclass(*args_, **kwargs_)
        else:
            return CustodyTransferInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FromPartner(self): return self.FromPartner
    def set_FromPartner(self, FromPartner): self.FromPartner = FromPartner
    def get_ToPartner(self): return self.ToPartner
    def set_ToPartner(self, ToPartner): self.ToPartner = ToPartner
    def hasContent_(self):
        if (
            self.FromPartner is not None or
            self.ToPartner is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyTransferInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyTransferInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyTransferInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyTransferInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FromPartner is not None:
            self.FromPartner.export(outfile, level, namespace_, name_='FromPartner', pretty_print=pretty_print)
        if self.ToPartner is not None:
            self.ToPartner.export(outfile, level, namespace_, name_='ToPartner', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustodyTransferInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FromPartner is not None:
            showIndent(outfile, level)
            outfile.write('FromPartner=model_.FromPartner(\n')
            self.FromPartner.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ToPartner is not None:
            showIndent(outfile, level)
            outfile.write('ToPartner=model_.ToPartner(\n')
            self.ToPartner.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FromPartner':
            obj_ = CustodyPartnerType.factory()
            obj_.build(child_)
            self.set_FromPartner(obj_)
        elif nodeName_ == 'ToPartner':
            obj_ = CustodyPartnerType.factory()
            obj_.build(child_)
            self.set_ToPartner(obj_)
# end class CustodyTransferInformation


class CustomerSpecificInformation(GeneratedsSuper):
    """Holds information required by a specific customer to complete a
    transaction.Identifies the kind of information being given."""
    subclass = None
    superclass = None
    def __init__(self, informationType=None, valueOf_=None):
        self.informationType = _cast(None, informationType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CustomerSpecificInformation.subclass:
            return CustomerSpecificInformation.subclass(*args_, **kwargs_)
        else:
            return CustomerSpecificInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationType(self): return self.informationType
    def set_informationType(self, informationType): self.informationType = informationType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustomerSpecificInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerSpecificInformation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustomerSpecificInformation'):
        if self.informationType is not None and 'informationType' not in already_processed:
            already_processed.add('informationType')
            outfile.write(' informationType=%s' % (self.gds_format_string(quote_attrib(self.informationType).encode(ExternalEncoding), input_name='informationType'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustomerSpecificInformation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CustomerSpecificInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.informationType is not None and 'informationType' not in already_processed:
            already_processed.add('informationType')
            showIndent(outfile, level)
            outfile.write('informationType = "%s",\n' % (self.informationType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationType', node)
        if value is not None and 'informationType' not in already_processed:
            already_processed.add('informationType')
            self.informationType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CustomerSpecificInformation


class Deferred(GeneratedsSuper):
    """Structure containing the terms for a deferred payment in relation to
    a transaction."""
    subclass = None
    superclass = None
    def __init__(self, DeferredAmount=None, DeferredDueDate=None, PercentDeferredPayable=None, Description=None):
        self.DeferredAmount = DeferredAmount
        self.DeferredDueDate = DeferredDueDate
        self.PercentDeferredPayable = PercentDeferredPayable
        self.Description = Description
    def factory(*args_, **kwargs_):
        if Deferred.subclass:
            return Deferred.subclass(*args_, **kwargs_)
        else:
            return Deferred(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeferredAmount(self): return self.DeferredAmount
    def set_DeferredAmount(self, DeferredAmount): self.DeferredAmount = DeferredAmount
    def get_DeferredDueDate(self): return self.DeferredDueDate
    def set_DeferredDueDate(self, DeferredDueDate): self.DeferredDueDate = DeferredDueDate
    def get_PercentDeferredPayable(self): return self.PercentDeferredPayable
    def set_PercentDeferredPayable(self, PercentDeferredPayable): self.PercentDeferredPayable = PercentDeferredPayable
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.DeferredAmount is not None or
            self.DeferredDueDate is not None or
            self.PercentDeferredPayable is not None or
            self.Description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Deferred', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deferred')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Deferred'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Deferred', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeferredAmount is not None:
            self.DeferredAmount.export(outfile, level, namespace_, name_='DeferredAmount', pretty_print=pretty_print)
        if self.DeferredDueDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeferredDueDate>%s</%sDeferredDueDate>%s' % (namespace_, self.gds_format_date(self.DeferredDueDate, input_name='DeferredDueDate'), namespace_, eol_))
        if self.PercentDeferredPayable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentDeferredPayable>%s</%sPercentDeferredPayable>%s' % (namespace_, self.gds_format_float(self.PercentDeferredPayable, input_name='PercentDeferredPayable'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Deferred'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DeferredAmount is not None:
            showIndent(outfile, level)
            outfile.write('DeferredAmount=model_.DeferredAmount(\n')
            self.DeferredAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DeferredDueDate is not None:
            showIndent(outfile, level)
            outfile.write('DeferredDueDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.DeferredDueDate, input_name='DeferredDueDate'))
        if self.PercentDeferredPayable is not None:
            showIndent(outfile, level)
            outfile.write('PercentDeferredPayable=%f,\n' % self.PercentDeferredPayable)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeferredAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DeferredAmount(obj_)
        elif nodeName_ == 'DeferredDueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'DeferredDueDate')
            self.DeferredDueDate = dval_
        elif nodeName_ == 'PercentDeferredPayable':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentDeferredPayable')
            self.PercentDeferredPayable = fval_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class Deferred


class DeliveryTolerances(GeneratedsSuper):
    """Structure containing information on the limits between which the
    delivered quantity can vary. Can be specified as either a
    quantity or percentage."""
    subclass = None
    superclass = None
    def __init__(self, UpperLimit=None, LowerLimit=None):
        self.UpperLimit = UpperLimit
        self.LowerLimit = LowerLimit
    def factory(*args_, **kwargs_):
        if DeliveryTolerances.subclass:
            return DeliveryTolerances.subclass(*args_, **kwargs_)
        else:
            return DeliveryTolerances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UpperLimit(self): return self.UpperLimit
    def set_UpperLimit(self, UpperLimit): self.UpperLimit = UpperLimit
    def get_LowerLimit(self): return self.LowerLimit
    def set_LowerLimit(self, LowerLimit): self.LowerLimit = LowerLimit
    def hasContent_(self):
        if (
            self.UpperLimit is not None or
            self.LowerLimit is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='DeliveryTolerances', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryTolerances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='DeliveryTolerances'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='DeliveryTolerances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UpperLimit is not None:
            self.UpperLimit.export(outfile, level, namespace_, name_='UpperLimit', pretty_print=pretty_print)
        if self.LowerLimit is not None:
            self.LowerLimit.export(outfile, level, namespace_, name_='LowerLimit', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeliveryTolerances'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UpperLimit is not None:
            showIndent(outfile, level)
            outfile.write('UpperLimit=model_.UpperLimit(\n')
            self.UpperLimit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LowerLimit is not None:
            showIndent(outfile, level)
            outfile.write('LowerLimit=model_.LowerLimit(\n')
            self.LowerLimit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UpperLimit':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_UpperLimit(obj_)
        elif nodeName_ == 'LowerLimit':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_LowerLimit(obj_)
# end class DeliveryTolerances


class Discounts(GeneratedsSuper):
    """Structure containing the terms for a discount in relation to a
    transaction."""
    subclass = None
    superclass = None
    def __init__(self, DaysDue=None, DiscountsDueDate=None, PercentDiscount=None, DiscountAmount=None, Description=None):
        if DaysDue is None:
            self.DaysDue = []
        else:
            self.DaysDue = DaysDue
        if DiscountsDueDate is None:
            self.DiscountsDueDate = []
        else:
            self.DiscountsDueDate = DiscountsDueDate
        self.PercentDiscount = PercentDiscount
        self.DiscountAmount = DiscountAmount
        self.Description = Description
    def factory(*args_, **kwargs_):
        if Discounts.subclass:
            return Discounts.subclass(*args_, **kwargs_)
        else:
            return Discounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DaysDue(self): return self.DaysDue
    def set_DaysDue(self, DaysDue): self.DaysDue = DaysDue
    def add_DaysDue(self, value): self.DaysDue.append(value)
    def insert_DaysDue(self, index, value): self.DaysDue[index] = value
    def get_DiscountsDueDate(self): return self.DiscountsDueDate
    def set_DiscountsDueDate(self, DiscountsDueDate): self.DiscountsDueDate = DiscountsDueDate
    def add_DiscountsDueDate(self, value): self.DiscountsDueDate.append(value)
    def insert_DiscountsDueDate(self, index, value): self.DiscountsDueDate[index] = value
    def get_PercentDiscount(self): return self.PercentDiscount
    def set_PercentDiscount(self, PercentDiscount): self.PercentDiscount = PercentDiscount
    def get_DiscountAmount(self): return self.DiscountAmount
    def set_DiscountAmount(self, DiscountAmount): self.DiscountAmount = DiscountAmount
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.DaysDue or
            self.DiscountsDueDate or
            self.PercentDiscount is not None or
            self.DiscountAmount is not None or
            self.Description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Discounts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Discounts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Discounts'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Discounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DaysDue_ in self.DaysDue:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDaysDue>%s</%sDaysDue>%s' % (namespace_, self.gds_format_integer(DaysDue_, input_name='DaysDue'), namespace_, eol_))
        for DiscountsDueDate_ in self.DiscountsDueDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscountsDueDate>%s</%sDiscountsDueDate>%s' % (namespace_, self.gds_format_datetime(DiscountsDueDate_, input_name='DiscountsDueDate'), namespace_, eol_))
        if self.PercentDiscount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentDiscount>%s</%sPercentDiscount>%s' % (namespace_, self.gds_format_float(self.PercentDiscount, input_name='PercentDiscount'), namespace_, eol_))
        if self.DiscountAmount is not None:
            self.DiscountAmount.export(outfile, level, namespace_, name_='DiscountAmount', pretty_print=pretty_print)
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Discounts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DaysDue=[\n')
        level += 1
        for DaysDue_ in self.DaysDue:
            showIndent(outfile, level)
            outfile.write('%d,\n' % DaysDue_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiscountsDueDate=[\n')
        level += 1
        for DiscountsDueDate_ in self.DiscountsDueDate:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_format_datetime(DiscountsDueDate_, input_name='DiscountsDueDate'))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PercentDiscount is not None:
            showIndent(outfile, level)
            outfile.write('PercentDiscount=%f,\n' % self.PercentDiscount)
        if self.DiscountAmount is not None:
            showIndent(outfile, level)
            outfile.write('DiscountAmount=model_.DiscountAmount(\n')
            self.DiscountAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DaysDue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DaysDue')
            self.DaysDue.append(ival_)
        elif nodeName_ == 'DiscountsDueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'DiscountsDueDate')
            self.DiscountsDueDate.append(dval_)
        elif nodeName_ == 'PercentDiscount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentDiscount')
            self.PercentDiscount = fval_
        elif nodeName_ == 'DiscountAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DiscountAmount(obj_)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class Discounts


class DocumentDeliveryInformation(GeneratedsSuper):
    """Identifies the party to which the document should be delivered."""
    subclass = None
    superclass = None
    def __init__(self, PartnerInformation=None):
        if PartnerInformation is None:
            self.PartnerInformation = []
        else:
            self.PartnerInformation = PartnerInformation
    def factory(*args_, **kwargs_):
        if DocumentDeliveryInformation.subclass:
            return DocumentDeliveryInformation.subclass(*args_, **kwargs_)
        else:
            return DocumentDeliveryInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def add_PartnerInformation(self, value): self.PartnerInformation.append(value)
    def insert_PartnerInformation(self, index, value): self.PartnerInformation[index] = value
    def hasContent_(self):
        if (
            self.PartnerInformation
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='DocumentDeliveryInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentDeliveryInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='DocumentDeliveryInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='DocumentDeliveryInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PartnerInformation_ in self.PartnerInformation:
            PartnerInformation_.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DocumentDeliveryInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PartnerInformation=[\n')
        level += 1
        for PartnerInformation_ in self.PartnerInformation:
            showIndent(outfile, level)
            outfile.write('model_.PartnerInformation(\n')
            PartnerInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.PartnerInformation.append(obj_)
# end class DocumentDeliveryInformation


class DocumentReference(GeneratedsSuper):
    """Structure which contains information that links this request to a
    reference document, i.e., contract, agreement, etc. Identifies
    what kind of document is being referenced.Identifies what
    "Other" is if chosen from an attribute enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, referenceType=None, definitionOfOther=None, DocumentIdentifier=None, ReferenceItem=None, ReferenceInformation=None, DocumentDate=None):
        self.referenceType = _cast(None, referenceType)
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.DocumentIdentifier = DocumentIdentifier
        self.ReferenceItem = ReferenceItem
        self.ReferenceInformation = ReferenceInformation
        self.DocumentDate = DocumentDate
    def factory(*args_, **kwargs_):
        if DocumentReference.subclass:
            return DocumentReference.subclass(*args_, **kwargs_)
        else:
            return DocumentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentIdentifier(self): return self.DocumentIdentifier
    def set_DocumentIdentifier(self, DocumentIdentifier): self.DocumentIdentifier = DocumentIdentifier
    def get_ReferenceItem(self): return self.ReferenceItem
    def set_ReferenceItem(self, ReferenceItem): self.ReferenceItem = ReferenceItem
    def get_ReferenceInformation(self): return self.ReferenceInformation
    def set_ReferenceInformation(self, ReferenceInformation): self.ReferenceInformation = ReferenceInformation
    def get_DocumentDate(self): return self.DocumentDate
    def set_DocumentDate(self, DocumentDate): self.DocumentDate = DocumentDate
    def get_referenceType(self): return self.referenceType
    def set_referenceType(self, referenceType): self.referenceType = referenceType
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def hasContent_(self):
        if (
            self.DocumentIdentifier is not None or
            self.ReferenceItem is not None or
            self.ReferenceInformation is not None or
            self.DocumentDate is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='DocumentReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='DocumentReference'):
        if self.referenceType is not None and 'referenceType' not in already_processed:
            already_processed.add('referenceType')
            outfile.write(' referenceType=%s' % (quote_attrib(self.referenceType), ))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='DocumentReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDocumentIdentifier>%s</%sDocumentIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.DocumentIdentifier).encode(ExternalEncoding), input_name='DocumentIdentifier'), namespace_, eol_))
        if self.ReferenceItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceItem>%s</%sReferenceItem>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReferenceItem).encode(ExternalEncoding), input_name='ReferenceItem'), namespace_, eol_))
        if self.ReferenceInformation is not None:
            self.ReferenceInformation.export(outfile, level, namespace_, name_='ReferenceInformation', pretty_print=pretty_print)
        if self.DocumentDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDocumentDate>%s</%sDocumentDate>%s' % (namespace_, self.gds_format_datetime(self.DocumentDate, input_name='DocumentDate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DocumentReference'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.referenceType is not None and 'referenceType' not in already_processed:
            already_processed.add('referenceType')
            showIndent(outfile, level)
            outfile.write('referenceType = %s,\n' % (self.referenceType,))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DocumentIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('DocumentIdentifier=%s,\n' % quote_python(self.DocumentIdentifier).encode(ExternalEncoding))
        if self.ReferenceItem is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceItem=%s,\n' % quote_python(self.ReferenceItem).encode(ExternalEncoding))
        if self.ReferenceInformation is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceInformation=model_.ReferenceInformation(\n')
            self.ReferenceInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentDate is not None:
            showIndent(outfile, level)
            outfile.write('DocumentDate=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.DocumentDate, input_name='DocumentDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceType', node)
        if value is not None and 'referenceType' not in already_processed:
            already_processed.add('referenceType')
            self.referenceType = value
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentIdentifier':
            DocumentIdentifier_ = child_.text
            DocumentIdentifier_ = self.gds_validate_string(DocumentIdentifier_, node, 'DocumentIdentifier')
            self.DocumentIdentifier = DocumentIdentifier_
        elif nodeName_ == 'ReferenceItem':
            ReferenceItem_ = child_.text
            ReferenceItem_ = self.gds_validate_string(ReferenceItem_, node, 'ReferenceItem')
            self.ReferenceItem = ReferenceItem_
        elif nodeName_ == 'ReferenceInformation':
            obj_ = ReferenceInformation.factory()
            obj_.build(child_)
            self.set_ReferenceInformation(obj_)
        elif nodeName_ == 'DocumentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'DocumentDate')
            self.DocumentDate = dval_
# end class DocumentReference


class EffectiveDates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FromDate=None, ToDate=None):
        self.FromDate = FromDate
        self.ToDate = ToDate
    def factory(*args_, **kwargs_):
        if EffectiveDates.subclass:
            return EffectiveDates.subclass(*args_, **kwargs_)
        else:
            return EffectiveDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FromDate(self): return self.FromDate
    def set_FromDate(self, FromDate): self.FromDate = FromDate
    def get_ToDate(self): return self.ToDate
    def set_ToDate(self, ToDate): self.ToDate = ToDate
    def hasContent_(self):
        if (
            self.FromDate is not None or
            self.ToDate is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='EffectiveDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EffectiveDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='EffectiveDates'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='EffectiveDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FromDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromDate>%s</%sFromDate>%s' % (namespace_, self.gds_format_date(self.FromDate, input_name='FromDate'), namespace_, eol_))
        if self.ToDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToDate>%s</%sToDate>%s' % (namespace_, self.gds_format_date(self.ToDate, input_name='ToDate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='EffectiveDates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FromDate is not None:
            showIndent(outfile, level)
            outfile.write('FromDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.FromDate, input_name='FromDate'))
        if self.ToDate is not None:
            showIndent(outfile, level)
            outfile.write('ToDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.ToDate, input_name='ToDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FromDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'FromDate')
            self.FromDate = dval_
        elif nodeName_ == 'ToDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'ToDate')
            self.ToDate = dval_
# end class EffectiveDates


class ErrorClassification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalMessageExceptionCode=None):
        self.GlobalMessageExceptionCode = GlobalMessageExceptionCode
    def factory(*args_, **kwargs_):
        if ErrorClassification.subclass:
            return ErrorClassification.subclass(*args_, **kwargs_)
        else:
            return ErrorClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalMessageExceptionCode(self): return self.GlobalMessageExceptionCode
    def set_GlobalMessageExceptionCode(self, GlobalMessageExceptionCode): self.GlobalMessageExceptionCode = GlobalMessageExceptionCode
    def hasContent_(self):
        if (
            self.GlobalMessageExceptionCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ErrorClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorClassification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ErrorClassification'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ErrorClassification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalMessageExceptionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGlobalMessageExceptionCode>%s</%sGlobalMessageExceptionCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.GlobalMessageExceptionCode).encode(ExternalEncoding), input_name='GlobalMessageExceptionCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ErrorClassification'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GlobalMessageExceptionCode is not None:
            showIndent(outfile, level)
            outfile.write('GlobalMessageExceptionCode=%s,\n' % quote_python(self.GlobalMessageExceptionCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalMessageExceptionCode':
            GlobalMessageExceptionCode_ = child_.text
            GlobalMessageExceptionCode_ = self.gds_validate_string(GlobalMessageExceptionCode_, node, 'GlobalMessageExceptionCode')
            self.GlobalMessageExceptionCode = GlobalMessageExceptionCode_
# end class ErrorClassification


class ErrorDescription(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FreeFormText=None):
        self.FreeFormText = FreeFormText
    def factory(*args_, **kwargs_):
        if ErrorDescription.subclass:
            return ErrorDescription.subclass(*args_, **kwargs_)
        else:
            return ErrorDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeFormText(self): return self.FreeFormText
    def set_FreeFormText(self, FreeFormText): self.FreeFormText = FreeFormText
    def hasContent_(self):
        if (
            self.FreeFormText is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ErrorDescription', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorDescription')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ErrorDescription'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ErrorDescription', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreeFormText is not None:
            self.FreeFormText.export(outfile, level, namespace_, name_='FreeFormText', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ErrorDescription'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FreeFormText is not None:
            showIndent(outfile, level)
            outfile.write('FreeFormText=model_.FreeFormText(\n')
            self.FreeFormText.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeFormText':
            obj_ = FreeFormText.factory()
            obj_.build(child_)
            self.set_FreeFormText(obj_)
# end class ErrorDescription


class ExceptionDescription(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ErrorClassification=None, ErrorDescription=None, OffendingMessageComponent=None):
        self.ErrorClassification = ErrorClassification
        self.ErrorDescription = ErrorDescription
        self.OffendingMessageComponent = OffendingMessageComponent
    def factory(*args_, **kwargs_):
        if ExceptionDescription.subclass:
            return ExceptionDescription.subclass(*args_, **kwargs_)
        else:
            return ExceptionDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ErrorClassification(self): return self.ErrorClassification
    def set_ErrorClassification(self, ErrorClassification): self.ErrorClassification = ErrorClassification
    def get_ErrorDescription(self): return self.ErrorDescription
    def set_ErrorDescription(self, ErrorDescription): self.ErrorDescription = ErrorDescription
    def get_OffendingMessageComponent(self): return self.OffendingMessageComponent
    def set_OffendingMessageComponent(self, OffendingMessageComponent): self.OffendingMessageComponent = OffendingMessageComponent
    def hasContent_(self):
        if (
            self.ErrorClassification is not None or
            self.ErrorDescription is not None or
            self.OffendingMessageComponent is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ExceptionDescription', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExceptionDescription')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ExceptionDescription'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ExceptionDescription', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ErrorClassification is not None:
            self.ErrorClassification.export(outfile, level, namespace_, name_='ErrorClassification', pretty_print=pretty_print)
        if self.ErrorDescription is not None:
            self.ErrorDescription.export(outfile, level, namespace_, name_='ErrorDescription', pretty_print=pretty_print)
        if self.OffendingMessageComponent is not None:
            self.OffendingMessageComponent.export(outfile, level, namespace_, name_='OffendingMessageComponent', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExceptionDescription'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ErrorClassification is not None:
            showIndent(outfile, level)
            outfile.write('ErrorClassification=model_.ErrorClassification(\n')
            self.ErrorClassification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ErrorDescription is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDescription=model_.ErrorDescription(\n')
            self.ErrorDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OffendingMessageComponent is not None:
            showIndent(outfile, level)
            outfile.write('OffendingMessageComponent=model_.OffendingMessageComponent(\n')
            self.OffendingMessageComponent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ErrorClassification':
            obj_ = ErrorClassification.factory()
            obj_.build(child_)
            self.set_ErrorClassification(obj_)
        elif nodeName_ == 'ErrorDescription':
            obj_ = ErrorDescription.factory()
            obj_.build(child_)
            self.set_ErrorDescription(obj_)
        elif nodeName_ == 'OffendingMessageComponent':
            obj_ = OffendingMessageComponent.factory()
            obj_.build(child_)
            self.set_OffendingMessageComponent(obj_)
# end class ExceptionDescription


class FieldTicketInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FieldTicketNumber=None, FieldTicketDate=None, RevisionNumber=None):
        self.FieldTicketNumber = FieldTicketNumber
        self.FieldTicketDate = FieldTicketDate
        self.RevisionNumber = RevisionNumber
    def factory(*args_, **kwargs_):
        if FieldTicketInformation.subclass:
            return FieldTicketInformation.subclass(*args_, **kwargs_)
        else:
            return FieldTicketInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FieldTicketNumber(self): return self.FieldTicketNumber
    def set_FieldTicketNumber(self, FieldTicketNumber): self.FieldTicketNumber = FieldTicketNumber
    def get_FieldTicketDate(self): return self.FieldTicketDate
    def set_FieldTicketDate(self, FieldTicketDate): self.FieldTicketDate = FieldTicketDate
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def hasContent_(self):
        if (
            self.FieldTicketNumber is not None or
            self.FieldTicketDate is not None or
            self.RevisionNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FieldTicketInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldTicketInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FieldTicketInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FieldTicketInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FieldTicketNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFieldTicketNumber>%s</%sFieldTicketNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.FieldTicketNumber).encode(ExternalEncoding), input_name='FieldTicketNumber'), namespace_, eol_))
        if self.FieldTicketDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFieldTicketDate>%s</%sFieldTicketDate>%s' % (namespace_, self.gds_format_date(self.FieldTicketDate, input_name='FieldTicketDate'), namespace_, eol_))
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FieldTicketInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FieldTicketNumber is not None:
            showIndent(outfile, level)
            outfile.write('FieldTicketNumber=%s,\n' % quote_python(self.FieldTicketNumber).encode(ExternalEncoding))
        if self.FieldTicketDate is not None:
            showIndent(outfile, level)
            outfile.write('FieldTicketDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.FieldTicketDate, input_name='FieldTicketDate'))
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FieldTicketNumber':
            FieldTicketNumber_ = child_.text
            FieldTicketNumber_ = self.gds_validate_string(FieldTicketNumber_, node, 'FieldTicketNumber')
            self.FieldTicketNumber = FieldTicketNumber_
        elif nodeName_ == 'FieldTicketDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'FieldTicketDate')
            self.FieldTicketDate = dval_
        elif nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
# end class FieldTicketInformation


class FinalDestinationLocationIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifierIndicator=None, valueOf_=None):
        self.identifierIndicator = _cast(None, identifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FinalDestinationLocationIdentifier.subclass:
            return FinalDestinationLocationIdentifier.subclass(*args_, **kwargs_)
        else:
            return FinalDestinationLocationIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifierIndicator(self): return self.identifierIndicator
    def set_identifierIndicator(self, identifierIndicator): self.identifierIndicator = identifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FinalDestinationLocationIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalDestinationLocationIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FinalDestinationLocationIdentifier'):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            outfile.write(' identifierIndicator=%s' % (quote_attrib(self.identifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FinalDestinationLocationIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FinalDestinationLocationIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            showIndent(outfile, level)
            outfile.write('identifierIndicator = %s,\n' % (self.identifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('identifierIndicator', node)
        if value is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            self.identifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FinalDestinationLocationIdentifier


class FinalDestinationLocationInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinalDestinationLocationIdentifier=None, FinalDestinationLocationDescription=None, AddressInformation=None, GeographicalInformation=None):
        if FinalDestinationLocationIdentifier is None:
            self.FinalDestinationLocationIdentifier = []
        else:
            self.FinalDestinationLocationIdentifier = FinalDestinationLocationIdentifier
        self.FinalDestinationLocationDescription = FinalDestinationLocationDescription
        self.AddressInformation = AddressInformation
        self.GeographicalInformation = GeographicalInformation
    def factory(*args_, **kwargs_):
        if FinalDestinationLocationInformation.subclass:
            return FinalDestinationLocationInformation.subclass(*args_, **kwargs_)
        else:
            return FinalDestinationLocationInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinalDestinationLocationIdentifier(self): return self.FinalDestinationLocationIdentifier
    def set_FinalDestinationLocationIdentifier(self, FinalDestinationLocationIdentifier): self.FinalDestinationLocationIdentifier = FinalDestinationLocationIdentifier
    def add_FinalDestinationLocationIdentifier(self, value): self.FinalDestinationLocationIdentifier.append(value)
    def insert_FinalDestinationLocationIdentifier(self, index, value): self.FinalDestinationLocationIdentifier[index] = value
    def get_FinalDestinationLocationDescription(self): return self.FinalDestinationLocationDescription
    def set_FinalDestinationLocationDescription(self, FinalDestinationLocationDescription): self.FinalDestinationLocationDescription = FinalDestinationLocationDescription
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_GeographicalInformation(self): return self.GeographicalInformation
    def set_GeographicalInformation(self, GeographicalInformation): self.GeographicalInformation = GeographicalInformation
    def hasContent_(self):
        if (
            self.FinalDestinationLocationIdentifier or
            self.FinalDestinationLocationDescription is not None or
            self.AddressInformation is not None or
            self.GeographicalInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FinalDestinationLocationInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalDestinationLocationInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FinalDestinationLocationInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FinalDestinationLocationInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FinalDestinationLocationIdentifier_ in self.FinalDestinationLocationIdentifier:
            FinalDestinationLocationIdentifier_.export(outfile, level, namespace_, name_='FinalDestinationLocationIdentifier', pretty_print=pretty_print)
        if self.FinalDestinationLocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFinalDestinationLocationDescription>%s</%sFinalDestinationLocationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.FinalDestinationLocationDescription).encode(ExternalEncoding), input_name='FinalDestinationLocationDescription'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.GeographicalInformation is not None:
            self.GeographicalInformation.export(outfile, level, namespace_, name_='GeographicalInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FinalDestinationLocationInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FinalDestinationLocationIdentifier=[\n')
        level += 1
        for FinalDestinationLocationIdentifier_ in self.FinalDestinationLocationIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.FinalDestinationLocationIdentifier(\n')
            FinalDestinationLocationIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FinalDestinationLocationDescription is not None:
            showIndent(outfile, level)
            outfile.write('FinalDestinationLocationDescription=%s,\n' % quote_python(self.FinalDestinationLocationDescription).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeographicalInformation is not None:
            showIndent(outfile, level)
            outfile.write('GeographicalInformation=model_.GeographicalInformation(\n')
            self.GeographicalInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinalDestinationLocationIdentifier':
            obj_ = FinalDestinationLocationIdentifier.factory()
            obj_.build(child_)
            self.FinalDestinationLocationIdentifier.append(obj_)
        elif nodeName_ == 'FinalDestinationLocationDescription':
            FinalDestinationLocationDescription_ = child_.text
            FinalDestinationLocationDescription_ = self.gds_validate_string(FinalDestinationLocationDescription_, node, 'FinalDestinationLocationDescription')
            self.FinalDestinationLocationDescription = FinalDestinationLocationDescription_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'GeographicalInformation':
            obj_ = GeographicalInformation.factory()
            obj_.build(child_)
            self.set_GeographicalInformation(obj_)
# end class FinalDestinationLocationInformation


class FlashTemperature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Temperature=None, UnitOfMeasureCode=None):
        self.Temperature = Temperature
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if FlashTemperature.subclass:
            return FlashTemperature.subclass(*args_, **kwargs_)
        else:
            return FlashTemperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Temperature is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FlashTemperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlashTemperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FlashTemperature'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FlashTemperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FlashTemperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Temperature is not None:
            showIndent(outfile, level)
            outfile.write('Temperature=model_.Temperature(\n')
            self.Temperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.set_Temperature(obj_)
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class FlashTemperature


class FreeFormText(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None):
        self.language = _cast(None, language)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FreeFormText.subclass:
            return FreeFormText.subclass(*args_, **kwargs_)
        else:
            return FreeFormText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FreeFormText', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeFormText')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FreeFormText'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding), input_name='language'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FreeFormText', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FreeFormText'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            showIndent(outfile, level)
            outfile.write('language = "%s",\n' % (self.language,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FreeFormText


class GaugeReadingMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Measurement=None, UnitOfMeasureCode=None):
        self.Measurement = Measurement
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if GaugeReadingMeasure.subclass:
            return GaugeReadingMeasure.subclass(*args_, **kwargs_)
        else:
            return GaugeReadingMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measurement(self): return self.Measurement
    def set_Measurement(self, Measurement): self.Measurement = Measurement
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Measurement is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='GaugeReadingMeasure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeReadingMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='GaugeReadingMeasure'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='GaugeReadingMeasure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Measurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurement>%s</%sMeasurement>%s' % (namespace_, self.gds_format_float(self.Measurement, input_name='Measurement'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GaugeReadingMeasure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Measurement is not None:
            showIndent(outfile, level)
            outfile.write('Measurement=%f,\n' % self.Measurement)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measurement')
            self.Measurement = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class GaugeReadingMeasure


class GeographicalInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FieldName=None, Section=None, Township=None, Range=None, Region=None, Block=None, GPSCoordinates=None):
        self.FieldName = FieldName
        self.Section = Section
        self.Township = Township
        self.Range = Range
        self.Region = Region
        self.Block = Block
        self.GPSCoordinates = GPSCoordinates
    def factory(*args_, **kwargs_):
        if GeographicalInformation.subclass:
            return GeographicalInformation.subclass(*args_, **kwargs_)
        else:
            return GeographicalInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FieldName(self): return self.FieldName
    def set_FieldName(self, FieldName): self.FieldName = FieldName
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def get_Township(self): return self.Township
    def set_Township(self, Township): self.Township = Township
    def get_Range(self): return self.Range
    def set_Range(self, Range): self.Range = Range
    def get_Region(self): return self.Region
    def set_Region(self, Region): self.Region = Region
    def get_Block(self): return self.Block
    def set_Block(self, Block): self.Block = Block
    def get_GPSCoordinates(self): return self.GPSCoordinates
    def set_GPSCoordinates(self, GPSCoordinates): self.GPSCoordinates = GPSCoordinates
    def hasContent_(self):
        if (
            self.FieldName is not None or
            self.Section is not None or
            self.Township is not None or
            self.Range is not None or
            self.Region is not None or
            self.Block is not None or
            self.GPSCoordinates is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='GeographicalInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeographicalInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='GeographicalInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='GeographicalInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FieldName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFieldName>%s</%sFieldName>%s' % (namespace_, self.gds_format_string(quote_xml(self.FieldName).encode(ExternalEncoding), input_name='FieldName'), namespace_, eol_))
        if self.Section is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSection>%s</%sSection>%s' % (namespace_, self.gds_format_string(quote_xml(self.Section).encode(ExternalEncoding), input_name='Section'), namespace_, eol_))
        if self.Township is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTownship>%s</%sTownship>%s' % (namespace_, self.gds_format_string(quote_xml(self.Township).encode(ExternalEncoding), input_name='Township'), namespace_, eol_))
        if self.Range is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRange>%s</%sRange>%s' % (namespace_, self.gds_format_string(quote_xml(self.Range).encode(ExternalEncoding), input_name='Range'), namespace_, eol_))
        if self.Region is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegion>%s</%sRegion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Region).encode(ExternalEncoding), input_name='Region'), namespace_, eol_))
        if self.Block is not None:
            self.Block.export(outfile, level, namespace_, name_='Block', pretty_print=pretty_print)
        if self.GPSCoordinates is not None:
            self.GPSCoordinates.export(outfile, level, namespace_, name_='GPSCoordinates', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GeographicalInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FieldName is not None:
            showIndent(outfile, level)
            outfile.write('FieldName=%s,\n' % quote_python(self.FieldName).encode(ExternalEncoding))
        if self.Section is not None:
            showIndent(outfile, level)
            outfile.write('Section=%s,\n' % quote_python(self.Section).encode(ExternalEncoding))
        if self.Township is not None:
            showIndent(outfile, level)
            outfile.write('Township=%s,\n' % quote_python(self.Township).encode(ExternalEncoding))
        if self.Range is not None:
            showIndent(outfile, level)
            outfile.write('Range=%s,\n' % quote_python(self.Range).encode(ExternalEncoding))
        if self.Region is not None:
            showIndent(outfile, level)
            outfile.write('Region=%s,\n' % quote_python(self.Region).encode(ExternalEncoding))
        if self.Block is not None:
            showIndent(outfile, level)
            outfile.write('Block=model_.Block(\n')
            self.Block.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GPSCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('GPSCoordinates=model_.GPSCoordinates(\n')
            self.GPSCoordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FieldName':
            FieldName_ = child_.text
            FieldName_ = self.gds_validate_string(FieldName_, node, 'FieldName')
            self.FieldName = FieldName_
        elif nodeName_ == 'Section':
            Section_ = child_.text
            Section_ = self.gds_validate_string(Section_, node, 'Section')
            self.Section = Section_
        elif nodeName_ == 'Township':
            Township_ = child_.text
            Township_ = self.gds_validate_string(Township_, node, 'Township')
            self.Township = Township_
        elif nodeName_ == 'Range':
            Range_ = child_.text
            Range_ = self.gds_validate_string(Range_, node, 'Range')
            self.Range = Range_
        elif nodeName_ == 'Region':
            Region_ = child_.text
            Region_ = self.gds_validate_string(Region_, node, 'Region')
            self.Region = Region_
        elif nodeName_ == 'Block':
            obj_ = Block.factory()
            obj_.build(child_)
            self.set_Block(obj_)
        elif nodeName_ == 'GPSCoordinates':
            obj_ = GPSCoordinates.factory()
            obj_.build(child_)
            self.set_GPSCoordinates(obj_)
# end class GeographicalInformation


class GPSCoordinates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Latitude=None, Longitude=None):
        self.Latitude = Latitude
        self.Longitude = Longitude
    def factory(*args_, **kwargs_):
        if GPSCoordinates.subclass:
            return GPSCoordinates.subclass(*args_, **kwargs_)
        else:
            return GPSCoordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def hasContent_(self):
        if (
            self.Latitude is not None or
            self.Longitude is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='GPSCoordinates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GPSCoordinates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='GPSCoordinates'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='GPSCoordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLatitude>%s</%sLatitude>%s' % (namespace_, self.gds_format_string(quote_xml(self.Latitude).encode(ExternalEncoding), input_name='Latitude'), namespace_, eol_))
        if self.Longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLongitude>%s</%sLongitude>%s' % (namespace_, self.gds_format_string(quote_xml(self.Longitude).encode(ExternalEncoding), input_name='Longitude'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GPSCoordinates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Latitude is not None:
            showIndent(outfile, level)
            outfile.write('Latitude=%s,\n' % quote_python(self.Latitude).encode(ExternalEncoding))
        if self.Longitude is not None:
            showIndent(outfile, level)
            outfile.write('Longitude=%s,\n' % quote_python(self.Longitude).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Latitude':
            Latitude_ = child_.text
            Latitude_ = self.gds_validate_string(Latitude_, node, 'Latitude')
            self.Latitude = Latitude_
        elif nodeName_ == 'Longitude':
            Longitude_ = child_.text
            Longitude_ = self.gds_validate_string(Longitude_, node, 'Longitude')
            self.Longitude = Longitude_
# end class GPSCoordinates


class Gravity(GeneratedsSuper):
    """Specifies the gravity of the product.Specifies the type of gravity."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Gravity.subclass:
            return Gravity.subclass(*args_, **kwargs_)
        else:
            return Gravity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Gravity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Gravity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Gravity'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Gravity', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Gravity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Gravity


class GrossQuantity(GeneratedsSuper):
    """A numeric signed field which represents the gross (metered) quantity
    of product loaded. Since this is a signed field, negative values
    are allowed. Negative values could mean: a cancelled
    transaction, receipt of product into a terminal, etc.This
    represents a combination of the following 2 fields in the PDXB
    v3 record set: 'GrossQuantity' and 'GrossCreditSign'."""
    subclass = None
    superclass = None
    def __init__(self, QuantityUnitOfMeasurement=None, valueOf_=None):
        self.QuantityUnitOfMeasurement = _cast(None, QuantityUnitOfMeasurement)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if GrossQuantity.subclass:
            return GrossQuantity.subclass(*args_, **kwargs_)
        else:
            return GrossQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QuantityUnitOfMeasurement(self): return self.QuantityUnitOfMeasurement
    def set_QuantityUnitOfMeasurement(self, QuantityUnitOfMeasurement): self.QuantityUnitOfMeasurement = QuantityUnitOfMeasurement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='GrossQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GrossQuantity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='GrossQuantity'):
        if self.QuantityUnitOfMeasurement is not None and 'QuantityUnitOfMeasurement' not in already_processed:
            already_processed.add('QuantityUnitOfMeasurement')
            outfile.write(' QuantityUnitOfMeasurement=%s' % (quote_attrib(self.QuantityUnitOfMeasurement), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='GrossQuantity', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='GrossQuantity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.QuantityUnitOfMeasurement is not None and 'QuantityUnitOfMeasurement' not in already_processed:
            already_processed.add('QuantityUnitOfMeasurement')
            showIndent(outfile, level)
            outfile.write('QuantityUnitOfMeasurement = %s,\n' % (self.QuantityUnitOfMeasurement,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('QuantityUnitOfMeasurement', node)
        if value is not None and 'QuantityUnitOfMeasurement' not in already_processed:
            already_processed.add('QuantityUnitOfMeasurement')
            self.QuantityUnitOfMeasurement = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GrossQuantity


class HazardousMaterialClassCode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hazardousMaterialIndicator=None, valueOf_=None):
        self.hazardousMaterialIndicator = _cast(None, hazardousMaterialIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HazardousMaterialClassCode.subclass:
            return HazardousMaterialClassCode.subclass(*args_, **kwargs_)
        else:
            return HazardousMaterialClassCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hazardousMaterialIndicator(self): return self.hazardousMaterialIndicator
    def set_hazardousMaterialIndicator(self, hazardousMaterialIndicator): self.hazardousMaterialIndicator = hazardousMaterialIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='HazardousMaterialClassCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousMaterialClassCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='HazardousMaterialClassCode'):
        if self.hazardousMaterialIndicator is not None and 'hazardousMaterialIndicator' not in already_processed:
            already_processed.add('hazardousMaterialIndicator')
            outfile.write(' hazardousMaterialIndicator=%s' % (self.gds_format_string(quote_attrib(self.hazardousMaterialIndicator).encode(ExternalEncoding), input_name='hazardousMaterialIndicator'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='HazardousMaterialClassCode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='HazardousMaterialClassCode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hazardousMaterialIndicator is not None and 'hazardousMaterialIndicator' not in already_processed:
            already_processed.add('hazardousMaterialIndicator')
            showIndent(outfile, level)
            outfile.write('hazardousMaterialIndicator = "%s",\n' % (self.hazardousMaterialIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hazardousMaterialIndicator', node)
        if value is not None and 'hazardousMaterialIndicator' not in already_processed:
            already_processed.add('hazardousMaterialIndicator')
            self.hazardousMaterialIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HazardousMaterialClassCode


class HazardousMaterials(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialHandlingCode=None, HazardousMaterialDescription=None, HazardousMaterialClassCode=None):
        self.SpecialHandlingCode = SpecialHandlingCode
        self.HazardousMaterialDescription = HazardousMaterialDescription
        if HazardousMaterialClassCode is None:
            self.HazardousMaterialClassCode = []
        else:
            self.HazardousMaterialClassCode = HazardousMaterialClassCode
    def factory(*args_, **kwargs_):
        if HazardousMaterials.subclass:
            return HazardousMaterials.subclass(*args_, **kwargs_)
        else:
            return HazardousMaterials(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialHandlingCode(self): return self.SpecialHandlingCode
    def set_SpecialHandlingCode(self, SpecialHandlingCode): self.SpecialHandlingCode = SpecialHandlingCode
    def get_HazardousMaterialDescription(self): return self.HazardousMaterialDescription
    def set_HazardousMaterialDescription(self, HazardousMaterialDescription): self.HazardousMaterialDescription = HazardousMaterialDescription
    def get_HazardousMaterialClassCode(self): return self.HazardousMaterialClassCode
    def set_HazardousMaterialClassCode(self, HazardousMaterialClassCode): self.HazardousMaterialClassCode = HazardousMaterialClassCode
    def add_HazardousMaterialClassCode(self, value): self.HazardousMaterialClassCode.append(value)
    def insert_HazardousMaterialClassCode(self, index, value): self.HazardousMaterialClassCode[index] = value
    def hasContent_(self):
        if (
            self.SpecialHandlingCode is not None or
            self.HazardousMaterialDescription is not None or
            self.HazardousMaterialClassCode
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='HazardousMaterials', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousMaterials')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='HazardousMaterials'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='HazardousMaterials', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialHandlingCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialHandlingCode>%s</%sSpecialHandlingCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.SpecialHandlingCode).encode(ExternalEncoding), input_name='SpecialHandlingCode'), namespace_, eol_))
        if self.HazardousMaterialDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHazardousMaterialDescription>%s</%sHazardousMaterialDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.HazardousMaterialDescription).encode(ExternalEncoding), input_name='HazardousMaterialDescription'), namespace_, eol_))
        for HazardousMaterialClassCode_ in self.HazardousMaterialClassCode:
            HazardousMaterialClassCode_.export(outfile, level, namespace_, name_='HazardousMaterialClassCode', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HazardousMaterials'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SpecialHandlingCode is not None:
            showIndent(outfile, level)
            outfile.write('SpecialHandlingCode=%s,\n' % quote_python(self.SpecialHandlingCode).encode(ExternalEncoding))
        if self.HazardousMaterialDescription is not None:
            showIndent(outfile, level)
            outfile.write('HazardousMaterialDescription=%s,\n' % quote_python(self.HazardousMaterialDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('HazardousMaterialClassCode=[\n')
        level += 1
        for HazardousMaterialClassCode_ in self.HazardousMaterialClassCode:
            showIndent(outfile, level)
            outfile.write('model_.HazardousMaterialClassCode(\n')
            HazardousMaterialClassCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialHandlingCode':
            SpecialHandlingCode_ = child_.text
            SpecialHandlingCode_ = self.gds_validate_string(SpecialHandlingCode_, node, 'SpecialHandlingCode')
            self.SpecialHandlingCode = SpecialHandlingCode_
        elif nodeName_ == 'HazardousMaterialDescription':
            HazardousMaterialDescription_ = child_.text
            HazardousMaterialDescription_ = self.gds_validate_string(HazardousMaterialDescription_, node, 'HazardousMaterialDescription')
            self.HazardousMaterialDescription = HazardousMaterialDescription_
        elif nodeName_ == 'HazardousMaterialClassCode':
            obj_ = HazardousMaterialClassCode.factory()
            obj_.build(child_)
            self.HazardousMaterialClassCode.append(obj_)
# end class HazardousMaterials


class IntermodalService(GeneratedsSuper):
    """Code indicating the type of intermodal service.Indicates the
    organizational body who assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IntermodalService.subclass:
            return IntermodalService.subclass(*args_, **kwargs_)
        else:
            return IntermodalService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='IntermodalService', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntermodalService')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='IntermodalService'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='IntermodalService', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IntermodalService'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IntermodalService


class Intrastat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommodityCode=None, CommodityDescription=None, TransactionNature=None, SupplementaryUnits=None, CountryOfFinalDestination=None, TransportMethodCode=None):
        self.CommodityCode = CommodityCode
        self.CommodityDescription = CommodityDescription
        self.TransactionNature = TransactionNature
        self.SupplementaryUnits = SupplementaryUnits
        self.CountryOfFinalDestination = CountryOfFinalDestination
        self.TransportMethodCode = TransportMethodCode
    def factory(*args_, **kwargs_):
        if Intrastat.subclass:
            return Intrastat.subclass(*args_, **kwargs_)
        else:
            return Intrastat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommodityCode(self): return self.CommodityCode
    def set_CommodityCode(self, CommodityCode): self.CommodityCode = CommodityCode
    def get_CommodityDescription(self): return self.CommodityDescription
    def set_CommodityDescription(self, CommodityDescription): self.CommodityDescription = CommodityDescription
    def get_TransactionNature(self): return self.TransactionNature
    def set_TransactionNature(self, TransactionNature): self.TransactionNature = TransactionNature
    def get_SupplementaryUnits(self): return self.SupplementaryUnits
    def set_SupplementaryUnits(self, SupplementaryUnits): self.SupplementaryUnits = SupplementaryUnits
    def get_CountryOfFinalDestination(self): return self.CountryOfFinalDestination
    def set_CountryOfFinalDestination(self, CountryOfFinalDestination): self.CountryOfFinalDestination = CountryOfFinalDestination
    def get_TransportMethodCode(self): return self.TransportMethodCode
    def set_TransportMethodCode(self, TransportMethodCode): self.TransportMethodCode = TransportMethodCode
    def hasContent_(self):
        if (
            self.CommodityCode is not None or
            self.CommodityDescription is not None or
            self.TransactionNature is not None or
            self.SupplementaryUnits is not None or
            self.CountryOfFinalDestination is not None or
            self.TransportMethodCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Intrastat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Intrastat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Intrastat'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Intrastat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommodityCode is not None:
            self.CommodityCode.export(outfile, level, namespace_, name_='CommodityCode', pretty_print=pretty_print)
        if self.CommodityDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommodityDescription>%s</%sCommodityDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.CommodityDescription).encode(ExternalEncoding), input_name='CommodityDescription'), namespace_, eol_))
        if self.TransactionNature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransactionNature>%s</%sTransactionNature>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransactionNature).encode(ExternalEncoding), input_name='TransactionNature'), namespace_, eol_))
        if self.SupplementaryUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupplementaryUnits>%s</%sSupplementaryUnits>%s' % (namespace_, self.gds_format_integer(self.SupplementaryUnits, input_name='SupplementaryUnits'), namespace_, eol_))
        if self.CountryOfFinalDestination is not None:
            self.CountryOfFinalDestination.export(outfile, level, namespace_, name_='CountryOfFinalDestination', pretty_print=pretty_print)
        if self.TransportMethodCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportMethodCode>%s</%sTransportMethodCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransportMethodCode).encode(ExternalEncoding), input_name='TransportMethodCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Intrastat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CommodityCode is not None:
            showIndent(outfile, level)
            outfile.write('CommodityCode=model_.CommodityCode(\n')
            self.CommodityCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CommodityDescription is not None:
            showIndent(outfile, level)
            outfile.write('CommodityDescription=%s,\n' % quote_python(self.CommodityDescription).encode(ExternalEncoding))
        if self.TransactionNature is not None:
            showIndent(outfile, level)
            outfile.write('TransactionNature=%s,\n' % quote_python(self.TransactionNature).encode(ExternalEncoding))
        if self.SupplementaryUnits is not None:
            showIndent(outfile, level)
            outfile.write('SupplementaryUnits=%d,\n' % self.SupplementaryUnits)
        if self.CountryOfFinalDestination is not None:
            showIndent(outfile, level)
            outfile.write('CountryOfFinalDestination=model_.CountryOfFinalDestination(\n')
            self.CountryOfFinalDestination.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TransportMethodCode is not None:
            showIndent(outfile, level)
            outfile.write('TransportMethodCode=%s,\n' % quote_python(self.TransportMethodCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommodityCode':
            obj_ = CommodityCode.factory()
            obj_.build(child_)
            self.set_CommodityCode(obj_)
        elif nodeName_ == 'CommodityDescription':
            CommodityDescription_ = child_.text
            CommodityDescription_ = self.gds_validate_string(CommodityDescription_, node, 'CommodityDescription')
            self.CommodityDescription = CommodityDescription_
        elif nodeName_ == 'TransactionNature':
            TransactionNature_ = child_.text
            TransactionNature_ = self.gds_validate_string(TransactionNature_, node, 'TransactionNature')
            self.TransactionNature = TransactionNature_
        elif nodeName_ == 'SupplementaryUnits':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SupplementaryUnits')
            self.SupplementaryUnits = ival_
        elif nodeName_ == 'CountryOfFinalDestination':
            obj_ = CountryOfFinalDestination.factory()
            obj_.build(child_)
            self.set_CountryOfFinalDestination(obj_)
        elif nodeName_ == 'TransportMethodCode':
            TransportMethodCode_ = child_.text
            TransportMethodCode_ = self.gds_validate_string(TransportMethodCode_, node, 'TransportMethodCode')
            self.TransportMethodCode = TransportMethodCode_
# end class Intrastat


class InvoiceInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InvoiceNumber=None, InvoiceDate=None, InvoiceTypeCode=None, RevisionNumber=None):
        self.InvoiceNumber = InvoiceNumber
        self.InvoiceDate = InvoiceDate
        self.InvoiceTypeCode = InvoiceTypeCode
        self.RevisionNumber = RevisionNumber
    def factory(*args_, **kwargs_):
        if InvoiceInformation.subclass:
            return InvoiceInformation.subclass(*args_, **kwargs_)
        else:
            return InvoiceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InvoiceNumber(self): return self.InvoiceNumber
    def set_InvoiceNumber(self, InvoiceNumber): self.InvoiceNumber = InvoiceNumber
    def get_InvoiceDate(self): return self.InvoiceDate
    def set_InvoiceDate(self, InvoiceDate): self.InvoiceDate = InvoiceDate
    def get_InvoiceTypeCode(self): return self.InvoiceTypeCode
    def set_InvoiceTypeCode(self, InvoiceTypeCode): self.InvoiceTypeCode = InvoiceTypeCode
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def hasContent_(self):
        if (
            self.InvoiceNumber is not None or
            self.InvoiceDate is not None or
            self.InvoiceTypeCode is not None or
            self.RevisionNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='InvoiceInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InvoiceInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='InvoiceInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='InvoiceInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InvoiceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInvoiceNumber>%s</%sInvoiceNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.InvoiceNumber).encode(ExternalEncoding), input_name='InvoiceNumber'), namespace_, eol_))
        if self.InvoiceDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInvoiceDate>%s</%sInvoiceDate>%s' % (namespace_, self.gds_format_date(self.InvoiceDate, input_name='InvoiceDate'), namespace_, eol_))
        if self.InvoiceTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInvoiceTypeCode>%s</%sInvoiceTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.InvoiceTypeCode).encode(ExternalEncoding), input_name='InvoiceTypeCode'), namespace_, eol_))
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InvoiceInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.InvoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('InvoiceNumber=%s,\n' % quote_python(self.InvoiceNumber).encode(ExternalEncoding))
        if self.InvoiceDate is not None:
            showIndent(outfile, level)
            outfile.write('InvoiceDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.InvoiceDate, input_name='InvoiceDate'))
        if self.InvoiceTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('InvoiceTypeCode=%s,\n' % quote_python(self.InvoiceTypeCode).encode(ExternalEncoding))
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InvoiceNumber':
            InvoiceNumber_ = child_.text
            InvoiceNumber_ = self.gds_validate_string(InvoiceNumber_, node, 'InvoiceNumber')
            self.InvoiceNumber = InvoiceNumber_
        elif nodeName_ == 'InvoiceDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'InvoiceDate')
            self.InvoiceDate = dval_
        elif nodeName_ == 'InvoiceTypeCode':
            InvoiceTypeCode_ = child_.text
            InvoiceTypeCode_ = self.gds_validate_string(InvoiceTypeCode_, node, 'InvoiceTypeCode')
            self.InvoiceTypeCode = InvoiceTypeCode_
        elif nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
# end class InvoiceInformation


class JobLocationIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, jobLocationIdentifierIndicator=None, valueOf_=None):
        self.jobLocationIdentifierIndicator = _cast(None, jobLocationIdentifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if JobLocationIdentifier.subclass:
            return JobLocationIdentifier.subclass(*args_, **kwargs_)
        else:
            return JobLocationIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_jobLocationIdentifierIndicator(self): return self.jobLocationIdentifierIndicator
    def set_jobLocationIdentifierIndicator(self, jobLocationIdentifierIndicator): self.jobLocationIdentifierIndicator = jobLocationIdentifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='JobLocationIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JobLocationIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='JobLocationIdentifier'):
        if self.jobLocationIdentifierIndicator is not None and 'jobLocationIdentifierIndicator' not in already_processed:
            already_processed.add('jobLocationIdentifierIndicator')
            outfile.write(' jobLocationIdentifierIndicator=%s' % (quote_attrib(self.jobLocationIdentifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='JobLocationIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='JobLocationIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.jobLocationIdentifierIndicator is not None and 'jobLocationIdentifierIndicator' not in already_processed:
            already_processed.add('jobLocationIdentifierIndicator')
            showIndent(outfile, level)
            outfile.write('jobLocationIdentifierIndicator = %s,\n' % (self.jobLocationIdentifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('jobLocationIdentifierIndicator', node)
        if value is not None and 'jobLocationIdentifierIndicator' not in already_processed:
            already_processed.add('jobLocationIdentifierIndicator')
            self.jobLocationIdentifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class JobLocationIdentifier


class JobLocationInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, JobLocationIdentifier=None, JobLocationClassCode=None, JobLocationDescription=None, JobLocationStatus=None, WellInformation=None, JobSiteCategory=None, AddressInformation=None, GeographicalInformation=None):
        if JobLocationIdentifier is None:
            self.JobLocationIdentifier = []
        else:
            self.JobLocationIdentifier = JobLocationIdentifier
        self.JobLocationClassCode = JobLocationClassCode
        self.JobLocationDescription = JobLocationDescription
        self.JobLocationStatus = JobLocationStatus
        self.WellInformation = WellInformation
        self.JobSiteCategory = JobSiteCategory
        self.AddressInformation = AddressInformation
        self.GeographicalInformation = GeographicalInformation
    def factory(*args_, **kwargs_):
        if JobLocationInformation.subclass:
            return JobLocationInformation.subclass(*args_, **kwargs_)
        else:
            return JobLocationInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_JobLocationIdentifier(self): return self.JobLocationIdentifier
    def set_JobLocationIdentifier(self, JobLocationIdentifier): self.JobLocationIdentifier = JobLocationIdentifier
    def add_JobLocationIdentifier(self, value): self.JobLocationIdentifier.append(value)
    def insert_JobLocationIdentifier(self, index, value): self.JobLocationIdentifier[index] = value
    def get_JobLocationClassCode(self): return self.JobLocationClassCode
    def set_JobLocationClassCode(self, JobLocationClassCode): self.JobLocationClassCode = JobLocationClassCode
    def get_JobLocationDescription(self): return self.JobLocationDescription
    def set_JobLocationDescription(self, JobLocationDescription): self.JobLocationDescription = JobLocationDescription
    def get_JobLocationStatus(self): return self.JobLocationStatus
    def set_JobLocationStatus(self, JobLocationStatus): self.JobLocationStatus = JobLocationStatus
    def get_WellInformation(self): return self.WellInformation
    def set_WellInformation(self, WellInformation): self.WellInformation = WellInformation
    def get_JobSiteCategory(self): return self.JobSiteCategory
    def set_JobSiteCategory(self, JobSiteCategory): self.JobSiteCategory = JobSiteCategory
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_GeographicalInformation(self): return self.GeographicalInformation
    def set_GeographicalInformation(self, GeographicalInformation): self.GeographicalInformation = GeographicalInformation
    def hasContent_(self):
        if (
            self.JobLocationIdentifier or
            self.JobLocationClassCode is not None or
            self.JobLocationDescription is not None or
            self.JobLocationStatus is not None or
            self.WellInformation is not None or
            self.JobSiteCategory is not None or
            self.AddressInformation is not None or
            self.GeographicalInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='JobLocationInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JobLocationInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='JobLocationInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='JobLocationInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for JobLocationIdentifier_ in self.JobLocationIdentifier:
            JobLocationIdentifier_.export(outfile, level, namespace_, name_='JobLocationIdentifier', pretty_print=pretty_print)
        if self.JobLocationClassCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobLocationClassCode>%s</%sJobLocationClassCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.JobLocationClassCode).encode(ExternalEncoding), input_name='JobLocationClassCode'), namespace_, eol_))
        if self.JobLocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobLocationDescription>%s</%sJobLocationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.JobLocationDescription).encode(ExternalEncoding), input_name='JobLocationDescription'), namespace_, eol_))
        if self.JobLocationStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobLocationStatus>%s</%sJobLocationStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.JobLocationStatus).encode(ExternalEncoding), input_name='JobLocationStatus'), namespace_, eol_))
        if self.WellInformation is not None:
            self.WellInformation.export(outfile, level, namespace_, name_='WellInformation', pretty_print=pretty_print)
        if self.JobSiteCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobSiteCategory>%s</%sJobSiteCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.JobSiteCategory).encode(ExternalEncoding), input_name='JobSiteCategory'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.GeographicalInformation is not None:
            self.GeographicalInformation.export(outfile, level, namespace_, name_='GeographicalInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='JobLocationInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('JobLocationIdentifier=[\n')
        level += 1
        for JobLocationIdentifier_ in self.JobLocationIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.JobLocationIdentifier(\n')
            JobLocationIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.JobLocationClassCode is not None:
            showIndent(outfile, level)
            outfile.write('JobLocationClassCode=%s,\n' % quote_python(self.JobLocationClassCode).encode(ExternalEncoding))
        if self.JobLocationDescription is not None:
            showIndent(outfile, level)
            outfile.write('JobLocationDescription=%s,\n' % quote_python(self.JobLocationDescription).encode(ExternalEncoding))
        if self.JobLocationStatus is not None:
            showIndent(outfile, level)
            outfile.write('JobLocationStatus=%s,\n' % quote_python(self.JobLocationStatus).encode(ExternalEncoding))
        if self.WellInformation is not None:
            showIndent(outfile, level)
            outfile.write('WellInformation=model_.WellInformation(\n')
            self.WellInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JobSiteCategory is not None:
            showIndent(outfile, level)
            outfile.write('JobSiteCategory=%s,\n' % quote_python(self.JobSiteCategory).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeographicalInformation is not None:
            showIndent(outfile, level)
            outfile.write('GeographicalInformation=model_.GeographicalInformation(\n')
            self.GeographicalInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'JobLocationIdentifier':
            obj_ = JobLocationIdentifier.factory()
            obj_.build(child_)
            self.JobLocationIdentifier.append(obj_)
        elif nodeName_ == 'JobLocationClassCode':
            JobLocationClassCode_ = child_.text
            JobLocationClassCode_ = self.gds_validate_string(JobLocationClassCode_, node, 'JobLocationClassCode')
            self.JobLocationClassCode = JobLocationClassCode_
        elif nodeName_ == 'JobLocationDescription':
            JobLocationDescription_ = child_.text
            JobLocationDescription_ = self.gds_validate_string(JobLocationDescription_, node, 'JobLocationDescription')
            self.JobLocationDescription = JobLocationDescription_
        elif nodeName_ == 'JobLocationStatus':
            JobLocationStatus_ = child_.text
            JobLocationStatus_ = self.gds_validate_string(JobLocationStatus_, node, 'JobLocationStatus')
            self.JobLocationStatus = JobLocationStatus_
        elif nodeName_ == 'WellInformation':
            obj_ = WellInformation.factory()
            obj_.build(child_)
            self.set_WellInformation(obj_)
        elif nodeName_ == 'JobSiteCategory':
            JobSiteCategory_ = child_.text
            JobSiteCategory_ = self.gds_validate_string(JobSiteCategory_, node, 'JobSiteCategory')
            self.JobSiteCategory = JobSiteCategory_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'GeographicalInformation':
            obj_ = GeographicalInformation.factory()
            obj_.build(child_)
            self.set_GeographicalInformation(obj_)
# end class JobLocationInformation


class LetterOfCreditInformation(GeneratedsSuper):
    """Structure holding information describing the details of the letter
    of credit associated with a transaction."""
    subclass = None
    superclass = None
    def __init__(self, DocumentReference=None, AdvisingBank=None, LetterOfCreditAmount=None, PaymentTerms=None, LetterOfCreditQuantity=None, LetterOfCreditVoyageDateTimeRange=None, LetterOfCreditNegotiatedDateTimeRange=None):
        self.DocumentReference = DocumentReference
        self.AdvisingBank = AdvisingBank
        self.LetterOfCreditAmount = LetterOfCreditAmount
        self.PaymentTerms = PaymentTerms
        self.LetterOfCreditQuantity = LetterOfCreditQuantity
        self.LetterOfCreditVoyageDateTimeRange = LetterOfCreditVoyageDateTimeRange
        self.LetterOfCreditNegotiatedDateTimeRange = LetterOfCreditNegotiatedDateTimeRange
    def factory(*args_, **kwargs_):
        if LetterOfCreditInformation.subclass:
            return LetterOfCreditInformation.subclass(*args_, **kwargs_)
        else:
            return LetterOfCreditInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentReference(self): return self.DocumentReference
    def set_DocumentReference(self, DocumentReference): self.DocumentReference = DocumentReference
    def get_AdvisingBank(self): return self.AdvisingBank
    def set_AdvisingBank(self, AdvisingBank): self.AdvisingBank = AdvisingBank
    def get_LetterOfCreditAmount(self): return self.LetterOfCreditAmount
    def set_LetterOfCreditAmount(self, LetterOfCreditAmount): self.LetterOfCreditAmount = LetterOfCreditAmount
    def get_PaymentTerms(self): return self.PaymentTerms
    def set_PaymentTerms(self, PaymentTerms): self.PaymentTerms = PaymentTerms
    def get_LetterOfCreditQuantity(self): return self.LetterOfCreditQuantity
    def set_LetterOfCreditQuantity(self, LetterOfCreditQuantity): self.LetterOfCreditQuantity = LetterOfCreditQuantity
    def get_LetterOfCreditVoyageDateTimeRange(self): return self.LetterOfCreditVoyageDateTimeRange
    def set_LetterOfCreditVoyageDateTimeRange(self, LetterOfCreditVoyageDateTimeRange): self.LetterOfCreditVoyageDateTimeRange = LetterOfCreditVoyageDateTimeRange
    def get_LetterOfCreditNegotiatedDateTimeRange(self): return self.LetterOfCreditNegotiatedDateTimeRange
    def set_LetterOfCreditNegotiatedDateTimeRange(self, LetterOfCreditNegotiatedDateTimeRange): self.LetterOfCreditNegotiatedDateTimeRange = LetterOfCreditNegotiatedDateTimeRange
    def hasContent_(self):
        if (
            self.DocumentReference is not None or
            self.AdvisingBank is not None or
            self.LetterOfCreditAmount is not None or
            self.PaymentTerms is not None or
            self.LetterOfCreditQuantity is not None or
            self.LetterOfCreditVoyageDateTimeRange is not None or
            self.LetterOfCreditNegotiatedDateTimeRange is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LetterOfCreditInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LetterOfCreditInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LetterOfCreditInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LetterOfCreditInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentReference is not None:
            self.DocumentReference.export(outfile, level, namespace_, name_='DocumentReference', pretty_print=pretty_print)
        if self.AdvisingBank is not None:
            self.AdvisingBank.export(outfile, level, namespace_, name_='AdvisingBank', pretty_print=pretty_print)
        if self.LetterOfCreditAmount is not None:
            self.LetterOfCreditAmount.export(outfile, level, namespace_, name_='LetterOfCreditAmount', pretty_print=pretty_print)
        if self.PaymentTerms is not None:
            self.PaymentTerms.export(outfile, level, namespace_, name_='PaymentTerms', pretty_print=pretty_print)
        if self.LetterOfCreditQuantity is not None:
            self.LetterOfCreditQuantity.export(outfile, level, namespace_, name_='LetterOfCreditQuantity', pretty_print=pretty_print)
        if self.LetterOfCreditVoyageDateTimeRange is not None:
            self.LetterOfCreditVoyageDateTimeRange.export(outfile, level, namespace_, name_='LetterOfCreditVoyageDateTimeRange', pretty_print=pretty_print)
        if self.LetterOfCreditNegotiatedDateTimeRange is not None:
            self.LetterOfCreditNegotiatedDateTimeRange.export(outfile, level, namespace_, name_='LetterOfCreditNegotiatedDateTimeRange', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LetterOfCreditInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DocumentReference is not None:
            showIndent(outfile, level)
            outfile.write('DocumentReference=model_.DocumentReference(\n')
            self.DocumentReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AdvisingBank is not None:
            showIndent(outfile, level)
            outfile.write('AdvisingBank=model_.AdvisingBankType(\n')
            self.AdvisingBank.exportLiteral(outfile, level, name_='AdvisingBank')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LetterOfCreditAmount is not None:
            showIndent(outfile, level)
            outfile.write('LetterOfCreditAmount=model_.MonetaryType(\n')
            self.LetterOfCreditAmount.exportLiteral(outfile, level, name_='LetterOfCreditAmount')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PaymentTerms is not None:
            showIndent(outfile, level)
            outfile.write('PaymentTerms=model_.PaymentTerms(\n')
            self.PaymentTerms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LetterOfCreditQuantity is not None:
            showIndent(outfile, level)
            outfile.write('LetterOfCreditQuantity=model_.LetterOfCreditQuantityType(\n')
            self.LetterOfCreditQuantity.exportLiteral(outfile, level, name_='LetterOfCreditQuantity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LetterOfCreditVoyageDateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('LetterOfCreditVoyageDateTimeRange=model_.DateTimeRangeType(\n')
            self.LetterOfCreditVoyageDateTimeRange.exportLiteral(outfile, level, name_='LetterOfCreditVoyageDateTimeRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LetterOfCreditNegotiatedDateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('LetterOfCreditNegotiatedDateTimeRange=model_.DateTimeRangeType(\n')
            self.LetterOfCreditNegotiatedDateTimeRange.exportLiteral(outfile, level, name_='LetterOfCreditNegotiatedDateTimeRange')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentReference':
            obj_ = DocumentReference.factory()
            obj_.build(child_)
            self.set_DocumentReference(obj_)
        elif nodeName_ == 'AdvisingBank':
            obj_ = AdvisingBankType.factory()
            obj_.build(child_)
            self.set_AdvisingBank(obj_)
        elif nodeName_ == 'LetterOfCreditAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_LetterOfCreditAmount(obj_)
        elif nodeName_ == 'PaymentTerms':
            obj_ = PaymentTerms.factory()
            obj_.build(child_)
            self.set_PaymentTerms(obj_)
        elif nodeName_ == 'LetterOfCreditQuantity':
            obj_ = LetterOfCreditQuantityType.factory()
            obj_.build(child_)
            self.set_LetterOfCreditQuantity(obj_)
        elif nodeName_ == 'LetterOfCreditVoyageDateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_LetterOfCreditVoyageDateTimeRange(obj_)
        elif nodeName_ == 'LetterOfCreditNegotiatedDateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_LetterOfCreditNegotiatedDateTimeRange(obj_)
# end class LetterOfCreditInformation


class LineItemAdditive(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdditiveTypeIdentifier=None, Quantity=None, UnitOfMeasureCode=None):
        if AdditiveTypeIdentifier is None:
            self.AdditiveTypeIdentifier = []
        else:
            self.AdditiveTypeIdentifier = AdditiveTypeIdentifier
        self.Quantity = Quantity
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if LineItemAdditive.subclass:
            return LineItemAdditive.subclass(*args_, **kwargs_)
        else:
            return LineItemAdditive(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdditiveTypeIdentifier(self): return self.AdditiveTypeIdentifier
    def set_AdditiveTypeIdentifier(self, AdditiveTypeIdentifier): self.AdditiveTypeIdentifier = AdditiveTypeIdentifier
    def add_AdditiveTypeIdentifier(self, value): self.AdditiveTypeIdentifier.append(value)
    def insert_AdditiveTypeIdentifier(self, index, value): self.AdditiveTypeIdentifier[index] = value
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.AdditiveTypeIdentifier or
            self.Quantity is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LineItemAdditive', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineItemAdditive')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LineItemAdditive'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LineItemAdditive', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AdditiveTypeIdentifier_ in self.AdditiveTypeIdentifier:
            AdditiveTypeIdentifier_.export(outfile, level, namespace_, name_='AdditiveTypeIdentifier', pretty_print=pretty_print)
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuantity>%s</%sQuantity>%s' % (namespace_, self.gds_format_float(self.Quantity, input_name='Quantity'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LineItemAdditive'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AdditiveTypeIdentifier=[\n')
        level += 1
        for AdditiveTypeIdentifier_ in self.AdditiveTypeIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.AdditiveTypeIdentifier(\n')
            AdditiveTypeIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Quantity is not None:
            showIndent(outfile, level)
            outfile.write('Quantity=%f,\n' % self.Quantity)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdditiveTypeIdentifier':
            obj_ = AdditiveTypeIdentifier.factory()
            obj_.build(child_)
            self.AdditiveTypeIdentifier.append(obj_)
        elif nodeName_ == 'Quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Quantity')
            self.Quantity = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class LineItemAdditive


class LineItemIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifierIndicator=None, valueOf_=None):
        self.identifierIndicator = _cast(None, identifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LineItemIdentifier.subclass:
            return LineItemIdentifier.subclass(*args_, **kwargs_)
        else:
            return LineItemIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifierIndicator(self): return self.identifierIndicator
    def set_identifierIndicator(self, identifierIndicator): self.identifierIndicator = identifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LineItemIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineItemIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LineItemIdentifier'):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            outfile.write(' identifierIndicator=%s' % (quote_attrib(self.identifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LineItemIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LineItemIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            showIndent(outfile, level)
            outfile.write('identifierIndicator = %s,\n' % (self.identifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('identifierIndicator', node)
        if value is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            self.identifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LineItemIdentifier


class LineItemInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LineItemIdentifier=None, LineItemName=None, LineItemDescription=None, ManufacturerIdentifier=None):
        if LineItemIdentifier is None:
            self.LineItemIdentifier = []
        else:
            self.LineItemIdentifier = LineItemIdentifier
        self.LineItemName = LineItemName
        self.LineItemDescription = LineItemDescription
        self.ManufacturerIdentifier = ManufacturerIdentifier
    def factory(*args_, **kwargs_):
        if LineItemInformation.subclass:
            return LineItemInformation.subclass(*args_, **kwargs_)
        else:
            return LineItemInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineItemIdentifier(self): return self.LineItemIdentifier
    def set_LineItemIdentifier(self, LineItemIdentifier): self.LineItemIdentifier = LineItemIdentifier
    def add_LineItemIdentifier(self, value): self.LineItemIdentifier.append(value)
    def insert_LineItemIdentifier(self, index, value): self.LineItemIdentifier[index] = value
    def get_LineItemName(self): return self.LineItemName
    def set_LineItemName(self, LineItemName): self.LineItemName = LineItemName
    def get_LineItemDescription(self): return self.LineItemDescription
    def set_LineItemDescription(self, LineItemDescription): self.LineItemDescription = LineItemDescription
    def get_ManufacturerIdentifier(self): return self.ManufacturerIdentifier
    def set_ManufacturerIdentifier(self, ManufacturerIdentifier): self.ManufacturerIdentifier = ManufacturerIdentifier
    def hasContent_(self):
        if (
            self.LineItemIdentifier or
            self.LineItemName is not None or
            self.LineItemDescription is not None or
            self.ManufacturerIdentifier is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LineItemInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineItemInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LineItemInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LineItemInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LineItemIdentifier_ in self.LineItemIdentifier:
            LineItemIdentifier_.export(outfile, level, namespace_, name_='LineItemIdentifier', pretty_print=pretty_print)
        if self.LineItemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemName>%s</%sLineItemName>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemName).encode(ExternalEncoding), input_name='LineItemName'), namespace_, eol_))
        if self.LineItemDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemDescription>%s</%sLineItemDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemDescription).encode(ExternalEncoding), input_name='LineItemDescription'), namespace_, eol_))
        if self.ManufacturerIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturerIdentifier>%s</%sManufacturerIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.ManufacturerIdentifier).encode(ExternalEncoding), input_name='ManufacturerIdentifier'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LineItemInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LineItemIdentifier=[\n')
        level += 1
        for LineItemIdentifier_ in self.LineItemIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.LineItemIdentifier(\n')
            LineItemIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LineItemName is not None:
            showIndent(outfile, level)
            outfile.write('LineItemName=%s,\n' % quote_python(self.LineItemName).encode(ExternalEncoding))
        if self.LineItemDescription is not None:
            showIndent(outfile, level)
            outfile.write('LineItemDescription=%s,\n' % quote_python(self.LineItemDescription).encode(ExternalEncoding))
        if self.ManufacturerIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('ManufacturerIdentifier=%s,\n' % quote_python(self.ManufacturerIdentifier).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineItemIdentifier':
            obj_ = LineItemIdentifier.factory()
            obj_.build(child_)
            self.LineItemIdentifier.append(obj_)
        elif nodeName_ == 'LineItemName':
            LineItemName_ = child_.text
            LineItemName_ = self.gds_validate_string(LineItemName_, node, 'LineItemName')
            self.LineItemName = LineItemName_
        elif nodeName_ == 'LineItemDescription':
            LineItemDescription_ = child_.text
            LineItemDescription_ = self.gds_validate_string(LineItemDescription_, node, 'LineItemDescription')
            self.LineItemDescription = LineItemDescription_
        elif nodeName_ == 'ManufacturerIdentifier':
            ManufacturerIdentifier_ = child_.text
            ManufacturerIdentifier_ = self.gds_validate_string(ManufacturerIdentifier_, node, 'ManufacturerIdentifier')
            self.ManufacturerIdentifier = ManufacturerIdentifier_
# end class LineItemInformation


class LineItemMeasures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SampleMeasures=None, VesselMeasures=None, TankMeasures=None, Meter=None, PartnerDefinedMeasure=None):
        self.SampleMeasures = SampleMeasures
        self.VesselMeasures = VesselMeasures
        self.TankMeasures = TankMeasures
        if Meter is None:
            self.Meter = []
        else:
            self.Meter = Meter
        if PartnerDefinedMeasure is None:
            self.PartnerDefinedMeasure = []
        else:
            self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def factory(*args_, **kwargs_):
        if LineItemMeasures.subclass:
            return LineItemMeasures.subclass(*args_, **kwargs_)
        else:
            return LineItemMeasures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SampleMeasures(self): return self.SampleMeasures
    def set_SampleMeasures(self, SampleMeasures): self.SampleMeasures = SampleMeasures
    def get_VesselMeasures(self): return self.VesselMeasures
    def set_VesselMeasures(self, VesselMeasures): self.VesselMeasures = VesselMeasures
    def get_TankMeasures(self): return self.TankMeasures
    def set_TankMeasures(self, TankMeasures): self.TankMeasures = TankMeasures
    def get_Meter(self): return self.Meter
    def set_Meter(self, Meter): self.Meter = Meter
    def add_Meter(self, value): self.Meter.append(value)
    def insert_Meter(self, index, value): self.Meter[index] = value
    def get_PartnerDefinedMeasure(self): return self.PartnerDefinedMeasure
    def set_PartnerDefinedMeasure(self, PartnerDefinedMeasure): self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def add_PartnerDefinedMeasure(self, value): self.PartnerDefinedMeasure.append(value)
    def insert_PartnerDefinedMeasure(self, index, value): self.PartnerDefinedMeasure[index] = value
    def hasContent_(self):
        if (
            self.SampleMeasures is not None or
            self.VesselMeasures is not None or
            self.TankMeasures is not None or
            self.Meter or
            self.PartnerDefinedMeasure
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LineItemMeasures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineItemMeasures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LineItemMeasures'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LineItemMeasures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SampleMeasures is not None:
            self.SampleMeasures.export(outfile, level, namespace_, name_='SampleMeasures', pretty_print=pretty_print)
        if self.VesselMeasures is not None:
            self.VesselMeasures.export(outfile, level, namespace_, name_='VesselMeasures', pretty_print=pretty_print)
        if self.TankMeasures is not None:
            self.TankMeasures.export(outfile, level, namespace_, name_='TankMeasures', pretty_print=pretty_print)
        for Meter_ in self.Meter:
            Meter_.export(outfile, level, namespace_, name_='Meter', pretty_print=pretty_print)
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            PartnerDefinedMeasure_.export(outfile, level, namespace_, name_='PartnerDefinedMeasure', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LineItemMeasures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SampleMeasures is not None:
            showIndent(outfile, level)
            outfile.write('SampleMeasures=model_.SampleMeasures(\n')
            self.SampleMeasures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VesselMeasures is not None:
            showIndent(outfile, level)
            outfile.write('VesselMeasures=model_.VesselMeasures(\n')
            self.VesselMeasures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankMeasures is not None:
            showIndent(outfile, level)
            outfile.write('TankMeasures=model_.TankMeasures(\n')
            self.TankMeasures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Meter=[\n')
        level += 1
        for Meter_ in self.Meter:
            showIndent(outfile, level)
            outfile.write('model_.Meter(\n')
            Meter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PartnerDefinedMeasure=[\n')
        level += 1
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            showIndent(outfile, level)
            outfile.write('model_.PartnerDefinedMeasure(\n')
            PartnerDefinedMeasure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SampleMeasures':
            obj_ = SampleMeasures.factory()
            obj_.build(child_)
            self.set_SampleMeasures(obj_)
        elif nodeName_ == 'VesselMeasures':
            obj_ = VesselMeasures.factory()
            obj_.build(child_)
            self.set_VesselMeasures(obj_)
        elif nodeName_ == 'TankMeasures':
            obj_ = TankMeasures.factory()
            obj_.build(child_)
            self.set_TankMeasures(obj_)
        elif nodeName_ == 'Meter':
            obj_ = Meter.factory()
            obj_.build(child_)
            self.Meter.append(obj_)
        elif nodeName_ == 'PartnerDefinedMeasure':
            obj_ = PartnerDefinedMeasure.factory()
            obj_.build(child_)
            self.PartnerDefinedMeasure.append(obj_)
# end class LineItemMeasures


class LineItemPurposeCode(GeneratedsSuper):
    """The purpose in the message for a given line item.Indicates the
    organizational body who assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LineItemPurposeCode.subclass:
            return LineItemPurposeCode.subclass(*args_, **kwargs_)
        else:
            return LineItemPurposeCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LineItemPurposeCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineItemPurposeCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LineItemPurposeCode'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LineItemPurposeCode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LineItemPurposeCode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LineItemPurposeCode


class Location(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locationIndicator=None, LocationIdentifier=None, LocationName=None, AddressInformation=None, GeographicalInformation=None, LocationDescription=None):
        self.locationIndicator = _cast(None, locationIndicator)
        self.LocationIdentifier = LocationIdentifier
        self.LocationName = LocationName
        self.AddressInformation = AddressInformation
        self.GeographicalInformation = GeographicalInformation
        self.LocationDescription = LocationDescription
    def factory(*args_, **kwargs_):
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocationIdentifier(self): return self.LocationIdentifier
    def set_LocationIdentifier(self, LocationIdentifier): self.LocationIdentifier = LocationIdentifier
    def get_LocationName(self): return self.LocationName
    def set_LocationName(self, LocationName): self.LocationName = LocationName
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_GeographicalInformation(self): return self.GeographicalInformation
    def set_GeographicalInformation(self, GeographicalInformation): self.GeographicalInformation = GeographicalInformation
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_locationIndicator(self): return self.locationIndicator
    def set_locationIndicator(self, locationIndicator): self.locationIndicator = locationIndicator
    def hasContent_(self):
        if (
            self.LocationIdentifier is not None or
            self.LocationName is not None or
            self.AddressInformation is not None or
            self.GeographicalInformation is not None or
            self.LocationDescription is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Location', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Location'):
        if self.locationIndicator is not None and 'locationIndicator' not in already_processed:
            already_processed.add('locationIndicator')
            outfile.write(' locationIndicator=%s' % (quote_attrib(self.locationIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocationIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationIdentifier>%s</%sLocationIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationIdentifier).encode(ExternalEncoding), input_name='LocationIdentifier'), namespace_, eol_))
        if self.LocationName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationName>%s</%sLocationName>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationName).encode(ExternalEncoding), input_name='LocationName'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.GeographicalInformation is not None:
            self.GeographicalInformation.export(outfile, level, namespace_, name_='GeographicalInformation', pretty_print=pretty_print)
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationDescription>%s</%sLocationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationDescription).encode(ExternalEncoding), input_name='LocationDescription'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Location'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locationIndicator is not None and 'locationIndicator' not in already_processed:
            already_processed.add('locationIndicator')
            showIndent(outfile, level)
            outfile.write('locationIndicator = %s,\n' % (self.locationIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LocationIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('LocationIdentifier=%s,\n' % quote_python(self.LocationIdentifier).encode(ExternalEncoding))
        if self.LocationName is not None:
            showIndent(outfile, level)
            outfile.write('LocationName=%s,\n' % quote_python(self.LocationName).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeographicalInformation is not None:
            showIndent(outfile, level)
            outfile.write('GeographicalInformation=model_.GeographicalInformation(\n')
            self.GeographicalInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocationDescription is not None:
            showIndent(outfile, level)
            outfile.write('LocationDescription=%s,\n' % quote_python(self.LocationDescription).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locationIndicator', node)
        if value is not None and 'locationIndicator' not in already_processed:
            already_processed.add('locationIndicator')
            self.locationIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocationIdentifier':
            LocationIdentifier_ = child_.text
            LocationIdentifier_ = self.gds_validate_string(LocationIdentifier_, node, 'LocationIdentifier')
            self.LocationIdentifier = LocationIdentifier_
        elif nodeName_ == 'LocationName':
            LocationName_ = child_.text
            LocationName_ = self.gds_validate_string(LocationName_, node, 'LocationName')
            self.LocationName = LocationName_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'GeographicalInformation':
            obj_ = GeographicalInformation.factory()
            obj_.build(child_)
            self.set_GeographicalInformation(obj_)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
# end class Location


class LocationCode(GeneratedsSuper):
    """A unique code identifying the location.Indicates the organizational
    body who assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LocationCode.subclass:
            return LocationCode.subclass(*args_, **kwargs_)
        else:
            return LocationCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LocationCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LocationCode'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LocationCode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LocationCode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocationCode


class LoadTenderInformation(GeneratedsSuper):
    """Structure containing information about the load tender."""
    subclass = None
    superclass = None
    def __init__(self, LoadTenderIdentifier=None, LoadTenderIssuedDateTime=None):
        self.LoadTenderIdentifier = LoadTenderIdentifier
        self.LoadTenderIssuedDateTime = LoadTenderIssuedDateTime
    def factory(*args_, **kwargs_):
        if LoadTenderInformation.subclass:
            return LoadTenderInformation.subclass(*args_, **kwargs_)
        else:
            return LoadTenderInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LoadTenderIdentifier(self): return self.LoadTenderIdentifier
    def set_LoadTenderIdentifier(self, LoadTenderIdentifier): self.LoadTenderIdentifier = LoadTenderIdentifier
    def get_LoadTenderIssuedDateTime(self): return self.LoadTenderIssuedDateTime
    def set_LoadTenderIssuedDateTime(self, LoadTenderIssuedDateTime): self.LoadTenderIssuedDateTime = LoadTenderIssuedDateTime
    def hasContent_(self):
        if (
            self.LoadTenderIdentifier is not None or
            self.LoadTenderIssuedDateTime is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LoadTenderInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadTenderInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LoadTenderInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LoadTenderInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LoadTenderIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoadTenderIdentifier>%s</%sLoadTenderIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.LoadTenderIdentifier).encode(ExternalEncoding), input_name='LoadTenderIdentifier'), namespace_, eol_))
        if self.LoadTenderIssuedDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoadTenderIssuedDateTime>%s</%sLoadTenderIssuedDateTime>%s' % (namespace_, self.gds_format_datetime(self.LoadTenderIssuedDateTime, input_name='LoadTenderIssuedDateTime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LoadTenderInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LoadTenderIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('LoadTenderIdentifier=%s,\n' % quote_python(self.LoadTenderIdentifier).encode(ExternalEncoding))
        if self.LoadTenderIssuedDateTime is not None:
            showIndent(outfile, level)
            outfile.write('LoadTenderIssuedDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.LoadTenderIssuedDateTime, input_name='LoadTenderIssuedDateTime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LoadTenderIdentifier':
            LoadTenderIdentifier_ = child_.text
            LoadTenderIdentifier_ = self.gds_validate_string(LoadTenderIdentifier_, node, 'LoadTenderIdentifier')
            self.LoadTenderIdentifier = LoadTenderIdentifier_
        elif nodeName_ == 'LoadTenderIssuedDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'LoadTenderIssuedDateTime')
            self.LoadTenderIssuedDateTime = dval_
# end class LoadTenderInformation


class ManufacturingIdentificationDetails(GeneratedsSuper):
    """Structure containing information relative to the manufacture of
    lading."""
    subclass = None
    superclass = None
    def __init__(self, ManufacturingIdentificationTypeCode=None, ManufacturingIdentifier=None, ParentManufacturingIdentifier=None):
        self.ManufacturingIdentificationTypeCode = ManufacturingIdentificationTypeCode
        self.ManufacturingIdentifier = ManufacturingIdentifier
        self.ParentManufacturingIdentifier = ParentManufacturingIdentifier
    def factory(*args_, **kwargs_):
        if ManufacturingIdentificationDetails.subclass:
            return ManufacturingIdentificationDetails.subclass(*args_, **kwargs_)
        else:
            return ManufacturingIdentificationDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ManufacturingIdentificationTypeCode(self): return self.ManufacturingIdentificationTypeCode
    def set_ManufacturingIdentificationTypeCode(self, ManufacturingIdentificationTypeCode): self.ManufacturingIdentificationTypeCode = ManufacturingIdentificationTypeCode
    def get_ManufacturingIdentifier(self): return self.ManufacturingIdentifier
    def set_ManufacturingIdentifier(self, ManufacturingIdentifier): self.ManufacturingIdentifier = ManufacturingIdentifier
    def get_ParentManufacturingIdentifier(self): return self.ParentManufacturingIdentifier
    def set_ParentManufacturingIdentifier(self, ParentManufacturingIdentifier): self.ParentManufacturingIdentifier = ParentManufacturingIdentifier
    def hasContent_(self):
        if (
            self.ManufacturingIdentificationTypeCode is not None or
            self.ManufacturingIdentifier is not None or
            self.ParentManufacturingIdentifier is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ManufacturingIdentificationDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ManufacturingIdentificationDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ManufacturingIdentificationDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ManufacturingIdentificationDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ManufacturingIdentificationTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturingIdentificationTypeCode>%s</%sManufacturingIdentificationTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ManufacturingIdentificationTypeCode).encode(ExternalEncoding), input_name='ManufacturingIdentificationTypeCode'), namespace_, eol_))
        if self.ManufacturingIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturingIdentifier>%s</%sManufacturingIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.ManufacturingIdentifier).encode(ExternalEncoding), input_name='ManufacturingIdentifier'), namespace_, eol_))
        if self.ParentManufacturingIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParentManufacturingIdentifier>%s</%sParentManufacturingIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.ParentManufacturingIdentifier).encode(ExternalEncoding), input_name='ParentManufacturingIdentifier'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ManufacturingIdentificationDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ManufacturingIdentificationTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('ManufacturingIdentificationTypeCode=%s,\n' % quote_python(self.ManufacturingIdentificationTypeCode).encode(ExternalEncoding))
        if self.ManufacturingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('ManufacturingIdentifier=%s,\n' % quote_python(self.ManufacturingIdentifier).encode(ExternalEncoding))
        if self.ParentManufacturingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('ParentManufacturingIdentifier=%s,\n' % quote_python(self.ParentManufacturingIdentifier).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ManufacturingIdentificationTypeCode':
            ManufacturingIdentificationTypeCode_ = child_.text
            ManufacturingIdentificationTypeCode_ = self.gds_validate_string(ManufacturingIdentificationTypeCode_, node, 'ManufacturingIdentificationTypeCode')
            self.ManufacturingIdentificationTypeCode = ManufacturingIdentificationTypeCode_
        elif nodeName_ == 'ManufacturingIdentifier':
            ManufacturingIdentifier_ = child_.text
            ManufacturingIdentifier_ = self.gds_validate_string(ManufacturingIdentifier_, node, 'ManufacturingIdentifier')
            self.ManufacturingIdentifier = ManufacturingIdentifier_
        elif nodeName_ == 'ParentManufacturingIdentifier':
            ParentManufacturingIdentifier_ = child_.text
            ParentManufacturingIdentifier_ = self.gds_validate_string(ParentManufacturingIdentifier_, node, 'ParentManufacturingIdentifier')
            self.ParentManufacturingIdentifier = ParentManufacturingIdentifier_
# end class ManufacturingIdentificationDetails


class ModeOfTransportation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TransportMethodCode=None, TransportEvent=None, TransportContainer=None, HazardousMaterials=None):
        self.TransportMethodCode = TransportMethodCode
        self.TransportEvent = TransportEvent
        self.TransportContainer = TransportContainer
        self.HazardousMaterials = HazardousMaterials
    def factory(*args_, **kwargs_):
        if ModeOfTransportation.subclass:
            return ModeOfTransportation.subclass(*args_, **kwargs_)
        else:
            return ModeOfTransportation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TransportMethodCode(self): return self.TransportMethodCode
    def set_TransportMethodCode(self, TransportMethodCode): self.TransportMethodCode = TransportMethodCode
    def get_TransportEvent(self): return self.TransportEvent
    def set_TransportEvent(self, TransportEvent): self.TransportEvent = TransportEvent
    def get_TransportContainer(self): return self.TransportContainer
    def set_TransportContainer(self, TransportContainer): self.TransportContainer = TransportContainer
    def get_HazardousMaterials(self): return self.HazardousMaterials
    def set_HazardousMaterials(self, HazardousMaterials): self.HazardousMaterials = HazardousMaterials
    def hasContent_(self):
        if (
            self.TransportMethodCode is not None or
            self.TransportEvent is not None or
            self.TransportContainer is not None or
            self.HazardousMaterials is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ModeOfTransportation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModeOfTransportation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ModeOfTransportation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ModeOfTransportation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TransportMethodCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportMethodCode>%s</%sTransportMethodCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransportMethodCode).encode(ExternalEncoding), input_name='TransportMethodCode'), namespace_, eol_))
        if self.TransportEvent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportEvent>%s</%sTransportEvent>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransportEvent).encode(ExternalEncoding), input_name='TransportEvent'), namespace_, eol_))
        if self.TransportContainer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportContainer>%s</%sTransportContainer>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransportContainer).encode(ExternalEncoding), input_name='TransportContainer'), namespace_, eol_))
        if self.HazardousMaterials is not None:
            self.HazardousMaterials.export(outfile, level, namespace_, name_='HazardousMaterials', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ModeOfTransportation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TransportMethodCode is not None:
            showIndent(outfile, level)
            outfile.write('TransportMethodCode=%s,\n' % quote_python(self.TransportMethodCode).encode(ExternalEncoding))
        if self.TransportEvent is not None:
            showIndent(outfile, level)
            outfile.write('TransportEvent=%s,\n' % quote_python(self.TransportEvent).encode(ExternalEncoding))
        if self.TransportContainer is not None:
            showIndent(outfile, level)
            outfile.write('TransportContainer=%s,\n' % quote_python(self.TransportContainer).encode(ExternalEncoding))
        if self.HazardousMaterials is not None:
            showIndent(outfile, level)
            outfile.write('HazardousMaterials=model_.HazardousMaterials(\n')
            self.HazardousMaterials.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TransportMethodCode':
            TransportMethodCode_ = child_.text
            TransportMethodCode_ = self.gds_validate_string(TransportMethodCode_, node, 'TransportMethodCode')
            self.TransportMethodCode = TransportMethodCode_
        elif nodeName_ == 'TransportEvent':
            TransportEvent_ = child_.text
            TransportEvent_ = self.gds_validate_string(TransportEvent_, node, 'TransportEvent')
            self.TransportEvent = TransportEvent_
        elif nodeName_ == 'TransportContainer':
            TransportContainer_ = child_.text
            TransportContainer_ = self.gds_validate_string(TransportContainer_, node, 'TransportContainer')
            self.TransportContainer = TransportContainer_
        elif nodeName_ == 'HazardousMaterials':
            obj_ = HazardousMaterials.factory()
            obj_.build(child_)
            self.set_HazardousMaterials(obj_)
# end class ModeOfTransportation


class MeasurementRange(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MinimumMeasurement=None, MaximumMeasurement=None):
        self.MinimumMeasurement = MinimumMeasurement
        self.MaximumMeasurement = MaximumMeasurement
    def factory(*args_, **kwargs_):
        if MeasurementRange.subclass:
            return MeasurementRange.subclass(*args_, **kwargs_)
        else:
            return MeasurementRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MinimumMeasurement(self): return self.MinimumMeasurement
    def set_MinimumMeasurement(self, MinimumMeasurement): self.MinimumMeasurement = MinimumMeasurement
    def get_MaximumMeasurement(self): return self.MaximumMeasurement
    def set_MaximumMeasurement(self, MaximumMeasurement): self.MaximumMeasurement = MaximumMeasurement
    def hasContent_(self):
        if (
            self.MinimumMeasurement is not None or
            self.MaximumMeasurement is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='MeasurementRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasurementRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='MeasurementRange'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='MeasurementRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MinimumMeasurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinimumMeasurement>%s</%sMinimumMeasurement>%s' % (namespace_, self.gds_format_float(self.MinimumMeasurement, input_name='MinimumMeasurement'), namespace_, eol_))
        if self.MaximumMeasurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaximumMeasurement>%s</%sMaximumMeasurement>%s' % (namespace_, self.gds_format_float(self.MaximumMeasurement, input_name='MaximumMeasurement'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MeasurementRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MinimumMeasurement is not None:
            showIndent(outfile, level)
            outfile.write('MinimumMeasurement=%f,\n' % self.MinimumMeasurement)
        if self.MaximumMeasurement is not None:
            showIndent(outfile, level)
            outfile.write('MaximumMeasurement=%f,\n' % self.MaximumMeasurement)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MinimumMeasurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MinimumMeasurement')
            self.MinimumMeasurement = fval_
        elif nodeName_ == 'MaximumMeasurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaximumMeasurement')
            self.MaximumMeasurement = fval_
# end class MeasurementRange


class Meter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeterNumber=None, OpenReading=None, CloseReading=None, MeterQuantity=None, MeterFactor=None, MeterDistributionPercent=None, ProverReport=None):
        self.MeterNumber = MeterNumber
        self.OpenReading = OpenReading
        self.CloseReading = CloseReading
        self.MeterQuantity = MeterQuantity
        self.MeterFactor = MeterFactor
        self.MeterDistributionPercent = MeterDistributionPercent
        self.ProverReport = ProverReport
    def factory(*args_, **kwargs_):
        if Meter.subclass:
            return Meter.subclass(*args_, **kwargs_)
        else:
            return Meter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeterNumber(self): return self.MeterNumber
    def set_MeterNumber(self, MeterNumber): self.MeterNumber = MeterNumber
    def get_OpenReading(self): return self.OpenReading
    def set_OpenReading(self, OpenReading): self.OpenReading = OpenReading
    def get_CloseReading(self): return self.CloseReading
    def set_CloseReading(self, CloseReading): self.CloseReading = CloseReading
    def get_MeterQuantity(self): return self.MeterQuantity
    def set_MeterQuantity(self, MeterQuantity): self.MeterQuantity = MeterQuantity
    def get_MeterFactor(self): return self.MeterFactor
    def set_MeterFactor(self, MeterFactor): self.MeterFactor = MeterFactor
    def get_MeterDistributionPercent(self): return self.MeterDistributionPercent
    def set_MeterDistributionPercent(self, MeterDistributionPercent): self.MeterDistributionPercent = MeterDistributionPercent
    def get_ProverReport(self): return self.ProverReport
    def set_ProverReport(self, ProverReport): self.ProverReport = ProverReport
    def hasContent_(self):
        if (
            self.MeterNumber is not None or
            self.OpenReading is not None or
            self.CloseReading is not None or
            self.MeterQuantity is not None or
            self.MeterFactor is not None or
            self.MeterDistributionPercent is not None or
            self.ProverReport is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Meter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Meter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Meter'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Meter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeterNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeterNumber>%s</%sMeterNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.MeterNumber).encode(ExternalEncoding), input_name='MeterNumber'), namespace_, eol_))
        if self.OpenReading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOpenReading>%s</%sOpenReading>%s' % (namespace_, self.gds_format_float(self.OpenReading, input_name='OpenReading'), namespace_, eol_))
        if self.CloseReading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloseReading>%s</%sCloseReading>%s' % (namespace_, self.gds_format_float(self.CloseReading, input_name='CloseReading'), namespace_, eol_))
        if self.MeterQuantity is not None:
            self.MeterQuantity.export(outfile, level, namespace_, name_='MeterQuantity', pretty_print=pretty_print)
        if self.MeterFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeterFactor>%s</%sMeterFactor>%s' % (namespace_, self.gds_format_float(self.MeterFactor, input_name='MeterFactor'), namespace_, eol_))
        if self.MeterDistributionPercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeterDistributionPercent>%s</%sMeterDistributionPercent>%s' % (namespace_, self.gds_format_float(self.MeterDistributionPercent, input_name='MeterDistributionPercent'), namespace_, eol_))
        if self.ProverReport is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProverReport>%s</%sProverReport>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProverReport).encode(ExternalEncoding), input_name='ProverReport'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Meter'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MeterNumber is not None:
            showIndent(outfile, level)
            outfile.write('MeterNumber=%s,\n' % quote_python(self.MeterNumber).encode(ExternalEncoding))
        if self.OpenReading is not None:
            showIndent(outfile, level)
            outfile.write('OpenReading=%f,\n' % self.OpenReading)
        if self.CloseReading is not None:
            showIndent(outfile, level)
            outfile.write('CloseReading=%f,\n' % self.CloseReading)
        if self.MeterQuantity is not None:
            showIndent(outfile, level)
            outfile.write('MeterQuantity=model_.MeterQuantity(\n')
            self.MeterQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MeterFactor is not None:
            showIndent(outfile, level)
            outfile.write('MeterFactor=%f,\n' % self.MeterFactor)
        if self.MeterDistributionPercent is not None:
            showIndent(outfile, level)
            outfile.write('MeterDistributionPercent=%f,\n' % self.MeterDistributionPercent)
        if self.ProverReport is not None:
            showIndent(outfile, level)
            outfile.write('ProverReport=%s,\n' % quote_python(self.ProverReport).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeterNumber':
            MeterNumber_ = child_.text
            MeterNumber_ = self.gds_validate_string(MeterNumber_, node, 'MeterNumber')
            self.MeterNumber = MeterNumber_
        elif nodeName_ == 'OpenReading':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'OpenReading')
            self.OpenReading = fval_
        elif nodeName_ == 'CloseReading':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CloseReading')
            self.CloseReading = fval_
        elif nodeName_ == 'MeterQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_MeterQuantity(obj_)
        elif nodeName_ == 'MeterFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MeterFactor')
            self.MeterFactor = fval_
        elif nodeName_ == 'MeterDistributionPercent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MeterDistributionPercent')
            self.MeterDistributionPercent = fval_
        elif nodeName_ == 'ProverReport':
            ProverReport_ = child_.text
            ProverReport_ = self.gds_validate_string(ProverReport_, node, 'ProverReport')
            self.ProverReport = ProverReport_
# end class Meter


class NetQuantity(GeneratedsSuper):
    """A numeric signed field which represents the net (metered) quantity
    of product loaded. Since this is a signed field, negative values
    are allowed. Negative values could mean: a cancelled
    transaction, receipt of product into a terminal, etc.This
    represents a combination of the following 2 fields in the PDXB
    v3 record set: 'Net Quantity or Temperature / Gravity' (field
    38) and 'NetCreditSign'."""
    subclass = None
    superclass = None
    def __init__(self, QuantityUnitOfMeasurement=None, valueOf_=None):
        self.QuantityUnitOfMeasurement = _cast(None, QuantityUnitOfMeasurement)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NetQuantity.subclass:
            return NetQuantity.subclass(*args_, **kwargs_)
        else:
            return NetQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QuantityUnitOfMeasurement(self): return self.QuantityUnitOfMeasurement
    def set_QuantityUnitOfMeasurement(self, QuantityUnitOfMeasurement): self.QuantityUnitOfMeasurement = QuantityUnitOfMeasurement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='NetQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetQuantity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='NetQuantity'):
        if self.QuantityUnitOfMeasurement is not None and 'QuantityUnitOfMeasurement' not in already_processed:
            already_processed.add('QuantityUnitOfMeasurement')
            outfile.write(' QuantityUnitOfMeasurement=%s' % (quote_attrib(self.QuantityUnitOfMeasurement), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='NetQuantity', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='NetQuantity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.QuantityUnitOfMeasurement is not None and 'QuantityUnitOfMeasurement' not in already_processed:
            already_processed.add('QuantityUnitOfMeasurement')
            showIndent(outfile, level)
            outfile.write('QuantityUnitOfMeasurement = %s,\n' % (self.QuantityUnitOfMeasurement,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('QuantityUnitOfMeasurement', node)
        if value is not None and 'QuantityUnitOfMeasurement' not in already_processed:
            already_processed.add('QuantityUnitOfMeasurement')
            self.QuantityUnitOfMeasurement = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NetQuantity


class ObservedTemperature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Temperature=None, UnitOfMeasureCode=None):
        self.Temperature = Temperature
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if ObservedTemperature.subclass:
            return ObservedTemperature.subclass(*args_, **kwargs_)
        else:
            return ObservedTemperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Temperature is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ObservedTemperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservedTemperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ObservedTemperature'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ObservedTemperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ObservedTemperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Temperature is not None:
            showIndent(outfile, level)
            outfile.write('Temperature=model_.Temperature(\n')
            self.Temperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.set_Temperature(obj_)
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class ObservedTemperature


class OffendingMessageComponent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalMessageComponentCode=None):
        self.GlobalMessageComponentCode = GlobalMessageComponentCode
    def factory(*args_, **kwargs_):
        if OffendingMessageComponent.subclass:
            return OffendingMessageComponent.subclass(*args_, **kwargs_)
        else:
            return OffendingMessageComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalMessageComponentCode(self): return self.GlobalMessageComponentCode
    def set_GlobalMessageComponentCode(self, GlobalMessageComponentCode): self.GlobalMessageComponentCode = GlobalMessageComponentCode
    def hasContent_(self):
        if (
            self.GlobalMessageComponentCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OffendingMessageComponent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffendingMessageComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OffendingMessageComponent'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OffendingMessageComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalMessageComponentCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGlobalMessageComponentCode>%s</%sGlobalMessageComponentCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.GlobalMessageComponentCode).encode(ExternalEncoding), input_name='GlobalMessageComponentCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OffendingMessageComponent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GlobalMessageComponentCode is not None:
            showIndent(outfile, level)
            outfile.write('GlobalMessageComponentCode=%s,\n' % quote_python(self.GlobalMessageComponentCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalMessageComponentCode':
            GlobalMessageComponentCode_ = child_.text
            GlobalMessageComponentCode_ = self.gds_validate_string(GlobalMessageComponentCode_, node, 'GlobalMessageComponentCode')
            self.GlobalMessageComponentCode = GlobalMessageComponentCode_
# end class OffendingMessageComponent


class OriginLocationIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifierIndicator=None, valueOf_=None):
        self.identifierIndicator = _cast(None, identifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OriginLocationIdentifier.subclass:
            return OriginLocationIdentifier.subclass(*args_, **kwargs_)
        else:
            return OriginLocationIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifierIndicator(self): return self.identifierIndicator
    def set_identifierIndicator(self, identifierIndicator): self.identifierIndicator = identifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OriginLocationIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginLocationIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OriginLocationIdentifier'):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            outfile.write(' identifierIndicator=%s' % (quote_attrib(self.identifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OriginLocationIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='OriginLocationIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.identifierIndicator is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            showIndent(outfile, level)
            outfile.write('identifierIndicator = %s,\n' % (self.identifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('identifierIndicator', node)
        if value is not None and 'identifierIndicator' not in already_processed:
            already_processed.add('identifierIndicator')
            self.identifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OriginLocationIdentifier


class OriginLocationInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OriginLocationIdentifier=None, OriginLocationDescription=None, AddressInformation=None, GeographicalInformation=None):
        if OriginLocationIdentifier is None:
            self.OriginLocationIdentifier = []
        else:
            self.OriginLocationIdentifier = OriginLocationIdentifier
        self.OriginLocationDescription = OriginLocationDescription
        self.AddressInformation = AddressInformation
        self.GeographicalInformation = GeographicalInformation
    def factory(*args_, **kwargs_):
        if OriginLocationInformation.subclass:
            return OriginLocationInformation.subclass(*args_, **kwargs_)
        else:
            return OriginLocationInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginLocationIdentifier(self): return self.OriginLocationIdentifier
    def set_OriginLocationIdentifier(self, OriginLocationIdentifier): self.OriginLocationIdentifier = OriginLocationIdentifier
    def add_OriginLocationIdentifier(self, value): self.OriginLocationIdentifier.append(value)
    def insert_OriginLocationIdentifier(self, index, value): self.OriginLocationIdentifier[index] = value
    def get_OriginLocationDescription(self): return self.OriginLocationDescription
    def set_OriginLocationDescription(self, OriginLocationDescription): self.OriginLocationDescription = OriginLocationDescription
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_GeographicalInformation(self): return self.GeographicalInformation
    def set_GeographicalInformation(self, GeographicalInformation): self.GeographicalInformation = GeographicalInformation
    def hasContent_(self):
        if (
            self.OriginLocationIdentifier or
            self.OriginLocationDescription is not None or
            self.AddressInformation is not None or
            self.GeographicalInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OriginLocationInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginLocationInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OriginLocationInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OriginLocationInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OriginLocationIdentifier_ in self.OriginLocationIdentifier:
            OriginLocationIdentifier_.export(outfile, level, namespace_, name_='OriginLocationIdentifier', pretty_print=pretty_print)
        if self.OriginLocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginLocationDescription>%s</%sOriginLocationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.OriginLocationDescription).encode(ExternalEncoding), input_name='OriginLocationDescription'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        if self.GeographicalInformation is not None:
            self.GeographicalInformation.export(outfile, level, namespace_, name_='GeographicalInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OriginLocationInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OriginLocationIdentifier=[\n')
        level += 1
        for OriginLocationIdentifier_ in self.OriginLocationIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.OriginLocationIdentifier(\n')
            OriginLocationIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.OriginLocationDescription is not None:
            showIndent(outfile, level)
            outfile.write('OriginLocationDescription=%s,\n' % quote_python(self.OriginLocationDescription).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeographicalInformation is not None:
            showIndent(outfile, level)
            outfile.write('GeographicalInformation=model_.GeographicalInformation(\n')
            self.GeographicalInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OriginLocationIdentifier':
            obj_ = OriginLocationIdentifier.factory()
            obj_.build(child_)
            self.OriginLocationIdentifier.append(obj_)
        elif nodeName_ == 'OriginLocationDescription':
            OriginLocationDescription_ = child_.text
            OriginLocationDescription_ = self.gds_validate_string(OriginLocationDescription_, node, 'OriginLocationDescription')
            self.OriginLocationDescription = OriginLocationDescription_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'GeographicalInformation':
            obj_ = GeographicalInformation.factory()
            obj_.build(child_)
            self.set_GeographicalInformation(obj_)
# end class OriginLocationInformation


class PackageDetail(GeneratedsSuper):
    """Structure containing information on the Packaging of the lading."""
    subclass = None
    superclass = None
    def __init__(self, LineItemNumber=None, ProductInformation=None, PackageType=None, PackageLevel=None, PackagingQuantity=None, ShippingLabelNumber=None, PackageWeight=None, SubUnitCount=None):
        self.LineItemNumber = LineItemNumber
        self.ProductInformation = ProductInformation
        self.PackageType = PackageType
        self.PackageLevel = PackageLevel
        self.PackagingQuantity = PackagingQuantity
        self.ShippingLabelNumber = ShippingLabelNumber
        self.PackageWeight = PackageWeight
        self.SubUnitCount = SubUnitCount
    def factory(*args_, **kwargs_):
        if PackageDetail.subclass:
            return PackageDetail.subclass(*args_, **kwargs_)
        else:
            return PackageDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineItemNumber(self): return self.LineItemNumber
    def set_LineItemNumber(self, LineItemNumber): self.LineItemNumber = LineItemNumber
    def get_ProductInformation(self): return self.ProductInformation
    def set_ProductInformation(self, ProductInformation): self.ProductInformation = ProductInformation
    def get_PackageType(self): return self.PackageType
    def set_PackageType(self, PackageType): self.PackageType = PackageType
    def get_PackageLevel(self): return self.PackageLevel
    def set_PackageLevel(self, PackageLevel): self.PackageLevel = PackageLevel
    def get_PackagingQuantity(self): return self.PackagingQuantity
    def set_PackagingQuantity(self, PackagingQuantity): self.PackagingQuantity = PackagingQuantity
    def get_ShippingLabelNumber(self): return self.ShippingLabelNumber
    def set_ShippingLabelNumber(self, ShippingLabelNumber): self.ShippingLabelNumber = ShippingLabelNumber
    def get_PackageWeight(self): return self.PackageWeight
    def set_PackageWeight(self, PackageWeight): self.PackageWeight = PackageWeight
    def get_SubUnitCount(self): return self.SubUnitCount
    def set_SubUnitCount(self, SubUnitCount): self.SubUnitCount = SubUnitCount
    def hasContent_(self):
        if (
            self.LineItemNumber is not None or
            self.ProductInformation is not None or
            self.PackageType is not None or
            self.PackageLevel is not None or
            self.PackagingQuantity is not None or
            self.ShippingLabelNumber is not None or
            self.PackageWeight is not None or
            self.SubUnitCount is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PackageDetail', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PackageDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PackageDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LineItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemNumber>%s</%sLineItemNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemNumber).encode(ExternalEncoding), input_name='LineItemNumber'), namespace_, eol_))
        if self.ProductInformation is not None:
            self.ProductInformation.export(outfile, level, namespace_, name_='ProductInformation', pretty_print=pretty_print)
        if self.PackageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPackageType>%s</%sPackageType>%s' % (namespace_, self.gds_format_string(quote_xml(self.PackageType).encode(ExternalEncoding), input_name='PackageType'), namespace_, eol_))
        if self.PackageLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPackageLevel>%s</%sPackageLevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.PackageLevel).encode(ExternalEncoding), input_name='PackageLevel'), namespace_, eol_))
        if self.PackagingQuantity is not None:
            self.PackagingQuantity.export(outfile, level, namespace_, name_='PackagingQuantity', pretty_print=pretty_print)
        if self.ShippingLabelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShippingLabelNumber>%s</%sShippingLabelNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.ShippingLabelNumber).encode(ExternalEncoding), input_name='ShippingLabelNumber'), namespace_, eol_))
        if self.PackageWeight is not None:
            self.PackageWeight.export(outfile, level, namespace_, name_='PackageWeight', pretty_print=pretty_print)
        if self.SubUnitCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubUnitCount>%s</%sSubUnitCount>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubUnitCount).encode(ExternalEncoding), input_name='SubUnitCount'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PackageDetail'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LineItemNumber is not None:
            showIndent(outfile, level)
            outfile.write('LineItemNumber=%s,\n' % quote_python(self.LineItemNumber).encode(ExternalEncoding))
        if self.ProductInformation is not None:
            showIndent(outfile, level)
            outfile.write('ProductInformation=model_.ProductInformation(\n')
            self.ProductInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PackageType is not None:
            showIndent(outfile, level)
            outfile.write('PackageType=%s,\n' % quote_python(self.PackageType).encode(ExternalEncoding))
        if self.PackageLevel is not None:
            showIndent(outfile, level)
            outfile.write('PackageLevel=%s,\n' % quote_python(self.PackageLevel).encode(ExternalEncoding))
        if self.PackagingQuantity is not None:
            showIndent(outfile, level)
            outfile.write('PackagingQuantity=model_.PackagingQuantity(\n')
            self.PackagingQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShippingLabelNumber is not None:
            showIndent(outfile, level)
            outfile.write('ShippingLabelNumber=%s,\n' % quote_python(self.ShippingLabelNumber).encode(ExternalEncoding))
        if self.PackageWeight is not None:
            showIndent(outfile, level)
            outfile.write('PackageWeight=model_.PackageWeight(\n')
            self.PackageWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubUnitCount is not None:
            showIndent(outfile, level)
            outfile.write('SubUnitCount=%s,\n' % quote_python(self.SubUnitCount).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineItemNumber':
            LineItemNumber_ = child_.text
            LineItemNumber_ = self.gds_validate_string(LineItemNumber_, node, 'LineItemNumber')
            self.LineItemNumber = LineItemNumber_
        elif nodeName_ == 'ProductInformation':
            obj_ = ProductInformation.factory()
            obj_.build(child_)
            self.set_ProductInformation(obj_)
        elif nodeName_ == 'PackageType':
            PackageType_ = child_.text
            PackageType_ = self.gds_validate_string(PackageType_, node, 'PackageType')
            self.PackageType = PackageType_
        elif nodeName_ == 'PackageLevel':
            PackageLevel_ = child_.text
            PackageLevel_ = self.gds_validate_string(PackageLevel_, node, 'PackageLevel')
            self.PackageLevel = PackageLevel_
        elif nodeName_ == 'PackagingQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PackagingQuantity(obj_)
        elif nodeName_ == 'ShippingLabelNumber':
            ShippingLabelNumber_ = child_.text
            ShippingLabelNumber_ = self.gds_validate_string(ShippingLabelNumber_, node, 'ShippingLabelNumber')
            self.ShippingLabelNumber = ShippingLabelNumber_
        elif nodeName_ == 'PackageWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PackageWeight(obj_)
        elif nodeName_ == 'SubUnitCount':
            SubUnitCount_ = child_.text
            SubUnitCount_ = self.gds_validate_string(SubUnitCount_, node, 'SubUnitCount')
            self.SubUnitCount = SubUnitCount_
# end class PackageDetail


class PackagingInformation(GeneratedsSuper):
    """Information about the type of packaging available as part of the
    product. This is generally viewed as one of the features of the
    product as opposed to "package" which is what is actually done
    as the time of shipping to prepare and send product(s) on
    carriers. Allows recursive access to subpackaging information."""
    subclass = None
    superclass = None
    def __init__(self, ProductInformation=None, PackagingQuantity=None, PackageType=None, PackageWeight=None, PackagingLabel=None, SpecialInstructions=None):
        self.ProductInformation = ProductInformation
        self.PackagingQuantity = PackagingQuantity
        self.PackageType = PackageType
        self.PackageWeight = PackageWeight
        self.PackagingLabel = PackagingLabel
        if SpecialInstructions is None:
            self.SpecialInstructions = []
        else:
            self.SpecialInstructions = SpecialInstructions
    def factory(*args_, **kwargs_):
        if PackagingInformation.subclass:
            return PackagingInformation.subclass(*args_, **kwargs_)
        else:
            return PackagingInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductInformation(self): return self.ProductInformation
    def set_ProductInformation(self, ProductInformation): self.ProductInformation = ProductInformation
    def get_PackagingQuantity(self): return self.PackagingQuantity
    def set_PackagingQuantity(self, PackagingQuantity): self.PackagingQuantity = PackagingQuantity
    def get_PackageType(self): return self.PackageType
    def set_PackageType(self, PackageType): self.PackageType = PackageType
    def get_PackageWeight(self): return self.PackageWeight
    def set_PackageWeight(self, PackageWeight): self.PackageWeight = PackageWeight
    def get_PackagingLabel(self): return self.PackagingLabel
    def set_PackagingLabel(self, PackagingLabel): self.PackagingLabel = PackagingLabel
    def get_SpecialInstructions(self): return self.SpecialInstructions
    def set_SpecialInstructions(self, SpecialInstructions): self.SpecialInstructions = SpecialInstructions
    def add_SpecialInstructions(self, value): self.SpecialInstructions.append(value)
    def insert_SpecialInstructions(self, index, value): self.SpecialInstructions[index] = value
    def hasContent_(self):
        if (
            self.ProductInformation is not None or
            self.PackagingQuantity is not None or
            self.PackageType is not None or
            self.PackageWeight is not None or
            self.PackagingLabel is not None or
            self.SpecialInstructions
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PackagingInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackagingInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PackagingInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PackagingInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProductInformation is not None:
            self.ProductInformation.export(outfile, level, namespace_, name_='ProductInformation', pretty_print=pretty_print)
        if self.PackagingQuantity is not None:
            self.PackagingQuantity.export(outfile, level, namespace_, name_='PackagingQuantity', pretty_print=pretty_print)
        if self.PackageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPackageType>%s</%sPackageType>%s' % (namespace_, self.gds_format_string(quote_xml(self.PackageType).encode(ExternalEncoding), input_name='PackageType'), namespace_, eol_))
        if self.PackageWeight is not None:
            self.PackageWeight.export(outfile, level, namespace_, name_='PackageWeight', pretty_print=pretty_print)
        if self.PackagingLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPackagingLabel>%s</%sPackagingLabel>%s' % (namespace_, self.gds_format_string(quote_xml(self.PackagingLabel).encode(ExternalEncoding), input_name='PackagingLabel'), namespace_, eol_))
        for SpecialInstructions_ in self.SpecialInstructions:
            SpecialInstructions_.export(outfile, level, namespace_, name_='SpecialInstructions', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PackagingInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProductInformation is not None:
            showIndent(outfile, level)
            outfile.write('ProductInformation=model_.ProductInformation(\n')
            self.ProductInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PackagingQuantity is not None:
            showIndent(outfile, level)
            outfile.write('PackagingQuantity=model_.PackagingQuantity(\n')
            self.PackagingQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PackageType is not None:
            showIndent(outfile, level)
            outfile.write('PackageType=%s,\n' % quote_python(self.PackageType).encode(ExternalEncoding))
        if self.PackageWeight is not None:
            showIndent(outfile, level)
            outfile.write('PackageWeight=model_.PackageWeight(\n')
            self.PackageWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PackagingLabel is not None:
            showIndent(outfile, level)
            outfile.write('PackagingLabel=%s,\n' % quote_python(self.PackagingLabel).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SpecialInstructions=[\n')
        level += 1
        for SpecialInstructions_ in self.SpecialInstructions:
            showIndent(outfile, level)
            outfile.write('model_.SpecialInstructions(\n')
            SpecialInstructions_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProductInformation':
            obj_ = ProductInformation.factory()
            obj_.build(child_)
            self.set_ProductInformation(obj_)
        elif nodeName_ == 'PackagingQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PackagingQuantity(obj_)
        elif nodeName_ == 'PackageType':
            PackageType_ = child_.text
            PackageType_ = self.gds_validate_string(PackageType_, node, 'PackageType')
            self.PackageType = PackageType_
        elif nodeName_ == 'PackageWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PackageWeight(obj_)
        elif nodeName_ == 'PackagingLabel':
            PackagingLabel_ = child_.text
            PackagingLabel_ = self.gds_validate_string(PackagingLabel_, node, 'PackagingLabel')
            self.PackagingLabel = PackagingLabel_
        elif nodeName_ == 'SpecialInstructions':
            obj_ = SpecialInstructions.factory()
            obj_.build(child_)
            self.SpecialInstructions.append(obj_)
# end class PackagingInformation


class PartnerDefinedMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartnerDefinedMeasureDescription=None, PartnerDefinedMeasureIdentifier=None, Measurement=None, UnitOfMeasureCode=None):
        self.PartnerDefinedMeasureDescription = PartnerDefinedMeasureDescription
        self.PartnerDefinedMeasureIdentifier = PartnerDefinedMeasureIdentifier
        self.Measurement = Measurement
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if PartnerDefinedMeasure.subclass:
            return PartnerDefinedMeasure.subclass(*args_, **kwargs_)
        else:
            return PartnerDefinedMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerDefinedMeasureDescription(self): return self.PartnerDefinedMeasureDescription
    def set_PartnerDefinedMeasureDescription(self, PartnerDefinedMeasureDescription): self.PartnerDefinedMeasureDescription = PartnerDefinedMeasureDescription
    def get_PartnerDefinedMeasureIdentifier(self): return self.PartnerDefinedMeasureIdentifier
    def set_PartnerDefinedMeasureIdentifier(self, PartnerDefinedMeasureIdentifier): self.PartnerDefinedMeasureIdentifier = PartnerDefinedMeasureIdentifier
    def get_Measurement(self): return self.Measurement
    def set_Measurement(self, Measurement): self.Measurement = Measurement
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.PartnerDefinedMeasureDescription is not None or
            self.PartnerDefinedMeasureIdentifier is not None or
            self.Measurement is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PartnerDefinedMeasure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerDefinedMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PartnerDefinedMeasure'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PartnerDefinedMeasure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartnerDefinedMeasureDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartnerDefinedMeasureDescription>%s</%sPartnerDefinedMeasureDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.PartnerDefinedMeasureDescription).encode(ExternalEncoding), input_name='PartnerDefinedMeasureDescription'), namespace_, eol_))
        if self.PartnerDefinedMeasureIdentifier is not None:
            self.PartnerDefinedMeasureIdentifier.export(outfile, level, namespace_, name_='PartnerDefinedMeasureIdentifier', pretty_print=pretty_print)
        if self.Measurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurement>%s</%sMeasurement>%s' % (namespace_, self.gds_format_float(self.Measurement, input_name='Measurement'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PartnerDefinedMeasure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PartnerDefinedMeasureDescription is not None:
            showIndent(outfile, level)
            outfile.write('PartnerDefinedMeasureDescription=%s,\n' % quote_python(self.PartnerDefinedMeasureDescription).encode(ExternalEncoding))
        if self.PartnerDefinedMeasureIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('PartnerDefinedMeasureIdentifier=model_.PartnerDefinedMeasureIdentifier(\n')
            self.PartnerDefinedMeasureIdentifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Measurement is not None:
            showIndent(outfile, level)
            outfile.write('Measurement=%f,\n' % self.Measurement)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerDefinedMeasureDescription':
            PartnerDefinedMeasureDescription_ = child_.text
            PartnerDefinedMeasureDescription_ = self.gds_validate_string(PartnerDefinedMeasureDescription_, node, 'PartnerDefinedMeasureDescription')
            self.PartnerDefinedMeasureDescription = PartnerDefinedMeasureDescription_
        elif nodeName_ == 'PartnerDefinedMeasureIdentifier':
            obj_ = PartnerDefinedMeasureIdentifier.factory()
            obj_.build(child_)
            self.set_PartnerDefinedMeasureIdentifier(obj_)
        elif nodeName_ == 'Measurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measurement')
            self.Measurement = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class PartnerDefinedMeasure


class PartnerDefinedMeasureIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partnerDefinedMeasureIdentifierIndicator=None, valueOf_=None):
        self.partnerDefinedMeasureIdentifierIndicator = _cast(None, partnerDefinedMeasureIdentifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PartnerDefinedMeasureIdentifier.subclass:
            return PartnerDefinedMeasureIdentifier.subclass(*args_, **kwargs_)
        else:
            return PartnerDefinedMeasureIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partnerDefinedMeasureIdentifierIndicator(self): return self.partnerDefinedMeasureIdentifierIndicator
    def set_partnerDefinedMeasureIdentifierIndicator(self, partnerDefinedMeasureIdentifierIndicator): self.partnerDefinedMeasureIdentifierIndicator = partnerDefinedMeasureIdentifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PartnerDefinedMeasureIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerDefinedMeasureIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PartnerDefinedMeasureIdentifier'):
        if self.partnerDefinedMeasureIdentifierIndicator is not None and 'partnerDefinedMeasureIdentifierIndicator' not in already_processed:
            already_processed.add('partnerDefinedMeasureIdentifierIndicator')
            outfile.write(' partnerDefinedMeasureIdentifierIndicator=%s' % (quote_attrib(self.partnerDefinedMeasureIdentifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PartnerDefinedMeasureIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PartnerDefinedMeasureIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.partnerDefinedMeasureIdentifierIndicator is not None and 'partnerDefinedMeasureIdentifierIndicator' not in already_processed:
            already_processed.add('partnerDefinedMeasureIdentifierIndicator')
            showIndent(outfile, level)
            outfile.write('partnerDefinedMeasureIdentifierIndicator = %s,\n' % (self.partnerDefinedMeasureIdentifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partnerDefinedMeasureIdentifierIndicator', node)
        if value is not None and 'partnerDefinedMeasureIdentifierIndicator' not in already_processed:
            already_processed.add('partnerDefinedMeasureIdentifierIndicator')
            self.partnerDefinedMeasureIdentifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartnerDefinedMeasureIdentifier


class PartnerIdentifier(GeneratedsSuper):
    """A unique businesss identifer, possibly DUNS Number.Identifies what
    "Other" is if chosen from an attribute enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, definitionOfOther=None, partnerIdentifierIndicator=None, valueOf_=None):
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.partnerIdentifierIndicator = _cast(None, partnerIdentifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PartnerIdentifier.subclass:
            return PartnerIdentifier.subclass(*args_, **kwargs_)
        else:
            return PartnerIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_partnerIdentifierIndicator(self): return self.partnerIdentifierIndicator
    def set_partnerIdentifierIndicator(self, partnerIdentifierIndicator): self.partnerIdentifierIndicator = partnerIdentifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PartnerIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PartnerIdentifier'):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
        if self.partnerIdentifierIndicator is not None and 'partnerIdentifierIndicator' not in already_processed:
            already_processed.add('partnerIdentifierIndicator')
            outfile.write(' partnerIdentifierIndicator=%s' % (quote_attrib(self.partnerIdentifierIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PartnerIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PartnerIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
        if self.partnerIdentifierIndicator is not None and 'partnerIdentifierIndicator' not in already_processed:
            already_processed.add('partnerIdentifierIndicator')
            showIndent(outfile, level)
            outfile.write('partnerIdentifierIndicator = %s,\n' % (self.partnerIdentifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
        value = find_attr_value_('partnerIdentifierIndicator', node)
        if value is not None and 'partnerIdentifierIndicator' not in already_processed:
            already_processed.add('partnerIdentifierIndicator')
            self.partnerIdentifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartnerIdentifier


class PartnerInformation(GeneratedsSuper):
    """Structure which contains the information necessary to describe a
    business partner.Identifies what "Other" is if chosen from an
    attribute enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, partnerRoleIndicator=None, definitionOfOther=None, PartnerIdentifier=None, PartnerName=None, AddressInformation=None, ContactInformation=None, TaxInformation=None, URL=None, AccountInformation=None):
        self.partnerRoleIndicator = _cast(None, partnerRoleIndicator)
        self.definitionOfOther = _cast(None, definitionOfOther)
        if PartnerIdentifier is None:
            self.PartnerIdentifier = []
        else:
            self.PartnerIdentifier = PartnerIdentifier
        self.PartnerName = PartnerName
        self.AddressInformation = AddressInformation
        if ContactInformation is None:
            self.ContactInformation = []
        else:
            self.ContactInformation = ContactInformation
        if TaxInformation is None:
            self.TaxInformation = []
        else:
            self.TaxInformation = TaxInformation
        self.URL = URL
        self.AccountInformation = AccountInformation
    def factory(*args_, **kwargs_):
        if PartnerInformation.subclass:
            return PartnerInformation.subclass(*args_, **kwargs_)
        else:
            return PartnerInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerIdentifier(self): return self.PartnerIdentifier
    def set_PartnerIdentifier(self, PartnerIdentifier): self.PartnerIdentifier = PartnerIdentifier
    def add_PartnerIdentifier(self, value): self.PartnerIdentifier.append(value)
    def insert_PartnerIdentifier(self, index, value): self.PartnerIdentifier[index] = value
    def get_PartnerName(self): return self.PartnerName
    def set_PartnerName(self, PartnerName): self.PartnerName = PartnerName
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_ContactInformation(self): return self.ContactInformation
    def set_ContactInformation(self, ContactInformation): self.ContactInformation = ContactInformation
    def add_ContactInformation(self, value): self.ContactInformation.append(value)
    def insert_ContactInformation(self, index, value): self.ContactInformation[index] = value
    def get_TaxInformation(self): return self.TaxInformation
    def set_TaxInformation(self, TaxInformation): self.TaxInformation = TaxInformation
    def add_TaxInformation(self, value): self.TaxInformation.append(value)
    def insert_TaxInformation(self, index, value): self.TaxInformation[index] = value
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_AccountInformation(self): return self.AccountInformation
    def set_AccountInformation(self, AccountInformation): self.AccountInformation = AccountInformation
    def get_partnerRoleIndicator(self): return self.partnerRoleIndicator
    def set_partnerRoleIndicator(self, partnerRoleIndicator): self.partnerRoleIndicator = partnerRoleIndicator
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def hasContent_(self):
        if (
            self.PartnerIdentifier or
            self.PartnerName is not None or
            self.AddressInformation is not None or
            self.ContactInformation or
            self.TaxInformation or
            self.URL is not None or
            self.AccountInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PartnerInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PartnerInformation'):
        if self.partnerRoleIndicator is not None and 'partnerRoleIndicator' not in already_processed:
            already_processed.add('partnerRoleIndicator')
            outfile.write(' partnerRoleIndicator=%s' % (quote_attrib(self.partnerRoleIndicator), ))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PartnerInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PartnerIdentifier_ in self.PartnerIdentifier:
            PartnerIdentifier_.export(outfile, level, namespace_, name_='PartnerIdentifier', pretty_print=pretty_print)
        if self.PartnerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartnerName>%s</%sPartnerName>%s' % (namespace_, self.gds_format_string(quote_xml(self.PartnerName).encode(ExternalEncoding), input_name='PartnerName'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
        for ContactInformation_ in self.ContactInformation:
            ContactInformation_.export(outfile, level, namespace_, name_='ContactInformation', pretty_print=pretty_print)
        for TaxInformation_ in self.TaxInformation:
            TaxInformation_.export(outfile, level, namespace_, name_='TaxInformation', pretty_print=pretty_print)
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
        if self.AccountInformation is not None:
            self.AccountInformation.export(outfile, level, namespace_, name_='AccountInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PartnerInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.partnerRoleIndicator is not None and 'partnerRoleIndicator' not in already_processed:
            already_processed.add('partnerRoleIndicator')
            showIndent(outfile, level)
            outfile.write('partnerRoleIndicator = %s,\n' % (self.partnerRoleIndicator,))
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PartnerIdentifier=[\n')
        level += 1
        for PartnerIdentifier_ in self.PartnerIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.PartnerIdentifier(\n')
            PartnerIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PartnerName is not None:
            showIndent(outfile, level)
            outfile.write('PartnerName=%s,\n' % quote_python(self.PartnerName).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ContactInformation=[\n')
        level += 1
        for ContactInformation_ in self.ContactInformation:
            showIndent(outfile, level)
            outfile.write('model_.ContactInformation(\n')
            ContactInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TaxInformation=[\n')
        level += 1
        for TaxInformation_ in self.TaxInformation:
            showIndent(outfile, level)
            outfile.write('model_.TaxInformation(\n')
            TaxInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.AccountInformation is not None:
            showIndent(outfile, level)
            outfile.write('AccountInformation=model_.AccountInformation(\n')
            self.AccountInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partnerRoleIndicator', node)
        if value is not None and 'partnerRoleIndicator' not in already_processed:
            already_processed.add('partnerRoleIndicator')
            self.partnerRoleIndicator = value
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerIdentifier':
            obj_ = PartnerIdentifier.factory()
            obj_.build(child_)
            self.PartnerIdentifier.append(obj_)
        elif nodeName_ == 'PartnerName':
            PartnerName_ = child_.text
            PartnerName_ = self.gds_validate_string(PartnerName_, node, 'PartnerName')
            self.PartnerName = PartnerName_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
        elif nodeName_ == 'ContactInformation':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.ContactInformation.append(obj_)
        elif nodeName_ == 'TaxInformation':
            obj_ = TaxInformation.factory()
            obj_.build(child_)
            self.TaxInformation.append(obj_)
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'AccountInformation':
            obj_ = AccountInformation.factory()
            obj_.build(child_)
            self.set_AccountInformation(obj_)
# end class PartnerInformation


class PaymentTerms(GeneratedsSuper):
    """Structure containing information on the terms for monetary
    settlement for a sale."""
    subclass = None
    superclass = None
    def __init__(self, PaymentTermsOfSale=None, Description=None, PaymentTermsBasisDateCode=None, PaymentTermsBasisDate=None, TermsNetDays=None, PercentOfInvoicePayable=None, Discounts=None, Deferred=None, Penalty=None):
        self.PaymentTermsOfSale = PaymentTermsOfSale
        self.Description = Description
        self.PaymentTermsBasisDateCode = PaymentTermsBasisDateCode
        self.PaymentTermsBasisDate = PaymentTermsBasisDate
        self.TermsNetDays = TermsNetDays
        self.PercentOfInvoicePayable = PercentOfInvoicePayable
        self.Discounts = Discounts
        self.Deferred = Deferred
        self.Penalty = Penalty
    def factory(*args_, **kwargs_):
        if PaymentTerms.subclass:
            return PaymentTerms.subclass(*args_, **kwargs_)
        else:
            return PaymentTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PaymentTermsOfSale(self): return self.PaymentTermsOfSale
    def set_PaymentTermsOfSale(self, PaymentTermsOfSale): self.PaymentTermsOfSale = PaymentTermsOfSale
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_PaymentTermsBasisDateCode(self): return self.PaymentTermsBasisDateCode
    def set_PaymentTermsBasisDateCode(self, PaymentTermsBasisDateCode): self.PaymentTermsBasisDateCode = PaymentTermsBasisDateCode
    def get_PaymentTermsBasisDate(self): return self.PaymentTermsBasisDate
    def set_PaymentTermsBasisDate(self, PaymentTermsBasisDate): self.PaymentTermsBasisDate = PaymentTermsBasisDate
    def get_TermsNetDays(self): return self.TermsNetDays
    def set_TermsNetDays(self, TermsNetDays): self.TermsNetDays = TermsNetDays
    def get_PercentOfInvoicePayable(self): return self.PercentOfInvoicePayable
    def set_PercentOfInvoicePayable(self, PercentOfInvoicePayable): self.PercentOfInvoicePayable = PercentOfInvoicePayable
    def get_Discounts(self): return self.Discounts
    def set_Discounts(self, Discounts): self.Discounts = Discounts
    def get_Deferred(self): return self.Deferred
    def set_Deferred(self, Deferred): self.Deferred = Deferred
    def get_Penalty(self): return self.Penalty
    def set_Penalty(self, Penalty): self.Penalty = Penalty
    def hasContent_(self):
        if (
            self.PaymentTermsOfSale is not None or
            self.Description is not None or
            self.PaymentTermsBasisDateCode is not None or
            self.PaymentTermsBasisDate is not None or
            self.TermsNetDays is not None or
            self.PercentOfInvoicePayable is not None or
            self.Discounts is not None or
            self.Deferred is not None or
            self.Penalty is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PaymentTerms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentTerms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PaymentTerms'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PaymentTerms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PaymentTermsOfSale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentTermsOfSale>%s</%sPaymentTermsOfSale>%s' % (namespace_, self.gds_format_string(quote_xml(self.PaymentTermsOfSale).encode(ExternalEncoding), input_name='PaymentTermsOfSale'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.PaymentTermsBasisDateCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentTermsBasisDateCode>%s</%sPaymentTermsBasisDateCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.PaymentTermsBasisDateCode).encode(ExternalEncoding), input_name='PaymentTermsBasisDateCode'), namespace_, eol_))
        if self.PaymentTermsBasisDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentTermsBasisDate>%s</%sPaymentTermsBasisDate>%s' % (namespace_, self.gds_format_date(self.PaymentTermsBasisDate, input_name='PaymentTermsBasisDate'), namespace_, eol_))
        if self.TermsNetDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTermsNetDays>%s</%sTermsNetDays>%s' % (namespace_, self.gds_format_integer(self.TermsNetDays, input_name='TermsNetDays'), namespace_, eol_))
        if self.PercentOfInvoicePayable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentOfInvoicePayable>%s</%sPercentOfInvoicePayable>%s' % (namespace_, self.gds_format_float(self.PercentOfInvoicePayable, input_name='PercentOfInvoicePayable'), namespace_, eol_))
        if self.Discounts is not None:
            self.Discounts.export(outfile, level, namespace_, name_='Discounts', pretty_print=pretty_print)
        if self.Deferred is not None:
            self.Deferred.export(outfile, level, namespace_, name_='Deferred', pretty_print=pretty_print)
        if self.Penalty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPenalty>%s</%sPenalty>%s' % (namespace_, self.gds_format_string(quote_xml(self.Penalty).encode(ExternalEncoding), input_name='Penalty'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PaymentTerms'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PaymentTermsOfSale is not None:
            showIndent(outfile, level)
            outfile.write('PaymentTermsOfSale=%s,\n' % quote_python(self.PaymentTermsOfSale).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.PaymentTermsBasisDateCode is not None:
            showIndent(outfile, level)
            outfile.write('PaymentTermsBasisDateCode=%s,\n' % quote_python(self.PaymentTermsBasisDateCode).encode(ExternalEncoding))
        if self.PaymentTermsBasisDate is not None:
            showIndent(outfile, level)
            outfile.write('PaymentTermsBasisDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.PaymentTermsBasisDate, input_name='PaymentTermsBasisDate'))
        if self.TermsNetDays is not None:
            showIndent(outfile, level)
            outfile.write('TermsNetDays=%d,\n' % self.TermsNetDays)
        if self.PercentOfInvoicePayable is not None:
            showIndent(outfile, level)
            outfile.write('PercentOfInvoicePayable=%f,\n' % self.PercentOfInvoicePayable)
        if self.Discounts is not None:
            showIndent(outfile, level)
            outfile.write('Discounts=model_.Discounts(\n')
            self.Discounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Deferred is not None:
            showIndent(outfile, level)
            outfile.write('Deferred=model_.Deferred(\n')
            self.Deferred.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Penalty is not None:
            showIndent(outfile, level)
            outfile.write('Penalty=%s,\n' % quote_python(self.Penalty).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PaymentTermsOfSale':
            PaymentTermsOfSale_ = child_.text
            PaymentTermsOfSale_ = self.gds_validate_string(PaymentTermsOfSale_, node, 'PaymentTermsOfSale')
            self.PaymentTermsOfSale = PaymentTermsOfSale_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'PaymentTermsBasisDateCode':
            PaymentTermsBasisDateCode_ = child_.text
            PaymentTermsBasisDateCode_ = self.gds_validate_string(PaymentTermsBasisDateCode_, node, 'PaymentTermsBasisDateCode')
            self.PaymentTermsBasisDateCode = PaymentTermsBasisDateCode_
        elif nodeName_ == 'PaymentTermsBasisDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'PaymentTermsBasisDate')
            self.PaymentTermsBasisDate = dval_
        elif nodeName_ == 'TermsNetDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TermsNetDays')
            self.TermsNetDays = ival_
        elif nodeName_ == 'PercentOfInvoicePayable':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentOfInvoicePayable')
            self.PercentOfInvoicePayable = fval_
        elif nodeName_ == 'Discounts':
            obj_ = Discounts.factory()
            obj_.build(child_)
            self.set_Discounts(obj_)
        elif nodeName_ == 'Deferred':
            obj_ = Deferred.factory()
            obj_.build(child_)
            self.set_Deferred(obj_)
        elif nodeName_ == 'Penalty':
            Penalty_ = child_.text
            Penalty_ = self.gds_validate_string(Penalty_, node, 'Penalty')
            self.Penalty = Penalty_
# end class PaymentTerms


class PersonnelInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PersonnelName=None, CompanyName=None, PersonnelIdentifier=None, TimeWorked=None, JobDescription=None, Comment=None):
        self.PersonnelName = PersonnelName
        self.CompanyName = CompanyName
        self.PersonnelIdentifier = PersonnelIdentifier
        self.TimeWorked = TimeWorked
        self.JobDescription = JobDescription
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if PersonnelInformation.subclass:
            return PersonnelInformation.subclass(*args_, **kwargs_)
        else:
            return PersonnelInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonnelName(self): return self.PersonnelName
    def set_PersonnelName(self, PersonnelName): self.PersonnelName = PersonnelName
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_PersonnelIdentifier(self): return self.PersonnelIdentifier
    def set_PersonnelIdentifier(self, PersonnelIdentifier): self.PersonnelIdentifier = PersonnelIdentifier
    def get_TimeWorked(self): return self.TimeWorked
    def set_TimeWorked(self, TimeWorked): self.TimeWorked = TimeWorked
    def get_JobDescription(self): return self.JobDescription
    def set_JobDescription(self, JobDescription): self.JobDescription = JobDescription
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def hasContent_(self):
        if (
            self.PersonnelName is not None or
            self.CompanyName is not None or
            self.PersonnelIdentifier is not None or
            self.TimeWorked is not None or
            self.JobDescription is not None or
            self.Comment is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PersonnelInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonnelInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PersonnelInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PersonnelInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PersonnelName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonnelName>%s</%sPersonnelName>%s' % (namespace_, self.gds_format_string(quote_xml(self.PersonnelName).encode(ExternalEncoding), input_name='PersonnelName'), namespace_, eol_))
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompanyName>%s</%sCompanyName>%s' % (namespace_, self.gds_format_string(quote_xml(self.CompanyName).encode(ExternalEncoding), input_name='CompanyName'), namespace_, eol_))
        if self.PersonnelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonnelIdentifier>%s</%sPersonnelIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.PersonnelIdentifier).encode(ExternalEncoding), input_name='PersonnelIdentifier'), namespace_, eol_))
        if self.TimeWorked is not None:
            self.TimeWorked.export(outfile, level, namespace_, name_='TimeWorked', pretty_print=pretty_print)
        if self.JobDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobDescription>%s</%sJobDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.JobDescription).encode(ExternalEncoding), input_name='JobDescription'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PersonnelInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PersonnelName is not None:
            showIndent(outfile, level)
            outfile.write('PersonnelName=%s,\n' % quote_python(self.PersonnelName).encode(ExternalEncoding))
        if self.CompanyName is not None:
            showIndent(outfile, level)
            outfile.write('CompanyName=%s,\n' % quote_python(self.CompanyName).encode(ExternalEncoding))
        if self.PersonnelIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('PersonnelIdentifier=%s,\n' % quote_python(self.PersonnelIdentifier).encode(ExternalEncoding))
        if self.TimeWorked is not None:
            showIndent(outfile, level)
            outfile.write('TimeWorked=model_.TimeWorked(\n')
            self.TimeWorked.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JobDescription is not None:
            showIndent(outfile, level)
            outfile.write('JobDescription=%s,\n' % quote_python(self.JobDescription).encode(ExternalEncoding))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PersonnelName':
            PersonnelName_ = child_.text
            PersonnelName_ = self.gds_validate_string(PersonnelName_, node, 'PersonnelName')
            self.PersonnelName = PersonnelName_
        elif nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
        elif nodeName_ == 'PersonnelIdentifier':
            PersonnelIdentifier_ = child_.text
            PersonnelIdentifier_ = self.gds_validate_string(PersonnelIdentifier_, node, 'PersonnelIdentifier')
            self.PersonnelIdentifier = PersonnelIdentifier_
        elif nodeName_ == 'TimeWorked':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_TimeWorked(obj_)
        elif nodeName_ == 'JobDescription':
            JobDescription_ = child_.text
            JobDescription_ = self.gds_validate_string(JobDescription_, node, 'JobDescription')
            self.JobDescription = JobDescription_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class PersonnelInformation


class PortOfDischarge(GeneratedsSuper):
    """The port or location of unloadingIndicates the organizational body
    who assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PortOfDischarge.subclass:
            return PortOfDischarge.subclass(*args_, **kwargs_)
        else:
            return PortOfDischarge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PortOfDischarge', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortOfDischarge')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PortOfDischarge'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PortOfDischarge', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PortOfDischarge'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PortOfDischarge


class PostalCountry(GeneratedsSuper):
    """The name of the country."""
    subclass = None
    superclass = None
    def __init__(self, CountryCode=None):
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if PostalCountry.subclass:
            return PostalCountry.subclass(*args_, **kwargs_)
        else:
            return PostalCountry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.CountryCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PostalCountry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalCountry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PostalCountry'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PostalCountry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountryCode>%s</%sCountryCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CountryCode).encode(ExternalEncoding), input_name='CountryCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PostalCountry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CountryCode is not None:
            showIndent(outfile, level)
            outfile.write('CountryCode=%s,\n' % quote_python(self.CountryCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class PostalCountry


class PortOfLoading(GeneratedsSuper):
    """The port of departure or loadingIndicates the organizational body
    who assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PortOfLoading.subclass:
            return PortOfLoading.subclass(*args_, **kwargs_)
        else:
            return PortOfLoading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PortOfLoading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortOfLoading')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PortOfLoading'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PortOfLoading', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PortOfLoading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PortOfLoading


class PriceBasis(GeneratedsSuper):
    """The rules upon which pricing is based in a transaction."""
    subclass = None
    superclass = None
    def __init__(self, Measurement=None, MeasurementRange=None, UnitOfMeasureCode=None, BasisDescription=None):
        self.Measurement = Measurement
        self.MeasurementRange = MeasurementRange
        self.UnitOfMeasureCode = UnitOfMeasureCode
        self.BasisDescription = BasisDescription
    def factory(*args_, **kwargs_):
        if PriceBasis.subclass:
            return PriceBasis.subclass(*args_, **kwargs_)
        else:
            return PriceBasis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measurement(self): return self.Measurement
    def set_Measurement(self, Measurement): self.Measurement = Measurement
    def get_MeasurementRange(self): return self.MeasurementRange
    def set_MeasurementRange(self, MeasurementRange): self.MeasurementRange = MeasurementRange
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def get_BasisDescription(self): return self.BasisDescription
    def set_BasisDescription(self, BasisDescription): self.BasisDescription = BasisDescription
    def hasContent_(self):
        if (
            self.Measurement is not None or
            self.MeasurementRange is not None or
            self.UnitOfMeasureCode is not None or
            self.BasisDescription is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PriceBasis', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceBasis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PriceBasis'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PriceBasis', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Measurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurement>%s</%sMeasurement>%s' % (namespace_, self.gds_format_float(self.Measurement, input_name='Measurement'), namespace_, eol_))
        if self.MeasurementRange is not None:
            self.MeasurementRange.export(outfile, level, namespace_, name_='MeasurementRange', pretty_print=pretty_print)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
        if self.BasisDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBasisDescription>%s</%sBasisDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.BasisDescription).encode(ExternalEncoding), input_name='BasisDescription'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PriceBasis'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Measurement is not None:
            showIndent(outfile, level)
            outfile.write('Measurement=%f,\n' % self.Measurement)
        if self.MeasurementRange is not None:
            showIndent(outfile, level)
            outfile.write('MeasurementRange=model_.MeasurementRange(\n')
            self.MeasurementRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
        if self.BasisDescription is not None:
            showIndent(outfile, level)
            outfile.write('BasisDescription=%s,\n' % quote_python(self.BasisDescription).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measurement')
            self.Measurement = fval_
        elif nodeName_ == 'MeasurementRange':
            obj_ = MeasurementRange.factory()
            obj_.build(child_)
            self.set_MeasurementRange(obj_)
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
        elif nodeName_ == 'BasisDescription':
            BasisDescription_ = child_.text
            BasisDescription_ = self.gds_validate_string(BasisDescription_, node, 'BasisDescription')
            self.BasisDescription = BasisDescription_
# end class PriceBasis


class Pricing(GeneratedsSuper):
    """Structure which contains price information about the monetary
    amount, the currency and price basis for it."""
    subclass = None
    superclass = None
    def __init__(self, UnitPrice=None, PriceBasis=None, PriceReason=None):
        self.UnitPrice = UnitPrice
        self.PriceBasis = PriceBasis
        self.PriceReason = PriceReason
    def factory(*args_, **kwargs_):
        if Pricing.subclass:
            return Pricing.subclass(*args_, **kwargs_)
        else:
            return Pricing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitPrice(self): return self.UnitPrice
    def set_UnitPrice(self, UnitPrice): self.UnitPrice = UnitPrice
    def get_PriceBasis(self): return self.PriceBasis
    def set_PriceBasis(self, PriceBasis): self.PriceBasis = PriceBasis
    def get_PriceReason(self): return self.PriceReason
    def set_PriceReason(self, PriceReason): self.PriceReason = PriceReason
    def hasContent_(self):
        if (
            self.UnitPrice is not None or
            self.PriceBasis is not None or
            self.PriceReason is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Pricing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pricing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Pricing'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Pricing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitPrice is not None:
            self.UnitPrice.export(outfile, level, namespace_, name_='UnitPrice', pretty_print=pretty_print)
        if self.PriceBasis is not None:
            self.PriceBasis.export(outfile, level, namespace_, name_='PriceBasis', pretty_print=pretty_print)
        if self.PriceReason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPriceReason>%s</%sPriceReason>%s' % (namespace_, self.gds_format_string(quote_xml(self.PriceReason).encode(ExternalEncoding), input_name='PriceReason'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Pricing'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitPrice is not None:
            showIndent(outfile, level)
            outfile.write('UnitPrice=model_.UnitPrice(\n')
            self.UnitPrice.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PriceBasis is not None:
            showIndent(outfile, level)
            outfile.write('PriceBasis=model_.PriceBasis(\n')
            self.PriceBasis.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PriceReason is not None:
            showIndent(outfile, level)
            outfile.write('PriceReason=%s,\n' % quote_python(self.PriceReason).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitPrice':
            obj_ = UnitPrice.factory()
            obj_.build(child_)
            self.set_UnitPrice(obj_)
        elif nodeName_ == 'PriceBasis':
            obj_ = PriceBasis.factory()
            obj_.build(child_)
            self.set_PriceBasis(obj_)
        elif nodeName_ == 'PriceReason':
            PriceReason_ = child_.text
            PriceReason_ = self.gds_validate_string(PriceReason_, node, 'PriceReason')
            self.PriceReason = PriceReason_
# end class Pricing


class ProductSubLineItems(GeneratedsSuper):
    """Children of product line items to add additional details to product
    line items."""
    subclass = None
    superclass = None
    def __init__(self, SubLineItemNumber=None, ManufacturingIdentificationDetails=None, GrossVolume=None, GrossWeight=None, NetWeight=None):
        self.SubLineItemNumber = SubLineItemNumber
        self.ManufacturingIdentificationDetails = ManufacturingIdentificationDetails
        self.GrossVolume = GrossVolume
        self.GrossWeight = GrossWeight
        self.NetWeight = NetWeight
    def factory(*args_, **kwargs_):
        if ProductSubLineItems.subclass:
            return ProductSubLineItems.subclass(*args_, **kwargs_)
        else:
            return ProductSubLineItems(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubLineItemNumber(self): return self.SubLineItemNumber
    def set_SubLineItemNumber(self, SubLineItemNumber): self.SubLineItemNumber = SubLineItemNumber
    def get_ManufacturingIdentificationDetails(self): return self.ManufacturingIdentificationDetails
    def set_ManufacturingIdentificationDetails(self, ManufacturingIdentificationDetails): self.ManufacturingIdentificationDetails = ManufacturingIdentificationDetails
    def get_GrossVolume(self): return self.GrossVolume
    def set_GrossVolume(self, GrossVolume): self.GrossVolume = GrossVolume
    def get_GrossWeight(self): return self.GrossWeight
    def set_GrossWeight(self, GrossWeight): self.GrossWeight = GrossWeight
    def get_NetWeight(self): return self.NetWeight
    def set_NetWeight(self, NetWeight): self.NetWeight = NetWeight
    def hasContent_(self):
        if (
            self.SubLineItemNumber is not None or
            self.ManufacturingIdentificationDetails is not None or
            self.GrossVolume is not None or
            self.GrossWeight is not None or
            self.NetWeight is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ProductSubLineItems', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSubLineItems')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ProductSubLineItems'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ProductSubLineItems', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubLineItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubLineItemNumber>%s</%sSubLineItemNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubLineItemNumber).encode(ExternalEncoding), input_name='SubLineItemNumber'), namespace_, eol_))
        if self.ManufacturingIdentificationDetails is not None:
            self.ManufacturingIdentificationDetails.export(outfile, level, namespace_, name_='ManufacturingIdentificationDetails', pretty_print=pretty_print)
        if self.GrossVolume is not None:
            self.GrossVolume.export(outfile, level, namespace_, name_='GrossVolume', pretty_print=pretty_print)
        if self.GrossWeight is not None:
            self.GrossWeight.export(outfile, level, namespace_, name_='GrossWeight', pretty_print=pretty_print)
        if self.NetWeight is not None:
            self.NetWeight.export(outfile, level, namespace_, name_='NetWeight', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductSubLineItems'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SubLineItemNumber is not None:
            showIndent(outfile, level)
            outfile.write('SubLineItemNumber=%s,\n' % quote_python(self.SubLineItemNumber).encode(ExternalEncoding))
        if self.ManufacturingIdentificationDetails is not None:
            showIndent(outfile, level)
            outfile.write('ManufacturingIdentificationDetails=model_.ManufacturingIdentificationDetails(\n')
            self.ManufacturingIdentificationDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GrossVolume is not None:
            showIndent(outfile, level)
            outfile.write('GrossVolume=model_.GrossVolume(\n')
            self.GrossVolume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GrossWeight is not None:
            showIndent(outfile, level)
            outfile.write('GrossWeight=model_.GrossWeight(\n')
            self.GrossWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NetWeight is not None:
            showIndent(outfile, level)
            outfile.write('NetWeight=model_.NetWeight(\n')
            self.NetWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubLineItemNumber':
            SubLineItemNumber_ = child_.text
            SubLineItemNumber_ = self.gds_validate_string(SubLineItemNumber_, node, 'SubLineItemNumber')
            self.SubLineItemNumber = SubLineItemNumber_
        elif nodeName_ == 'ManufacturingIdentificationDetails':
            obj_ = ManufacturingIdentificationDetails.factory()
            obj_.build(child_)
            self.set_ManufacturingIdentificationDetails(obj_)
        elif nodeName_ == 'GrossVolume':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_GrossVolume(obj_)
        elif nodeName_ == 'GrossWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_GrossWeight(obj_)
        elif nodeName_ == 'NetWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_NetWeight(obj_)
# end class ProductSubLineItems


class PrimaryCurrency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None):
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if PrimaryCurrency.subclass:
            return PrimaryCurrency.subclass(*args_, **kwargs_)
        else:
            return PrimaryCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PrimaryCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimaryCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PrimaryCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PrimaryCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PrimaryCurrency'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class PrimaryCurrency


class ProductIdentifier(GeneratedsSuper):
    """The unique code or number for a specific product.The organization
    who assigns a particular identifier for a product or
    partner.Identifies what "Other" is if chosen from an attribute
    enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, definitionOfOther=None, assigningOrganization=None, valueOf_=None):
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.assigningOrganization = _cast(None, assigningOrganization)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ProductIdentifier.subclass:
            return ProductIdentifier.subclass(*args_, **kwargs_)
        else:
            return ProductIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_assigningOrganization(self): return self.assigningOrganization
    def set_assigningOrganization(self, assigningOrganization): self.assigningOrganization = assigningOrganization
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ProductIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ProductIdentifier'):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
        if self.assigningOrganization is not None and 'assigningOrganization' not in already_processed:
            already_processed.add('assigningOrganization')
            outfile.write(' assigningOrganization=%s' % (quote_attrib(self.assigningOrganization), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ProductIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ProductIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
        if self.assigningOrganization is not None and 'assigningOrganization' not in already_processed:
            already_processed.add('assigningOrganization')
            showIndent(outfile, level)
            outfile.write('assigningOrganization = %s,\n' % (self.assigningOrganization,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
        value = find_attr_value_('assigningOrganization', node)
        if value is not None and 'assigningOrganization' not in already_processed:
            already_processed.add('assigningOrganization')
            self.assigningOrganization = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductIdentifier


class ProductInformation(GeneratedsSuper):
    """Structure which contains the information for a given product."""
    subclass = None
    superclass = None
    def __init__(self, ProductIdentifier=None, ProductDescription=None, ProductGradeDescription=None):
        if ProductIdentifier is None:
            self.ProductIdentifier = []
        else:
            self.ProductIdentifier = ProductIdentifier
        if ProductDescription is None:
            self.ProductDescription = []
        else:
            self.ProductDescription = ProductDescription
        if ProductGradeDescription is None:
            self.ProductGradeDescription = []
        else:
            self.ProductGradeDescription = ProductGradeDescription
    def factory(*args_, **kwargs_):
        if ProductInformation.subclass:
            return ProductInformation.subclass(*args_, **kwargs_)
        else:
            return ProductInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductIdentifier(self): return self.ProductIdentifier
    def set_ProductIdentifier(self, ProductIdentifier): self.ProductIdentifier = ProductIdentifier
    def add_ProductIdentifier(self, value): self.ProductIdentifier.append(value)
    def insert_ProductIdentifier(self, index, value): self.ProductIdentifier[index] = value
    def get_ProductDescription(self): return self.ProductDescription
    def set_ProductDescription(self, ProductDescription): self.ProductDescription = ProductDescription
    def add_ProductDescription(self, value): self.ProductDescription.append(value)
    def insert_ProductDescription(self, index, value): self.ProductDescription[index] = value
    def get_ProductGradeDescription(self): return self.ProductGradeDescription
    def set_ProductGradeDescription(self, ProductGradeDescription): self.ProductGradeDescription = ProductGradeDescription
    def add_ProductGradeDescription(self, value): self.ProductGradeDescription.append(value)
    def insert_ProductGradeDescription(self, index, value): self.ProductGradeDescription[index] = value
    def hasContent_(self):
        if (
            self.ProductIdentifier or
            self.ProductDescription or
            self.ProductGradeDescription
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ProductInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ProductInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ProductInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProductIdentifier_ in self.ProductIdentifier:
            ProductIdentifier_.export(outfile, level, namespace_, name_='ProductIdentifier', pretty_print=pretty_print)
        for ProductDescription_ in self.ProductDescription:
            ProductDescription_.export(outfile, level, namespace_, name_='ProductDescription', pretty_print=pretty_print)
        for ProductGradeDescription_ in self.ProductGradeDescription:
            ProductGradeDescription_.export(outfile, level, namespace_, name_='ProductGradeDescription', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ProductIdentifier=[\n')
        level += 1
        for ProductIdentifier_ in self.ProductIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.ProductIdentifier(\n')
            ProductIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProductDescription=[\n')
        level += 1
        for ProductDescription_ in self.ProductDescription:
            showIndent(outfile, level)
            outfile.write('model_.ProductDescription(\n')
            ProductDescription_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProductGradeDescription=[\n')
        level += 1
        for ProductGradeDescription_ in self.ProductGradeDescription:
            showIndent(outfile, level)
            outfile.write('model_.ProductGradeDescription(\n')
            ProductGradeDescription_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProductIdentifier':
            obj_ = ProductIdentifier.factory()
            obj_.build(child_)
            self.ProductIdentifier.append(obj_)
        elif nodeName_ == 'ProductDescription':
            obj_ = DescriptionType.factory()
            obj_.build(child_)
            self.ProductDescription.append(obj_)
        elif nodeName_ == 'ProductGradeDescription':
            obj_ = DescriptionType.factory()
            obj_.build(child_)
            self.ProductGradeDescription.append(obj_)
# end class ProductInformation


class PurchaseOrderInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PurchaseOrderNumber=None, PurchaseOrderIssuedDate=None, PurchaseOrderTypeCode=None, ReleaseNumber=None, SalesOrderNumber=None, RevisionNumber=None):
        self.PurchaseOrderNumber = PurchaseOrderNumber
        self.PurchaseOrderIssuedDate = PurchaseOrderIssuedDate
        self.PurchaseOrderTypeCode = PurchaseOrderTypeCode
        self.ReleaseNumber = ReleaseNumber
        self.SalesOrderNumber = SalesOrderNumber
        self.RevisionNumber = RevisionNumber
    def factory(*args_, **kwargs_):
        if PurchaseOrderInformation.subclass:
            return PurchaseOrderInformation.subclass(*args_, **kwargs_)
        else:
            return PurchaseOrderInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PurchaseOrderNumber(self): return self.PurchaseOrderNumber
    def set_PurchaseOrderNumber(self, PurchaseOrderNumber): self.PurchaseOrderNumber = PurchaseOrderNumber
    def get_PurchaseOrderIssuedDate(self): return self.PurchaseOrderIssuedDate
    def set_PurchaseOrderIssuedDate(self, PurchaseOrderIssuedDate): self.PurchaseOrderIssuedDate = PurchaseOrderIssuedDate
    def get_PurchaseOrderTypeCode(self): return self.PurchaseOrderTypeCode
    def set_PurchaseOrderTypeCode(self, PurchaseOrderTypeCode): self.PurchaseOrderTypeCode = PurchaseOrderTypeCode
    def get_ReleaseNumber(self): return self.ReleaseNumber
    def set_ReleaseNumber(self, ReleaseNumber): self.ReleaseNumber = ReleaseNumber
    def get_SalesOrderNumber(self): return self.SalesOrderNumber
    def set_SalesOrderNumber(self, SalesOrderNumber): self.SalesOrderNumber = SalesOrderNumber
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def hasContent_(self):
        if (
            self.PurchaseOrderNumber is not None or
            self.PurchaseOrderIssuedDate is not None or
            self.PurchaseOrderTypeCode is not None or
            self.ReleaseNumber is not None or
            self.SalesOrderNumber is not None or
            self.RevisionNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PurchaseOrderInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PurchaseOrderInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PurchaseOrderInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PurchaseOrderInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PurchaseOrderNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurchaseOrderNumber>%s</%sPurchaseOrderNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.PurchaseOrderNumber).encode(ExternalEncoding), input_name='PurchaseOrderNumber'), namespace_, eol_))
        if self.PurchaseOrderIssuedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurchaseOrderIssuedDate>%s</%sPurchaseOrderIssuedDate>%s' % (namespace_, self.gds_format_date(self.PurchaseOrderIssuedDate, input_name='PurchaseOrderIssuedDate'), namespace_, eol_))
        if self.PurchaseOrderTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurchaseOrderTypeCode>%s</%sPurchaseOrderTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.PurchaseOrderTypeCode).encode(ExternalEncoding), input_name='PurchaseOrderTypeCode'), namespace_, eol_))
        if self.ReleaseNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReleaseNumber>%s</%sReleaseNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReleaseNumber).encode(ExternalEncoding), input_name='ReleaseNumber'), namespace_, eol_))
        if self.SalesOrderNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSalesOrderNumber>%s</%sSalesOrderNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.SalesOrderNumber).encode(ExternalEncoding), input_name='SalesOrderNumber'), namespace_, eol_))
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PurchaseOrderInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PurchaseOrderNumber is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderNumber=%s,\n' % quote_python(self.PurchaseOrderNumber).encode(ExternalEncoding))
        if self.PurchaseOrderIssuedDate is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderIssuedDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.PurchaseOrderIssuedDate, input_name='PurchaseOrderIssuedDate'))
        if self.PurchaseOrderTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderTypeCode=%s,\n' % quote_python(self.PurchaseOrderTypeCode).encode(ExternalEncoding))
        if self.ReleaseNumber is not None:
            showIndent(outfile, level)
            outfile.write('ReleaseNumber=%s,\n' % quote_python(self.ReleaseNumber).encode(ExternalEncoding))
        if self.SalesOrderNumber is not None:
            showIndent(outfile, level)
            outfile.write('SalesOrderNumber=%s,\n' % quote_python(self.SalesOrderNumber).encode(ExternalEncoding))
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PurchaseOrderNumber':
            PurchaseOrderNumber_ = child_.text
            PurchaseOrderNumber_ = self.gds_validate_string(PurchaseOrderNumber_, node, 'PurchaseOrderNumber')
            self.PurchaseOrderNumber = PurchaseOrderNumber_
        elif nodeName_ == 'PurchaseOrderIssuedDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'PurchaseOrderIssuedDate')
            self.PurchaseOrderIssuedDate = dval_
        elif nodeName_ == 'PurchaseOrderTypeCode':
            PurchaseOrderTypeCode_ = child_.text
            PurchaseOrderTypeCode_ = self.gds_validate_string(PurchaseOrderTypeCode_, node, 'PurchaseOrderTypeCode')
            self.PurchaseOrderTypeCode = PurchaseOrderTypeCode_
        elif nodeName_ == 'ReleaseNumber':
            ReleaseNumber_ = child_.text
            ReleaseNumber_ = self.gds_validate_string(ReleaseNumber_, node, 'ReleaseNumber')
            self.ReleaseNumber = ReleaseNumber_
        elif nodeName_ == 'SalesOrderNumber':
            SalesOrderNumber_ = child_.text
            SalesOrderNumber_ = self.gds_validate_string(SalesOrderNumber_, node, 'SalesOrderNumber')
            self.SalesOrderNumber = SalesOrderNumber_
        elif nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
# end class PurchaseOrderInformation


class PurchaseOrderReferenceInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OrderNumber=None, OrderDate=None, LineItemNumber=None, ChangeSequenceNumber=None, ReleaseNumber=None):
        self.OrderNumber = OrderNumber
        self.OrderDate = OrderDate
        self.LineItemNumber = LineItemNumber
        self.ChangeSequenceNumber = ChangeSequenceNumber
        self.ReleaseNumber = ReleaseNumber
    def factory(*args_, **kwargs_):
        if PurchaseOrderReferenceInformation.subclass:
            return PurchaseOrderReferenceInformation.subclass(*args_, **kwargs_)
        else:
            return PurchaseOrderReferenceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrderNumber(self): return self.OrderNumber
    def set_OrderNumber(self, OrderNumber): self.OrderNumber = OrderNumber
    def get_OrderDate(self): return self.OrderDate
    def set_OrderDate(self, OrderDate): self.OrderDate = OrderDate
    def get_LineItemNumber(self): return self.LineItemNumber
    def set_LineItemNumber(self, LineItemNumber): self.LineItemNumber = LineItemNumber
    def get_ChangeSequenceNumber(self): return self.ChangeSequenceNumber
    def set_ChangeSequenceNumber(self, ChangeSequenceNumber): self.ChangeSequenceNumber = ChangeSequenceNumber
    def get_ReleaseNumber(self): return self.ReleaseNumber
    def set_ReleaseNumber(self, ReleaseNumber): self.ReleaseNumber = ReleaseNumber
    def hasContent_(self):
        if (
            self.OrderNumber is not None or
            self.OrderDate is not None or
            self.LineItemNumber is not None or
            self.ChangeSequenceNumber is not None or
            self.ReleaseNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PurchaseOrderReferenceInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PurchaseOrderReferenceInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PurchaseOrderReferenceInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PurchaseOrderReferenceInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrderNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrderNumber>%s</%sOrderNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrderNumber).encode(ExternalEncoding), input_name='OrderNumber'), namespace_, eol_))
        if self.OrderDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrderDate>%s</%sOrderDate>%s' % (namespace_, self.gds_format_datetime(self.OrderDate, input_name='OrderDate'), namespace_, eol_))
        if self.LineItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemNumber>%s</%sLineItemNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemNumber).encode(ExternalEncoding), input_name='LineItemNumber'), namespace_, eol_))
        if self.ChangeSequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChangeSequenceNumber>%s</%sChangeSequenceNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.ChangeSequenceNumber).encode(ExternalEncoding), input_name='ChangeSequenceNumber'), namespace_, eol_))
        if self.ReleaseNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReleaseNumber>%s</%sReleaseNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReleaseNumber).encode(ExternalEncoding), input_name='ReleaseNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PurchaseOrderReferenceInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OrderNumber is not None:
            showIndent(outfile, level)
            outfile.write('OrderNumber=%s,\n' % quote_python(self.OrderNumber).encode(ExternalEncoding))
        if self.OrderDate is not None:
            showIndent(outfile, level)
            outfile.write('OrderDate=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.OrderDate, input_name='OrderDate'))
        if self.LineItemNumber is not None:
            showIndent(outfile, level)
            outfile.write('LineItemNumber=%s,\n' % quote_python(self.LineItemNumber).encode(ExternalEncoding))
        if self.ChangeSequenceNumber is not None:
            showIndent(outfile, level)
            outfile.write('ChangeSequenceNumber=%s,\n' % quote_python(self.ChangeSequenceNumber).encode(ExternalEncoding))
        if self.ReleaseNumber is not None:
            showIndent(outfile, level)
            outfile.write('ReleaseNumber=%s,\n' % quote_python(self.ReleaseNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrderNumber':
            OrderNumber_ = child_.text
            OrderNumber_ = self.gds_validate_string(OrderNumber_, node, 'OrderNumber')
            self.OrderNumber = OrderNumber_
        elif nodeName_ == 'OrderDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'OrderDate')
            self.OrderDate = dval_
        elif nodeName_ == 'LineItemNumber':
            LineItemNumber_ = child_.text
            LineItemNumber_ = self.gds_validate_string(LineItemNumber_, node, 'LineItemNumber')
            self.LineItemNumber = LineItemNumber_
        elif nodeName_ == 'ChangeSequenceNumber':
            ChangeSequenceNumber_ = child_.text
            ChangeSequenceNumber_ = self.gds_validate_string(ChangeSequenceNumber_, node, 'ChangeSequenceNumber')
            self.ChangeSequenceNumber = ChangeSequenceNumber_
        elif nodeName_ == 'ReleaseNumber':
            ReleaseNumber_ = child_.text
            ReleaseNumber_ = self.gds_validate_string(ReleaseNumber_, node, 'ReleaseNumber')
            self.ReleaseNumber = ReleaseNumber_
# end class PurchaseOrderReferenceInformation


class QuoteRequestInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, QuoteRequestNumber=None, QuoteRequestDate=None, RevisionNumber=None):
        self.QuoteRequestNumber = QuoteRequestNumber
        self.QuoteRequestDate = QuoteRequestDate
        self.RevisionNumber = RevisionNumber
    def factory(*args_, **kwargs_):
        if QuoteRequestInformation.subclass:
            return QuoteRequestInformation.subclass(*args_, **kwargs_)
        else:
            return QuoteRequestInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QuoteRequestNumber(self): return self.QuoteRequestNumber
    def set_QuoteRequestNumber(self, QuoteRequestNumber): self.QuoteRequestNumber = QuoteRequestNumber
    def get_QuoteRequestDate(self): return self.QuoteRequestDate
    def set_QuoteRequestDate(self, QuoteRequestDate): self.QuoteRequestDate = QuoteRequestDate
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def hasContent_(self):
        if (
            self.QuoteRequestNumber is not None or
            self.QuoteRequestDate is not None or
            self.RevisionNumber is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='QuoteRequestInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuoteRequestInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='QuoteRequestInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='QuoteRequestInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QuoteRequestNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuoteRequestNumber>%s</%sQuoteRequestNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.QuoteRequestNumber).encode(ExternalEncoding), input_name='QuoteRequestNumber'), namespace_, eol_))
        if self.QuoteRequestDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuoteRequestDate>%s</%sQuoteRequestDate>%s' % (namespace_, self.gds_format_date(self.QuoteRequestDate, input_name='QuoteRequestDate'), namespace_, eol_))
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='QuoteRequestInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.QuoteRequestNumber is not None:
            showIndent(outfile, level)
            outfile.write('QuoteRequestNumber=%s,\n' % quote_python(self.QuoteRequestNumber).encode(ExternalEncoding))
        if self.QuoteRequestDate is not None:
            showIndent(outfile, level)
            outfile.write('QuoteRequestDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.QuoteRequestDate, input_name='QuoteRequestDate'))
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QuoteRequestNumber':
            QuoteRequestNumber_ = child_.text
            QuoteRequestNumber_ = self.gds_validate_string(QuoteRequestNumber_, node, 'QuoteRequestNumber')
            self.QuoteRequestNumber = QuoteRequestNumber_
        elif nodeName_ == 'QuoteRequestDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'QuoteRequestDate')
            self.QuoteRequestDate = dval_
        elif nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
# end class QuoteRequestInformation


class RateOfExchangeDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenceCurrency=None, TargetCurrency=None, ExchangeRate=None, DateOfRateOfExchange=None):
        self.ReferenceCurrency = ReferenceCurrency
        self.TargetCurrency = TargetCurrency
        self.ExchangeRate = ExchangeRate
        self.DateOfRateOfExchange = DateOfRateOfExchange
    def factory(*args_, **kwargs_):
        if RateOfExchangeDetail.subclass:
            return RateOfExchangeDetail.subclass(*args_, **kwargs_)
        else:
            return RateOfExchangeDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenceCurrency(self): return self.ReferenceCurrency
    def set_ReferenceCurrency(self, ReferenceCurrency): self.ReferenceCurrency = ReferenceCurrency
    def get_TargetCurrency(self): return self.TargetCurrency
    def set_TargetCurrency(self, TargetCurrency): self.TargetCurrency = TargetCurrency
    def get_ExchangeRate(self): return self.ExchangeRate
    def set_ExchangeRate(self, ExchangeRate): self.ExchangeRate = ExchangeRate
    def get_DateOfRateOfExchange(self): return self.DateOfRateOfExchange
    def set_DateOfRateOfExchange(self, DateOfRateOfExchange): self.DateOfRateOfExchange = DateOfRateOfExchange
    def hasContent_(self):
        if (
            self.ReferenceCurrency is not None or
            self.TargetCurrency is not None or
            self.ExchangeRate is not None or
            self.DateOfRateOfExchange is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='RateOfExchangeDetail', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateOfExchangeDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='RateOfExchangeDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='RateOfExchangeDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceCurrency is not None:
            self.ReferenceCurrency.export(outfile, level, namespace_, name_='ReferenceCurrency', pretty_print=pretty_print)
        if self.TargetCurrency is not None:
            self.TargetCurrency.export(outfile, level, namespace_, name_='TargetCurrency', pretty_print=pretty_print)
        if self.ExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExchangeRate>%s</%sExchangeRate>%s' % (namespace_, self.gds_format_float(self.ExchangeRate, input_name='ExchangeRate'), namespace_, eol_))
        if self.DateOfRateOfExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateOfRateOfExchange>%s</%sDateOfRateOfExchange>%s' % (namespace_, self.gds_format_date(self.DateOfRateOfExchange, input_name='DateOfRateOfExchange'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RateOfExchangeDetail'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ReferenceCurrency is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceCurrency=model_.ReferenceCurrency(\n')
            self.ReferenceCurrency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetCurrency is not None:
            showIndent(outfile, level)
            outfile.write('TargetCurrency=model_.TargetCurrency(\n')
            self.TargetCurrency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExchangeRate is not None:
            showIndent(outfile, level)
            outfile.write('ExchangeRate=%f,\n' % self.ExchangeRate)
        if self.DateOfRateOfExchange is not None:
            showIndent(outfile, level)
            outfile.write('DateOfRateOfExchange=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.DateOfRateOfExchange, input_name='DateOfRateOfExchange'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceCurrency':
            obj_ = ReferenceCurrency.factory()
            obj_.build(child_)
            self.set_ReferenceCurrency(obj_)
        elif nodeName_ == 'TargetCurrency':
            obj_ = TargetCurrency.factory()
            obj_.build(child_)
            self.set_TargetCurrency(obj_)
        elif nodeName_ == 'ExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ExchangeRate')
            self.ExchangeRate = fval_
        elif nodeName_ == 'DateOfRateOfExchange':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'DateOfRateOfExchange')
            self.DateOfRateOfExchange = dval_
# end class RateOfExchangeDetail


class ReferenceCurrency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None):
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if ReferenceCurrency.subclass:
            return ReferenceCurrency.subclass(*args_, **kwargs_)
        else:
            return ReferenceCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ReferenceCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ReferenceCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ReferenceCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReferenceCurrency'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class ReferenceCurrency


class ReferenceInformation(GeneratedsSuper):
    """Additional reference information or supporting information for a
    referenced document."""
    subclass = None
    superclass = None
    def __init__(self, referenceInformationIndicator=None, ReferenceNumber=None, Description=None):
        self.referenceInformationIndicator = _cast(None, referenceInformationIndicator)
        self.ReferenceNumber = ReferenceNumber
        self.Description = Description
    def factory(*args_, **kwargs_):
        if ReferenceInformation.subclass:
            return ReferenceInformation.subclass(*args_, **kwargs_)
        else:
            return ReferenceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_referenceInformationIndicator(self): return self.referenceInformationIndicator
    def set_referenceInformationIndicator(self, referenceInformationIndicator): self.referenceInformationIndicator = referenceInformationIndicator
    def hasContent_(self):
        if (
            self.ReferenceNumber is not None or
            self.Description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ReferenceInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ReferenceInformation'):
        if self.referenceInformationIndicator is not None and 'referenceInformationIndicator' not in already_processed:
            already_processed.add('referenceInformationIndicator')
            outfile.write(' referenceInformationIndicator=%s' % (quote_attrib(self.referenceInformationIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ReferenceInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceNumber>%s</%sReferenceNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReferenceNumber).encode(ExternalEncoding), input_name='ReferenceNumber'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReferenceInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.referenceInformationIndicator is not None and 'referenceInformationIndicator' not in already_processed:
            already_processed.add('referenceInformationIndicator')
            showIndent(outfile, level)
            outfile.write('referenceInformationIndicator = %s,\n' % (self.referenceInformationIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ReferenceNumber is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceNumber=%s,\n' % quote_python(self.ReferenceNumber).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceInformationIndicator', node)
        if value is not None and 'referenceInformationIndicator' not in already_processed:
            already_processed.add('referenceInformationIndicator')
            self.referenceInformationIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceNumber':
            ReferenceNumber_ = child_.text
            ReferenceNumber_ = self.gds_validate_string(ReferenceNumber_, node, 'ReferenceNumber')
            self.ReferenceNumber = ReferenceNumber_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ReferenceInformation


class RequestedDocument(GeneratedsSuper):
    """Structure which contains information about references to documents."""
    subclass = None
    superclass = None
    def __init__(self, DocumentReference=None, DocumentDeliveryInformation=None, NumberOfOriginals=None, NumberOfCopies=None):
        self.DocumentReference = DocumentReference
        self.DocumentDeliveryInformation = DocumentDeliveryInformation
        self.NumberOfOriginals = NumberOfOriginals
        self.NumberOfCopies = NumberOfCopies
    def factory(*args_, **kwargs_):
        if RequestedDocument.subclass:
            return RequestedDocument.subclass(*args_, **kwargs_)
        else:
            return RequestedDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentReference(self): return self.DocumentReference
    def set_DocumentReference(self, DocumentReference): self.DocumentReference = DocumentReference
    def get_DocumentDeliveryInformation(self): return self.DocumentDeliveryInformation
    def set_DocumentDeliveryInformation(self, DocumentDeliveryInformation): self.DocumentDeliveryInformation = DocumentDeliveryInformation
    def get_NumberOfOriginals(self): return self.NumberOfOriginals
    def set_NumberOfOriginals(self, NumberOfOriginals): self.NumberOfOriginals = NumberOfOriginals
    def get_NumberOfCopies(self): return self.NumberOfCopies
    def set_NumberOfCopies(self, NumberOfCopies): self.NumberOfCopies = NumberOfCopies
    def hasContent_(self):
        if (
            self.DocumentReference is not None or
            self.DocumentDeliveryInformation is not None or
            self.NumberOfOriginals is not None or
            self.NumberOfCopies is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='RequestedDocument', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='RequestedDocument'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='RequestedDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentReference is not None:
            self.DocumentReference.export(outfile, level, namespace_, name_='DocumentReference', pretty_print=pretty_print)
        if self.DocumentDeliveryInformation is not None:
            self.DocumentDeliveryInformation.export(outfile, level, namespace_, name_='DocumentDeliveryInformation', pretty_print=pretty_print)
        if self.NumberOfOriginals is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfOriginals>%s</%sNumberOfOriginals>%s' % (namespace_, self.gds_format_integer(self.NumberOfOriginals, input_name='NumberOfOriginals'), namespace_, eol_))
        if self.NumberOfCopies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfCopies>%s</%sNumberOfCopies>%s' % (namespace_, self.gds_format_integer(self.NumberOfCopies, input_name='NumberOfCopies'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RequestedDocument'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DocumentReference is not None:
            showIndent(outfile, level)
            outfile.write('DocumentReference=model_.DocumentReference(\n')
            self.DocumentReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentDeliveryInformation is not None:
            showIndent(outfile, level)
            outfile.write('DocumentDeliveryInformation=model_.DocumentDeliveryInformation(\n')
            self.DocumentDeliveryInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NumberOfOriginals is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfOriginals=%d,\n' % self.NumberOfOriginals)
        if self.NumberOfCopies is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfCopies=%d,\n' % self.NumberOfCopies)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentReference':
            obj_ = DocumentReference.factory()
            obj_.build(child_)
            self.set_DocumentReference(obj_)
        elif nodeName_ == 'DocumentDeliveryInformation':
            obj_ = DocumentDeliveryInformation.factory()
            obj_.build(child_)
            self.set_DocumentDeliveryInformation(obj_)
        elif nodeName_ == 'NumberOfOriginals':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfOriginals')
            self.NumberOfOriginals = ival_
        elif nodeName_ == 'NumberOfCopies':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfCopies')
            self.NumberOfCopies = ival_
# end class RequestedDocument


class RequestQuoteResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OpenDate=None, CloseDate=None, ContactInformation=None, ResponseInstructions=None):
        self.OpenDate = OpenDate
        self.CloseDate = CloseDate
        self.ContactInformation = ContactInformation
        self.ResponseInstructions = ResponseInstructions
    def factory(*args_, **kwargs_):
        if RequestQuoteResponse.subclass:
            return RequestQuoteResponse.subclass(*args_, **kwargs_)
        else:
            return RequestQuoteResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpenDate(self): return self.OpenDate
    def set_OpenDate(self, OpenDate): self.OpenDate = OpenDate
    def get_CloseDate(self): return self.CloseDate
    def set_CloseDate(self, CloseDate): self.CloseDate = CloseDate
    def get_ContactInformation(self): return self.ContactInformation
    def set_ContactInformation(self, ContactInformation): self.ContactInformation = ContactInformation
    def get_ResponseInstructions(self): return self.ResponseInstructions
    def set_ResponseInstructions(self, ResponseInstructions): self.ResponseInstructions = ResponseInstructions
    def hasContent_(self):
        if (
            self.OpenDate is not None or
            self.CloseDate is not None or
            self.ContactInformation is not None or
            self.ResponseInstructions is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='RequestQuoteResponse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestQuoteResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='RequestQuoteResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='RequestQuoteResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpenDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOpenDate>%s</%sOpenDate>%s' % (namespace_, self.gds_format_date(self.OpenDate, input_name='OpenDate'), namespace_, eol_))
        if self.CloseDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloseDate>%s</%sCloseDate>%s' % (namespace_, self.gds_format_date(self.CloseDate, input_name='CloseDate'), namespace_, eol_))
        if self.ContactInformation is not None:
            self.ContactInformation.export(outfile, level, namespace_, name_='ContactInformation', pretty_print=pretty_print)
        if self.ResponseInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResponseInstructions>%s</%sResponseInstructions>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResponseInstructions).encode(ExternalEncoding), input_name='ResponseInstructions'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RequestQuoteResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpenDate is not None:
            showIndent(outfile, level)
            outfile.write('OpenDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.OpenDate, input_name='OpenDate'))
        if self.CloseDate is not None:
            showIndent(outfile, level)
            outfile.write('CloseDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.CloseDate, input_name='CloseDate'))
        if self.ContactInformation is not None:
            showIndent(outfile, level)
            outfile.write('ContactInformation=model_.ContactInformation(\n')
            self.ContactInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResponseInstructions is not None:
            showIndent(outfile, level)
            outfile.write('ResponseInstructions=%s,\n' % quote_python(self.ResponseInstructions).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpenDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'OpenDate')
            self.OpenDate = dval_
        elif nodeName_ == 'CloseDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'CloseDate')
            self.CloseDate = dval_
        elif nodeName_ == 'ContactInformation':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.set_ContactInformation(obj_)
        elif nodeName_ == 'ResponseInstructions':
            ResponseInstructions_ = child_.text
            ResponseInstructions_ = self.gds_validate_string(ResponseInstructions_, node, 'ResponseInstructions')
            self.ResponseInstructions = ResponseInstructions_
# end class RequestQuoteResponse


class ResultingOrderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PurchaseOrderTypeCode=None):
        self.PurchaseOrderTypeCode = PurchaseOrderTypeCode
    def factory(*args_, **kwargs_):
        if ResultingOrderType.subclass:
            return ResultingOrderType.subclass(*args_, **kwargs_)
        else:
            return ResultingOrderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PurchaseOrderTypeCode(self): return self.PurchaseOrderTypeCode
    def set_PurchaseOrderTypeCode(self, PurchaseOrderTypeCode): self.PurchaseOrderTypeCode = PurchaseOrderTypeCode
    def hasContent_(self):
        if (
            self.PurchaseOrderTypeCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ResultingOrderType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultingOrderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ResultingOrderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ResultingOrderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PurchaseOrderTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurchaseOrderTypeCode>%s</%sPurchaseOrderTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.PurchaseOrderTypeCode).encode(ExternalEncoding), input_name='PurchaseOrderTypeCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ResultingOrderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PurchaseOrderTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderTypeCode=%s,\n' % quote_python(self.PurchaseOrderTypeCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PurchaseOrderTypeCode':
            PurchaseOrderTypeCode_ = child_.text
            PurchaseOrderTypeCode_ = self.gds_validate_string(PurchaseOrderTypeCode_, node, 'PurchaseOrderTypeCode')
            self.PurchaseOrderTypeCode = PurchaseOrderTypeCode_
# end class ResultingOrderType


class RigIdentifier(GeneratedsSuper):
    """The unique code or number for a specific rig.Identifies which rig
    identifier is being given."""
    subclass = None
    superclass = None
    def __init__(self, rigIdentifierType=None, valueOf_=None):
        self.rigIdentifierType = _cast(None, rigIdentifierType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RigIdentifier.subclass:
            return RigIdentifier.subclass(*args_, **kwargs_)
        else:
            return RigIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rigIdentifierType(self): return self.rigIdentifierType
    def set_rigIdentifierType(self, rigIdentifierType): self.rigIdentifierType = rigIdentifierType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='RigIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RigIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='RigIdentifier'):
        if self.rigIdentifierType is not None and 'rigIdentifierType' not in already_processed:
            already_processed.add('rigIdentifierType')
            outfile.write(' rigIdentifierType=%s' % (self.gds_format_string(quote_attrib(self.rigIdentifierType).encode(ExternalEncoding), input_name='rigIdentifierType'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='RigIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RigIdentifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rigIdentifierType is not None and 'rigIdentifierType' not in already_processed:
            already_processed.add('rigIdentifierType')
            showIndent(outfile, level)
            outfile.write('rigIdentifierType = "%s",\n' % (self.rigIdentifierType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rigIdentifierType', node)
        if value is not None and 'rigIdentifierType' not in already_processed:
            already_processed.add('rigIdentifierType')
            self.rigIdentifierType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RigIdentifier


class SampleMeasures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartnerDefinedMeasure=None, ObservedDensity=None, ObservedTemperature=None, APIGravity=None, AverageTemperature=None, AveragePressure=None, AverageFlowRate=None, CorrectedGravity=None, CorrectedTemperatureLiquidFactor=None, CorrectedPressureLiquidFactor=None, CorrectedDensity=None, CompositeFactor=None, PercentLoaded=None, FlashTemperature=None, Haze=None, LineItemColor=None, Microseparometer=None, IncrustationFactor=None):
        if PartnerDefinedMeasure is None:
            self.PartnerDefinedMeasure = []
        else:
            self.PartnerDefinedMeasure = PartnerDefinedMeasure
        self.ObservedDensity = ObservedDensity
        self.ObservedTemperature = ObservedTemperature
        self.APIGravity = APIGravity
        self.AverageTemperature = AverageTemperature
        self.AveragePressure = AveragePressure
        self.AverageFlowRate = AverageFlowRate
        self.CorrectedGravity = CorrectedGravity
        self.CorrectedTemperatureLiquidFactor = CorrectedTemperatureLiquidFactor
        self.CorrectedPressureLiquidFactor = CorrectedPressureLiquidFactor
        self.CorrectedDensity = CorrectedDensity
        self.CompositeFactor = CompositeFactor
        self.PercentLoaded = PercentLoaded
        self.FlashTemperature = FlashTemperature
        self.Haze = Haze
        self.LineItemColor = LineItemColor
        self.Microseparometer = Microseparometer
        self.IncrustationFactor = IncrustationFactor
    def factory(*args_, **kwargs_):
        if SampleMeasures.subclass:
            return SampleMeasures.subclass(*args_, **kwargs_)
        else:
            return SampleMeasures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerDefinedMeasure(self): return self.PartnerDefinedMeasure
    def set_PartnerDefinedMeasure(self, PartnerDefinedMeasure): self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def add_PartnerDefinedMeasure(self, value): self.PartnerDefinedMeasure.append(value)
    def insert_PartnerDefinedMeasure(self, index, value): self.PartnerDefinedMeasure[index] = value
    def get_ObservedDensity(self): return self.ObservedDensity
    def set_ObservedDensity(self, ObservedDensity): self.ObservedDensity = ObservedDensity
    def get_ObservedTemperature(self): return self.ObservedTemperature
    def set_ObservedTemperature(self, ObservedTemperature): self.ObservedTemperature = ObservedTemperature
    def get_APIGravity(self): return self.APIGravity
    def set_APIGravity(self, APIGravity): self.APIGravity = APIGravity
    def get_AverageTemperature(self): return self.AverageTemperature
    def set_AverageTemperature(self, AverageTemperature): self.AverageTemperature = AverageTemperature
    def get_AveragePressure(self): return self.AveragePressure
    def set_AveragePressure(self, AveragePressure): self.AveragePressure = AveragePressure
    def get_AverageFlowRate(self): return self.AverageFlowRate
    def set_AverageFlowRate(self, AverageFlowRate): self.AverageFlowRate = AverageFlowRate
    def get_CorrectedGravity(self): return self.CorrectedGravity
    def set_CorrectedGravity(self, CorrectedGravity): self.CorrectedGravity = CorrectedGravity
    def get_CorrectedTemperatureLiquidFactor(self): return self.CorrectedTemperatureLiquidFactor
    def set_CorrectedTemperatureLiquidFactor(self, CorrectedTemperatureLiquidFactor): self.CorrectedTemperatureLiquidFactor = CorrectedTemperatureLiquidFactor
    def get_CorrectedPressureLiquidFactor(self): return self.CorrectedPressureLiquidFactor
    def set_CorrectedPressureLiquidFactor(self, CorrectedPressureLiquidFactor): self.CorrectedPressureLiquidFactor = CorrectedPressureLiquidFactor
    def get_CorrectedDensity(self): return self.CorrectedDensity
    def set_CorrectedDensity(self, CorrectedDensity): self.CorrectedDensity = CorrectedDensity
    def get_CompositeFactor(self): return self.CompositeFactor
    def set_CompositeFactor(self, CompositeFactor): self.CompositeFactor = CompositeFactor
    def get_PercentLoaded(self): return self.PercentLoaded
    def set_PercentLoaded(self, PercentLoaded): self.PercentLoaded = PercentLoaded
    def get_FlashTemperature(self): return self.FlashTemperature
    def set_FlashTemperature(self, FlashTemperature): self.FlashTemperature = FlashTemperature
    def get_Haze(self): return self.Haze
    def set_Haze(self, Haze): self.Haze = Haze
    def get_LineItemColor(self): return self.LineItemColor
    def set_LineItemColor(self, LineItemColor): self.LineItemColor = LineItemColor
    def get_Microseparometer(self): return self.Microseparometer
    def set_Microseparometer(self, Microseparometer): self.Microseparometer = Microseparometer
    def get_IncrustationFactor(self): return self.IncrustationFactor
    def set_IncrustationFactor(self, IncrustationFactor): self.IncrustationFactor = IncrustationFactor
    def hasContent_(self):
        if (
            self.PartnerDefinedMeasure or
            self.ObservedDensity is not None or
            self.ObservedTemperature is not None or
            self.APIGravity is not None or
            self.AverageTemperature is not None or
            self.AveragePressure is not None or
            self.AverageFlowRate is not None or
            self.CorrectedGravity is not None or
            self.CorrectedTemperatureLiquidFactor is not None or
            self.CorrectedPressureLiquidFactor is not None or
            self.CorrectedDensity is not None or
            self.CompositeFactor is not None or
            self.PercentLoaded is not None or
            self.FlashTemperature is not None or
            self.Haze is not None or
            self.LineItemColor is not None or
            self.Microseparometer is not None or
            self.IncrustationFactor is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SampleMeasures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleMeasures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SampleMeasures'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SampleMeasures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            PartnerDefinedMeasure_.export(outfile, level, namespace_, name_='PartnerDefinedMeasure', pretty_print=pretty_print)
        if self.ObservedDensity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObservedDensity>%s</%sObservedDensity>%s' % (namespace_, self.gds_format_float(self.ObservedDensity, input_name='ObservedDensity'), namespace_, eol_))
        if self.ObservedTemperature is not None:
            self.ObservedTemperature.export(outfile, level, namespace_, name_='ObservedTemperature', pretty_print=pretty_print)
        if self.APIGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAPIGravity>%s</%sAPIGravity>%s' % (namespace_, self.gds_format_float(self.APIGravity, input_name='APIGravity'), namespace_, eol_))
        if self.AverageTemperature is not None:
            self.AverageTemperature.export(outfile, level, namespace_, name_='AverageTemperature', pretty_print=pretty_print)
        if self.AveragePressure is not None:
            self.AveragePressure.export(outfile, level, namespace_, name_='AveragePressure', pretty_print=pretty_print)
        if self.AverageFlowRate is not None:
            self.AverageFlowRate.export(outfile, level, namespace_, name_='AverageFlowRate', pretty_print=pretty_print)
        if self.CorrectedGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedGravity>%s</%sCorrectedGravity>%s' % (namespace_, self.gds_format_float(self.CorrectedGravity, input_name='CorrectedGravity'), namespace_, eol_))
        if self.CorrectedTemperatureLiquidFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedTemperatureLiquidFactor>%s</%sCorrectedTemperatureLiquidFactor>%s' % (namespace_, self.gds_format_float(self.CorrectedTemperatureLiquidFactor, input_name='CorrectedTemperatureLiquidFactor'), namespace_, eol_))
        if self.CorrectedPressureLiquidFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedPressureLiquidFactor>%s</%sCorrectedPressureLiquidFactor>%s' % (namespace_, self.gds_format_float(self.CorrectedPressureLiquidFactor, input_name='CorrectedPressureLiquidFactor'), namespace_, eol_))
        if self.CorrectedDensity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedDensity>%s</%sCorrectedDensity>%s' % (namespace_, self.gds_format_float(self.CorrectedDensity, input_name='CorrectedDensity'), namespace_, eol_))
        if self.CompositeFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompositeFactor>%s</%sCompositeFactor>%s' % (namespace_, self.gds_format_float(self.CompositeFactor, input_name='CompositeFactor'), namespace_, eol_))
        if self.PercentLoaded is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentLoaded>%s</%sPercentLoaded>%s' % (namespace_, self.gds_format_float(self.PercentLoaded, input_name='PercentLoaded'), namespace_, eol_))
        if self.FlashTemperature is not None:
            self.FlashTemperature.export(outfile, level, namespace_, name_='FlashTemperature', pretty_print=pretty_print)
        if self.Haze is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHaze>%s</%sHaze>%s' % (namespace_, self.gds_format_integer(self.Haze, input_name='Haze'), namespace_, eol_))
        if self.LineItemColor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemColor>%s</%sLineItemColor>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemColor).encode(ExternalEncoding), input_name='LineItemColor'), namespace_, eol_))
        if self.Microseparometer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMicroseparometer>%s</%sMicroseparometer>%s' % (namespace_, self.gds_format_string(quote_xml(self.Microseparometer).encode(ExternalEncoding), input_name='Microseparometer'), namespace_, eol_))
        if self.IncrustationFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIncrustationFactor>%s</%sIncrustationFactor>%s' % (namespace_, self.gds_format_float(self.IncrustationFactor, input_name='IncrustationFactor'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SampleMeasures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PartnerDefinedMeasure=[\n')
        level += 1
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            showIndent(outfile, level)
            outfile.write('model_.PartnerDefinedMeasure(\n')
            PartnerDefinedMeasure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ObservedDensity is not None:
            showIndent(outfile, level)
            outfile.write('ObservedDensity=%f,\n' % self.ObservedDensity)
        if self.ObservedTemperature is not None:
            showIndent(outfile, level)
            outfile.write('ObservedTemperature=model_.ObservedTemperature(\n')
            self.ObservedTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.APIGravity is not None:
            showIndent(outfile, level)
            outfile.write('APIGravity=%f,\n' % self.APIGravity)
        if self.AverageTemperature is not None:
            showIndent(outfile, level)
            outfile.write('AverageTemperature=model_.AverageTemperature(\n')
            self.AverageTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AveragePressure is not None:
            showIndent(outfile, level)
            outfile.write('AveragePressure=model_.AveragePressure(\n')
            self.AveragePressure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AverageFlowRate is not None:
            showIndent(outfile, level)
            outfile.write('AverageFlowRate=model_.AverageFlowRate(\n')
            self.AverageFlowRate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrectedGravity is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedGravity=%f,\n' % self.CorrectedGravity)
        if self.CorrectedTemperatureLiquidFactor is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedTemperatureLiquidFactor=%f,\n' % self.CorrectedTemperatureLiquidFactor)
        if self.CorrectedPressureLiquidFactor is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedPressureLiquidFactor=%f,\n' % self.CorrectedPressureLiquidFactor)
        if self.CorrectedDensity is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedDensity=%f,\n' % self.CorrectedDensity)
        if self.CompositeFactor is not None:
            showIndent(outfile, level)
            outfile.write('CompositeFactor=%f,\n' % self.CompositeFactor)
        if self.PercentLoaded is not None:
            showIndent(outfile, level)
            outfile.write('PercentLoaded=%f,\n' % self.PercentLoaded)
        if self.FlashTemperature is not None:
            showIndent(outfile, level)
            outfile.write('FlashTemperature=model_.FlashTemperature(\n')
            self.FlashTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Haze is not None:
            showIndent(outfile, level)
            outfile.write('Haze=%d,\n' % self.Haze)
        if self.LineItemColor is not None:
            showIndent(outfile, level)
            outfile.write('LineItemColor=%s,\n' % quote_python(self.LineItemColor).encode(ExternalEncoding))
        if self.Microseparometer is not None:
            showIndent(outfile, level)
            outfile.write('Microseparometer=%s,\n' % quote_python(self.Microseparometer).encode(ExternalEncoding))
        if self.IncrustationFactor is not None:
            showIndent(outfile, level)
            outfile.write('IncrustationFactor=%f,\n' % self.IncrustationFactor)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerDefinedMeasure':
            obj_ = PartnerDefinedMeasure.factory()
            obj_.build(child_)
            self.PartnerDefinedMeasure.append(obj_)
        elif nodeName_ == 'ObservedDensity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ObservedDensity')
            self.ObservedDensity = fval_
        elif nodeName_ == 'ObservedTemperature':
            obj_ = ObservedTemperature.factory()
            obj_.build(child_)
            self.set_ObservedTemperature(obj_)
        elif nodeName_ == 'APIGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'APIGravity')
            self.APIGravity = fval_
        elif nodeName_ == 'AverageTemperature':
            obj_ = AverageTemperature.factory()
            obj_.build(child_)
            self.set_AverageTemperature(obj_)
        elif nodeName_ == 'AveragePressure':
            obj_ = AveragePressure.factory()
            obj_.build(child_)
            self.set_AveragePressure(obj_)
        elif nodeName_ == 'AverageFlowRate':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_AverageFlowRate(obj_)
        elif nodeName_ == 'CorrectedGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedGravity')
            self.CorrectedGravity = fval_
        elif nodeName_ == 'CorrectedTemperatureLiquidFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedTemperatureLiquidFactor')
            self.CorrectedTemperatureLiquidFactor = fval_
        elif nodeName_ == 'CorrectedPressureLiquidFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedPressureLiquidFactor')
            self.CorrectedPressureLiquidFactor = fval_
        elif nodeName_ == 'CorrectedDensity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedDensity')
            self.CorrectedDensity = fval_
        elif nodeName_ == 'CompositeFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CompositeFactor')
            self.CompositeFactor = fval_
        elif nodeName_ == 'PercentLoaded':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentLoaded')
            self.PercentLoaded = fval_
        elif nodeName_ == 'FlashTemperature':
            obj_ = FlashTemperature.factory()
            obj_.build(child_)
            self.set_FlashTemperature(obj_)
        elif nodeName_ == 'Haze':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Haze')
            self.Haze = ival_
        elif nodeName_ == 'LineItemColor':
            LineItemColor_ = child_.text
            LineItemColor_ = self.gds_validate_string(LineItemColor_, node, 'LineItemColor')
            self.LineItemColor = LineItemColor_
        elif nodeName_ == 'Microseparometer':
            Microseparometer_ = child_.text
            Microseparometer_ = self.gds_validate_string(Microseparometer_, node, 'Microseparometer')
            self.Microseparometer = Microseparometer_
        elif nodeName_ == 'IncrustationFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'IncrustationFactor')
            self.IncrustationFactor = fval_
# end class SampleMeasures


class SecondCurrency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None):
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if SecondCurrency.subclass:
            return SecondCurrency.subclass(*args_, **kwargs_)
        else:
            return SecondCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SecondCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SecondCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SecondCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SecondCurrency'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class SecondCurrency


class SellersCurrency(GeneratedsSuper):
    """Indicates the currency of the seller."""
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None):
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if SellersCurrency.subclass:
            return SellersCurrency.subclass(*args_, **kwargs_)
        else:
            return SellersCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SellersCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SellersCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SellersCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SellersCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SellersCurrency'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class SellersCurrency


class ServiceDateTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dateTypeIndicator=None, valueOf_=None):
        self.dateTypeIndicator = _cast(None, dateTypeIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ServiceDateTime.subclass:
            return ServiceDateTime.subclass(*args_, **kwargs_)
        else:
            return ServiceDateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTypeIndicator(self): return self.dateTypeIndicator
    def set_dateTypeIndicator(self, dateTypeIndicator): self.dateTypeIndicator = dateTypeIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ServiceDateTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceDateTime')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ServiceDateTime'):
        if self.dateTypeIndicator is not None and 'dateTypeIndicator' not in already_processed:
            already_processed.add('dateTypeIndicator')
            outfile.write(' dateTypeIndicator=%s' % (quote_attrib(self.dateTypeIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ServiceDateTime', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ServiceDateTime'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dateTypeIndicator is not None and 'dateTypeIndicator' not in already_processed:
            already_processed.add('dateTypeIndicator')
            showIndent(outfile, level)
            outfile.write('dateTypeIndicator = %s,\n' % (self.dateTypeIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dateTypeIndicator', node)
        if value is not None and 'dateTypeIndicator' not in already_processed:
            already_processed.add('dateTypeIndicator')
            self.dateTypeIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceDateTime


class ShipmentTerms(GeneratedsSuper):
    """Structure containing information on the terms for shipment."""
    subclass = None
    superclass = None
    def __init__(self, ShipmentTermsCode=None, ShipmentTermsLocation=None):
        self.ShipmentTermsCode = ShipmentTermsCode
        self.ShipmentTermsLocation = ShipmentTermsLocation
    def factory(*args_, **kwargs_):
        if ShipmentTerms.subclass:
            return ShipmentTerms.subclass(*args_, **kwargs_)
        else:
            return ShipmentTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipmentTermsCode(self): return self.ShipmentTermsCode
    def set_ShipmentTermsCode(self, ShipmentTermsCode): self.ShipmentTermsCode = ShipmentTermsCode
    def get_ShipmentTermsLocation(self): return self.ShipmentTermsLocation
    def set_ShipmentTermsLocation(self, ShipmentTermsLocation): self.ShipmentTermsLocation = ShipmentTermsLocation
    def hasContent_(self):
        if (
            self.ShipmentTermsCode is not None or
            self.ShipmentTermsLocation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ShipmentTerms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentTerms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ShipmentTerms'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ShipmentTerms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipmentTermsCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShipmentTermsCode>%s</%sShipmentTermsCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ShipmentTermsCode).encode(ExternalEncoding), input_name='ShipmentTermsCode'), namespace_, eol_))
        if self.ShipmentTermsLocation is not None:
            self.ShipmentTermsLocation.export(outfile, level, namespace_, name_='ShipmentTermsLocation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ShipmentTerms'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ShipmentTermsCode is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentTermsCode=%s,\n' % quote_python(self.ShipmentTermsCode).encode(ExternalEncoding))
        if self.ShipmentTermsLocation is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentTermsLocation=model_.ShipmentTermsLocation(\n')
            self.ShipmentTermsLocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipmentTermsCode':
            ShipmentTermsCode_ = child_.text
            ShipmentTermsCode_ = self.gds_validate_string(ShipmentTermsCode_, node, 'ShipmentTermsCode')
            self.ShipmentTermsCode = ShipmentTermsCode_
        elif nodeName_ == 'ShipmentTermsLocation':
            obj_ = ShipmentTermsLocation.factory()
            obj_.build(child_)
            self.set_ShipmentTermsLocation(obj_)
# end class ShipmentTerms


class ShipmentPackaging(GeneratedsSuper):
    """Structure containing details of the lading packaging."""
    subclass = None
    superclass = None
    def __init__(self, PackageDetail=None):
        if PackageDetail is None:
            self.PackageDetail = []
        else:
            self.PackageDetail = PackageDetail
    def factory(*args_, **kwargs_):
        if ShipmentPackaging.subclass:
            return ShipmentPackaging.subclass(*args_, **kwargs_)
        else:
            return ShipmentPackaging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PackageDetail(self): return self.PackageDetail
    def set_PackageDetail(self, PackageDetail): self.PackageDetail = PackageDetail
    def add_PackageDetail(self, value): self.PackageDetail.append(value)
    def insert_PackageDetail(self, index, value): self.PackageDetail[index] = value
    def hasContent_(self):
        if (
            self.PackageDetail
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ShipmentPackaging', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentPackaging')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ShipmentPackaging'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ShipmentPackaging', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PackageDetail_ in self.PackageDetail:
            PackageDetail_.export(outfile, level, namespace_, name_='PackageDetail', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ShipmentPackaging'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PackageDetail=[\n')
        level += 1
        for PackageDetail_ in self.PackageDetail:
            showIndent(outfile, level)
            outfile.write('model_.PackageDetail(\n')
            PackageDetail_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PackageDetail':
            obj_ = PackageDetail.factory()
            obj_.build(child_)
            self.PackageDetail.append(obj_)
# end class ShipmentPackaging


class ShipmentTermsLocation(GeneratedsSuper):
    """The terms under which a product is shipped, such as "Freight
    Prepaid", "FOB", etc.Indicates the organizational body who
    assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ShipmentTermsLocation.subclass:
            return ShipmentTermsLocation.subclass(*args_, **kwargs_)
        else:
            return ShipmentTermsLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ShipmentTermsLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentTermsLocation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ShipmentTermsLocation'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ShipmentTermsLocation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ShipmentTermsLocation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ShipmentTermsLocation


class ShipNoticeEquipmentDetails(GeneratedsSuper):
    """Structure containing the equipment details related to the
    AdvancedShipNotice message."""
    subclass = None
    superclass = None
    def __init__(self, LineItemNumber=None, EquipmentIdentifier=None, CarrierEquipmentCode=None, EquipmentOwnership=None, NumberOfUnits=None, SpecialInstructions=None, Height=None, Width=None, Length=None, NetWeight=None, TareWeight=None, GrossWeight=None, NetVolume=None, GrossVolume=None, SealNumber=None, EquipmentLoadEmptyStatus=None):
        self.LineItemNumber = LineItemNumber
        self.EquipmentIdentifier = EquipmentIdentifier
        self.CarrierEquipmentCode = CarrierEquipmentCode
        self.EquipmentOwnership = EquipmentOwnership
        self.NumberOfUnits = NumberOfUnits
        if SpecialInstructions is None:
            self.SpecialInstructions = []
        else:
            self.SpecialInstructions = SpecialInstructions
        self.Height = Height
        self.Width = Width
        self.Length = Length
        self.NetWeight = NetWeight
        self.TareWeight = TareWeight
        self.GrossWeight = GrossWeight
        self.NetVolume = NetVolume
        self.GrossVolume = GrossVolume
        if SealNumber is None:
            self.SealNumber = []
        else:
            self.SealNumber = SealNumber
        self.EquipmentLoadEmptyStatus = EquipmentLoadEmptyStatus
    def factory(*args_, **kwargs_):
        if ShipNoticeEquipmentDetails.subclass:
            return ShipNoticeEquipmentDetails.subclass(*args_, **kwargs_)
        else:
            return ShipNoticeEquipmentDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineItemNumber(self): return self.LineItemNumber
    def set_LineItemNumber(self, LineItemNumber): self.LineItemNumber = LineItemNumber
    def get_EquipmentIdentifier(self): return self.EquipmentIdentifier
    def set_EquipmentIdentifier(self, EquipmentIdentifier): self.EquipmentIdentifier = EquipmentIdentifier
    def get_CarrierEquipmentCode(self): return self.CarrierEquipmentCode
    def set_CarrierEquipmentCode(self, CarrierEquipmentCode): self.CarrierEquipmentCode = CarrierEquipmentCode
    def get_EquipmentOwnership(self): return self.EquipmentOwnership
    def set_EquipmentOwnership(self, EquipmentOwnership): self.EquipmentOwnership = EquipmentOwnership
    def get_NumberOfUnits(self): return self.NumberOfUnits
    def set_NumberOfUnits(self, NumberOfUnits): self.NumberOfUnits = NumberOfUnits
    def get_SpecialInstructions(self): return self.SpecialInstructions
    def set_SpecialInstructions(self, SpecialInstructions): self.SpecialInstructions = SpecialInstructions
    def add_SpecialInstructions(self, value): self.SpecialInstructions.append(value)
    def insert_SpecialInstructions(self, index, value): self.SpecialInstructions[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_NetWeight(self): return self.NetWeight
    def set_NetWeight(self, NetWeight): self.NetWeight = NetWeight
    def get_TareWeight(self): return self.TareWeight
    def set_TareWeight(self, TareWeight): self.TareWeight = TareWeight
    def get_GrossWeight(self): return self.GrossWeight
    def set_GrossWeight(self, GrossWeight): self.GrossWeight = GrossWeight
    def get_NetVolume(self): return self.NetVolume
    def set_NetVolume(self, NetVolume): self.NetVolume = NetVolume
    def get_GrossVolume(self): return self.GrossVolume
    def set_GrossVolume(self, GrossVolume): self.GrossVolume = GrossVolume
    def get_SealNumber(self): return self.SealNumber
    def set_SealNumber(self, SealNumber): self.SealNumber = SealNumber
    def add_SealNumber(self, value): self.SealNumber.append(value)
    def insert_SealNumber(self, index, value): self.SealNumber[index] = value
    def get_EquipmentLoadEmptyStatus(self): return self.EquipmentLoadEmptyStatus
    def set_EquipmentLoadEmptyStatus(self, EquipmentLoadEmptyStatus): self.EquipmentLoadEmptyStatus = EquipmentLoadEmptyStatus
    def hasContent_(self):
        if (
            self.LineItemNumber is not None or
            self.EquipmentIdentifier is not None or
            self.CarrierEquipmentCode is not None or
            self.EquipmentOwnership is not None or
            self.NumberOfUnits is not None or
            self.SpecialInstructions or
            self.Height is not None or
            self.Width is not None or
            self.Length is not None or
            self.NetWeight is not None or
            self.TareWeight is not None or
            self.GrossWeight is not None or
            self.NetVolume is not None or
            self.GrossVolume is not None or
            self.SealNumber or
            self.EquipmentLoadEmptyStatus is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ShipNoticeEquipmentDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipNoticeEquipmentDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ShipNoticeEquipmentDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ShipNoticeEquipmentDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LineItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemNumber>%s</%sLineItemNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemNumber).encode(ExternalEncoding), input_name='LineItemNumber'), namespace_, eol_))
        if self.EquipmentIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEquipmentIdentifier>%s</%sEquipmentIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.EquipmentIdentifier).encode(ExternalEncoding), input_name='EquipmentIdentifier'), namespace_, eol_))
        if self.CarrierEquipmentCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCarrierEquipmentCode>%s</%sCarrierEquipmentCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CarrierEquipmentCode).encode(ExternalEncoding), input_name='CarrierEquipmentCode'), namespace_, eol_))
        if self.EquipmentOwnership is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEquipmentOwnership>%s</%sEquipmentOwnership>%s' % (namespace_, self.gds_format_string(quote_xml(self.EquipmentOwnership).encode(ExternalEncoding), input_name='EquipmentOwnership'), namespace_, eol_))
        if self.NumberOfUnits is not None:
            self.NumberOfUnits.export(outfile, level, namespace_, name_='NumberOfUnits', pretty_print=pretty_print)
        for SpecialInstructions_ in self.SpecialInstructions:
            SpecialInstructions_.export(outfile, level, namespace_, name_='SpecialInstructions', pretty_print=pretty_print)
        if self.Height is not None:
            self.Height.export(outfile, level, namespace_, name_='Height', pretty_print=pretty_print)
        if self.Width is not None:
            self.Width.export(outfile, level, namespace_, name_='Width', pretty_print=pretty_print)
        if self.Length is not None:
            self.Length.export(outfile, level, namespace_, name_='Length', pretty_print=pretty_print)
        if self.NetWeight is not None:
            self.NetWeight.export(outfile, level, namespace_, name_='NetWeight', pretty_print=pretty_print)
        if self.TareWeight is not None:
            self.TareWeight.export(outfile, level, namespace_, name_='TareWeight', pretty_print=pretty_print)
        if self.GrossWeight is not None:
            self.GrossWeight.export(outfile, level, namespace_, name_='GrossWeight', pretty_print=pretty_print)
        if self.NetVolume is not None:
            self.NetVolume.export(outfile, level, namespace_, name_='NetVolume', pretty_print=pretty_print)
        if self.GrossVolume is not None:
            self.GrossVolume.export(outfile, level, namespace_, name_='GrossVolume', pretty_print=pretty_print)
        for SealNumber_ in self.SealNumber:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSealNumber>%s</%sSealNumber>%s' % (namespace_, self.gds_format_string(quote_xml(SealNumber_).encode(ExternalEncoding), input_name='SealNumber'), namespace_, eol_))
        if self.EquipmentLoadEmptyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEquipmentLoadEmptyStatus>%s</%sEquipmentLoadEmptyStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.EquipmentLoadEmptyStatus).encode(ExternalEncoding), input_name='EquipmentLoadEmptyStatus'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ShipNoticeEquipmentDetails'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LineItemNumber is not None:
            showIndent(outfile, level)
            outfile.write('LineItemNumber=%s,\n' % quote_python(self.LineItemNumber).encode(ExternalEncoding))
        if self.EquipmentIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('EquipmentIdentifier=%s,\n' % quote_python(self.EquipmentIdentifier).encode(ExternalEncoding))
        if self.CarrierEquipmentCode is not None:
            showIndent(outfile, level)
            outfile.write('CarrierEquipmentCode=%s,\n' % quote_python(self.CarrierEquipmentCode).encode(ExternalEncoding))
        if self.EquipmentOwnership is not None:
            showIndent(outfile, level)
            outfile.write('EquipmentOwnership=%s,\n' % quote_python(self.EquipmentOwnership).encode(ExternalEncoding))
        if self.NumberOfUnits is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfUnits=model_.NumberOfUnits(\n')
            self.NumberOfUnits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SpecialInstructions=[\n')
        level += 1
        for SpecialInstructions_ in self.SpecialInstructions:
            showIndent(outfile, level)
            outfile.write('model_.SpecialInstructions(\n')
            SpecialInstructions_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Height is not None:
            showIndent(outfile, level)
            outfile.write('Height=model_.Height(\n')
            self.Height.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Width is not None:
            showIndent(outfile, level)
            outfile.write('Width=model_.Width(\n')
            self.Width.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=model_.Length(\n')
            self.Length.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NetWeight is not None:
            showIndent(outfile, level)
            outfile.write('NetWeight=model_.NetWeight(\n')
            self.NetWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TareWeight is not None:
            showIndent(outfile, level)
            outfile.write('TareWeight=model_.TareWeight(\n')
            self.TareWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GrossWeight is not None:
            showIndent(outfile, level)
            outfile.write('GrossWeight=model_.GrossWeight(\n')
            self.GrossWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NetVolume is not None:
            showIndent(outfile, level)
            outfile.write('NetVolume=model_.NetVolume(\n')
            self.NetVolume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GrossVolume is not None:
            showIndent(outfile, level)
            outfile.write('GrossVolume=model_.GrossVolume(\n')
            self.GrossVolume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SealNumber=[\n')
        level += 1
        for SealNumber_ in self.SealNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SealNumber_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EquipmentLoadEmptyStatus is not None:
            showIndent(outfile, level)
            outfile.write('EquipmentLoadEmptyStatus=%s,\n' % quote_python(self.EquipmentLoadEmptyStatus).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineItemNumber':
            LineItemNumber_ = child_.text
            LineItemNumber_ = self.gds_validate_string(LineItemNumber_, node, 'LineItemNumber')
            self.LineItemNumber = LineItemNumber_
        elif nodeName_ == 'EquipmentIdentifier':
            EquipmentIdentifier_ = child_.text
            EquipmentIdentifier_ = self.gds_validate_string(EquipmentIdentifier_, node, 'EquipmentIdentifier')
            self.EquipmentIdentifier = EquipmentIdentifier_
        elif nodeName_ == 'CarrierEquipmentCode':
            CarrierEquipmentCode_ = child_.text
            CarrierEquipmentCode_ = self.gds_validate_string(CarrierEquipmentCode_, node, 'CarrierEquipmentCode')
            self.CarrierEquipmentCode = CarrierEquipmentCode_
        elif nodeName_ == 'EquipmentOwnership':
            EquipmentOwnership_ = child_.text
            EquipmentOwnership_ = self.gds_validate_string(EquipmentOwnership_, node, 'EquipmentOwnership')
            self.EquipmentOwnership = EquipmentOwnership_
        elif nodeName_ == 'NumberOfUnits':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_NumberOfUnits(obj_)
        elif nodeName_ == 'SpecialInstructions':
            obj_ = SpecialInstructions.factory()
            obj_.build(child_)
            self.SpecialInstructions.append(obj_)
        elif nodeName_ == 'Height':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_Height(obj_)
        elif nodeName_ == 'Width':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_Width(obj_)
        elif nodeName_ == 'Length':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_Length(obj_)
        elif nodeName_ == 'NetWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_NetWeight(obj_)
        elif nodeName_ == 'TareWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_TareWeight(obj_)
        elif nodeName_ == 'GrossWeight':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_GrossWeight(obj_)
        elif nodeName_ == 'NetVolume':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_NetVolume(obj_)
        elif nodeName_ == 'GrossVolume':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_GrossVolume(obj_)
        elif nodeName_ == 'SealNumber':
            SealNumber_ = child_.text
            SealNumber_ = self.gds_validate_string(SealNumber_, node, 'SealNumber')
            self.SealNumber.append(SealNumber_)
        elif nodeName_ == 'EquipmentLoadEmptyStatus':
            EquipmentLoadEmptyStatus_ = child_.text
            EquipmentLoadEmptyStatus_ = self.gds_validate_string(EquipmentLoadEmptyStatus_, node, 'EquipmentLoadEmptyStatus')
            self.EquipmentLoadEmptyStatus = EquipmentLoadEmptyStatus_
# end class ShipNoticeEquipmentDetails


class SpecialInstructions(GeneratedsSuper):
    """A free-form textual description of requirements.Identifies what kind
    of special instruction is being given.Identifies what "Other" is
    if chosen from an attribute enumeration list"""
    subclass = None
    superclass = None
    def __init__(self, definitionOfOther=None, instructionIndicator=None, valueOf_=None):
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.instructionIndicator = _cast(None, instructionIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SpecialInstructions.subclass:
            return SpecialInstructions.subclass(*args_, **kwargs_)
        else:
            return SpecialInstructions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_instructionIndicator(self): return self.instructionIndicator
    def set_instructionIndicator(self, instructionIndicator): self.instructionIndicator = instructionIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SpecialInstructions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecialInstructions')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SpecialInstructions'):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
        if self.instructionIndicator is not None and 'instructionIndicator' not in already_processed:
            already_processed.add('instructionIndicator')
            outfile.write(' instructionIndicator=%s' % (quote_attrib(self.instructionIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SpecialInstructions', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SpecialInstructions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
        if self.instructionIndicator is not None and 'instructionIndicator' not in already_processed:
            already_processed.add('instructionIndicator')
            showIndent(outfile, level)
            outfile.write('instructionIndicator = %s,\n' % (self.instructionIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
        value = find_attr_value_('instructionIndicator', node)
        if value is not None and 'instructionIndicator' not in already_processed:
            already_processed.add('instructionIndicator')
            self.instructionIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpecialInstructions


class TankCloseMeasures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdjustmentQuantity=None, AmbientTemperature=None, APIGravity=None, CorrectedQuantity=None, CorrectedGravity=None, TankDateTime=None, GaugeReadingMeasure=None, GaugeQuantity=None, ReadingQuantity=None, TankWaterQuantity=None, TankWaterMeasure=None, TankTemperature=None, AdjustedRoofQuantity=None, CorrectedTemperatureLiquidFactor=None, PartnerDefinedMeasure=None):
        self.AdjustmentQuantity = AdjustmentQuantity
        self.AmbientTemperature = AmbientTemperature
        self.APIGravity = APIGravity
        self.CorrectedQuantity = CorrectedQuantity
        self.CorrectedGravity = CorrectedGravity
        self.TankDateTime = TankDateTime
        self.GaugeReadingMeasure = GaugeReadingMeasure
        self.GaugeQuantity = GaugeQuantity
        self.ReadingQuantity = ReadingQuantity
        self.TankWaterQuantity = TankWaterQuantity
        self.TankWaterMeasure = TankWaterMeasure
        self.TankTemperature = TankTemperature
        self.AdjustedRoofQuantity = AdjustedRoofQuantity
        self.CorrectedTemperatureLiquidFactor = CorrectedTemperatureLiquidFactor
        if PartnerDefinedMeasure is None:
            self.PartnerDefinedMeasure = []
        else:
            self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def factory(*args_, **kwargs_):
        if TankCloseMeasures.subclass:
            return TankCloseMeasures.subclass(*args_, **kwargs_)
        else:
            return TankCloseMeasures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdjustmentQuantity(self): return self.AdjustmentQuantity
    def set_AdjustmentQuantity(self, AdjustmentQuantity): self.AdjustmentQuantity = AdjustmentQuantity
    def get_AmbientTemperature(self): return self.AmbientTemperature
    def set_AmbientTemperature(self, AmbientTemperature): self.AmbientTemperature = AmbientTemperature
    def get_APIGravity(self): return self.APIGravity
    def set_APIGravity(self, APIGravity): self.APIGravity = APIGravity
    def get_CorrectedQuantity(self): return self.CorrectedQuantity
    def set_CorrectedQuantity(self, CorrectedQuantity): self.CorrectedQuantity = CorrectedQuantity
    def get_CorrectedGravity(self): return self.CorrectedGravity
    def set_CorrectedGravity(self, CorrectedGravity): self.CorrectedGravity = CorrectedGravity
    def get_TankDateTime(self): return self.TankDateTime
    def set_TankDateTime(self, TankDateTime): self.TankDateTime = TankDateTime
    def get_GaugeReadingMeasure(self): return self.GaugeReadingMeasure
    def set_GaugeReadingMeasure(self, GaugeReadingMeasure): self.GaugeReadingMeasure = GaugeReadingMeasure
    def get_GaugeQuantity(self): return self.GaugeQuantity
    def set_GaugeQuantity(self, GaugeQuantity): self.GaugeQuantity = GaugeQuantity
    def get_ReadingQuantity(self): return self.ReadingQuantity
    def set_ReadingQuantity(self, ReadingQuantity): self.ReadingQuantity = ReadingQuantity
    def get_TankWaterQuantity(self): return self.TankWaterQuantity
    def set_TankWaterQuantity(self, TankWaterQuantity): self.TankWaterQuantity = TankWaterQuantity
    def get_TankWaterMeasure(self): return self.TankWaterMeasure
    def set_TankWaterMeasure(self, TankWaterMeasure): self.TankWaterMeasure = TankWaterMeasure
    def get_TankTemperature(self): return self.TankTemperature
    def set_TankTemperature(self, TankTemperature): self.TankTemperature = TankTemperature
    def get_AdjustedRoofQuantity(self): return self.AdjustedRoofQuantity
    def set_AdjustedRoofQuantity(self, AdjustedRoofQuantity): self.AdjustedRoofQuantity = AdjustedRoofQuantity
    def get_CorrectedTemperatureLiquidFactor(self): return self.CorrectedTemperatureLiquidFactor
    def set_CorrectedTemperatureLiquidFactor(self, CorrectedTemperatureLiquidFactor): self.CorrectedTemperatureLiquidFactor = CorrectedTemperatureLiquidFactor
    def get_PartnerDefinedMeasure(self): return self.PartnerDefinedMeasure
    def set_PartnerDefinedMeasure(self, PartnerDefinedMeasure): self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def add_PartnerDefinedMeasure(self, value): self.PartnerDefinedMeasure.append(value)
    def insert_PartnerDefinedMeasure(self, index, value): self.PartnerDefinedMeasure[index] = value
    def hasContent_(self):
        if (
            self.AdjustmentQuantity is not None or
            self.AmbientTemperature is not None or
            self.APIGravity is not None or
            self.CorrectedQuantity is not None or
            self.CorrectedGravity is not None or
            self.TankDateTime is not None or
            self.GaugeReadingMeasure is not None or
            self.GaugeQuantity is not None or
            self.ReadingQuantity is not None or
            self.TankWaterQuantity is not None or
            self.TankWaterMeasure is not None or
            self.TankTemperature is not None or
            self.AdjustedRoofQuantity is not None or
            self.CorrectedTemperatureLiquidFactor is not None or
            self.PartnerDefinedMeasure
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TankCloseMeasures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankCloseMeasures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TankCloseMeasures'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TankCloseMeasures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdjustmentQuantity is not None:
            self.AdjustmentQuantity.export(outfile, level, namespace_, name_='AdjustmentQuantity', pretty_print=pretty_print)
        if self.AmbientTemperature is not None:
            self.AmbientTemperature.export(outfile, level, namespace_, name_='AmbientTemperature', pretty_print=pretty_print)
        if self.APIGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAPIGravity>%s</%sAPIGravity>%s' % (namespace_, self.gds_format_float(self.APIGravity, input_name='APIGravity'), namespace_, eol_))
        if self.CorrectedQuantity is not None:
            self.CorrectedQuantity.export(outfile, level, namespace_, name_='CorrectedQuantity', pretty_print=pretty_print)
        if self.CorrectedGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedGravity>%s</%sCorrectedGravity>%s' % (namespace_, self.gds_format_float(self.CorrectedGravity, input_name='CorrectedGravity'), namespace_, eol_))
        if self.TankDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTankDateTime>%s</%sTankDateTime>%s' % (namespace_, self.gds_format_datetime(self.TankDateTime, input_name='TankDateTime'), namespace_, eol_))
        if self.GaugeReadingMeasure is not None:
            self.GaugeReadingMeasure.export(outfile, level, namespace_, name_='GaugeReadingMeasure', pretty_print=pretty_print)
        if self.GaugeQuantity is not None:
            self.GaugeQuantity.export(outfile, level, namespace_, name_='GaugeQuantity', pretty_print=pretty_print)
        if self.ReadingQuantity is not None:
            self.ReadingQuantity.export(outfile, level, namespace_, name_='ReadingQuantity', pretty_print=pretty_print)
        if self.TankWaterQuantity is not None:
            self.TankWaterQuantity.export(outfile, level, namespace_, name_='TankWaterQuantity', pretty_print=pretty_print)
        if self.TankWaterMeasure is not None:
            self.TankWaterMeasure.export(outfile, level, namespace_, name_='TankWaterMeasure', pretty_print=pretty_print)
        if self.TankTemperature is not None:
            self.TankTemperature.export(outfile, level, namespace_, name_='TankTemperature', pretty_print=pretty_print)
        if self.AdjustedRoofQuantity is not None:
            self.AdjustedRoofQuantity.export(outfile, level, namespace_, name_='AdjustedRoofQuantity', pretty_print=pretty_print)
        if self.CorrectedTemperatureLiquidFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedTemperatureLiquidFactor>%s</%sCorrectedTemperatureLiquidFactor>%s' % (namespace_, self.gds_format_float(self.CorrectedTemperatureLiquidFactor, input_name='CorrectedTemperatureLiquidFactor'), namespace_, eol_))
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            PartnerDefinedMeasure_.export(outfile, level, namespace_, name_='PartnerDefinedMeasure', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TankCloseMeasures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AdjustmentQuantity is not None:
            showIndent(outfile, level)
            outfile.write('AdjustmentQuantity=model_.AdjustmentQuantity(\n')
            self.AdjustmentQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AmbientTemperature is not None:
            showIndent(outfile, level)
            outfile.write('AmbientTemperature=model_.AmbientTemperature(\n')
            self.AmbientTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.APIGravity is not None:
            showIndent(outfile, level)
            outfile.write('APIGravity=%f,\n' % self.APIGravity)
        if self.CorrectedQuantity is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedQuantity=model_.CorrectedQuantity(\n')
            self.CorrectedQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrectedGravity is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedGravity=%f,\n' % self.CorrectedGravity)
        if self.TankDateTime is not None:
            showIndent(outfile, level)
            outfile.write('TankDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.TankDateTime, input_name='TankDateTime'))
        if self.GaugeReadingMeasure is not None:
            showIndent(outfile, level)
            outfile.write('GaugeReadingMeasure=model_.GaugeReadingMeasure(\n')
            self.GaugeReadingMeasure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaugeQuantity is not None:
            showIndent(outfile, level)
            outfile.write('GaugeQuantity=model_.GaugeQuantity(\n')
            self.GaugeQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingQuantity is not None:
            showIndent(outfile, level)
            outfile.write('ReadingQuantity=model_.ReadingQuantity(\n')
            self.ReadingQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankWaterQuantity is not None:
            showIndent(outfile, level)
            outfile.write('TankWaterQuantity=model_.TankWaterQuantity(\n')
            self.TankWaterQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankWaterMeasure is not None:
            showIndent(outfile, level)
            outfile.write('TankWaterMeasure=model_.TankWaterMeasure(\n')
            self.TankWaterMeasure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankTemperature is not None:
            showIndent(outfile, level)
            outfile.write('TankTemperature=model_.TankTemperature(\n')
            self.TankTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AdjustedRoofQuantity is not None:
            showIndent(outfile, level)
            outfile.write('AdjustedRoofQuantity=model_.AdjustedRoofQuantity(\n')
            self.AdjustedRoofQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrectedTemperatureLiquidFactor is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedTemperatureLiquidFactor=%f,\n' % self.CorrectedTemperatureLiquidFactor)
        showIndent(outfile, level)
        outfile.write('PartnerDefinedMeasure=[\n')
        level += 1
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            showIndent(outfile, level)
            outfile.write('model_.PartnerDefinedMeasure(\n')
            PartnerDefinedMeasure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdjustmentQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_AdjustmentQuantity(obj_)
        elif nodeName_ == 'AmbientTemperature':
            obj_ = AmbientTemperature.factory()
            obj_.build(child_)
            self.set_AmbientTemperature(obj_)
        elif nodeName_ == 'APIGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'APIGravity')
            self.APIGravity = fval_
        elif nodeName_ == 'CorrectedQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_CorrectedQuantity(obj_)
        elif nodeName_ == 'CorrectedGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedGravity')
            self.CorrectedGravity = fval_
        elif nodeName_ == 'TankDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'TankDateTime')
            self.TankDateTime = dval_
        elif nodeName_ == 'GaugeReadingMeasure':
            obj_ = GaugeReadingMeasure.factory()
            obj_.build(child_)
            self.set_GaugeReadingMeasure(obj_)
        elif nodeName_ == 'GaugeQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_GaugeQuantity(obj_)
        elif nodeName_ == 'ReadingQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_ReadingQuantity(obj_)
        elif nodeName_ == 'TankWaterQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_TankWaterQuantity(obj_)
        elif nodeName_ == 'TankWaterMeasure':
            obj_ = TankWaterMeasure.factory()
            obj_.build(child_)
            self.set_TankWaterMeasure(obj_)
        elif nodeName_ == 'TankTemperature':
            obj_ = TankTemperature.factory()
            obj_.build(child_)
            self.set_TankTemperature(obj_)
        elif nodeName_ == 'AdjustedRoofQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_AdjustedRoofQuantity(obj_)
        elif nodeName_ == 'CorrectedTemperatureLiquidFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedTemperatureLiquidFactor')
            self.CorrectedTemperatureLiquidFactor = fval_
        elif nodeName_ == 'PartnerDefinedMeasure':
            obj_ = PartnerDefinedMeasure.factory()
            obj_.build(child_)
            self.PartnerDefinedMeasure.append(obj_)
# end class TankCloseMeasures


class TankHeight(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Measurement=None, UnitOfMeasureCode=None):
        self.Measurement = Measurement
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if TankHeight.subclass:
            return TankHeight.subclass(*args_, **kwargs_)
        else:
            return TankHeight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measurement(self): return self.Measurement
    def set_Measurement(self, Measurement): self.Measurement = Measurement
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Measurement is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TankHeight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankHeight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TankHeight'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TankHeight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Measurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurement>%s</%sMeasurement>%s' % (namespace_, self.gds_format_float(self.Measurement, input_name='Measurement'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TankHeight'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Measurement is not None:
            showIndent(outfile, level)
            outfile.write('Measurement=%f,\n' % self.Measurement)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measurement')
            self.Measurement = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class TankHeight


class TankMeasures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TankHeight=None, TankCapacityQuantity=None, PartnerDefinedMeasure=None, TankOpenMeasures=None, TankCloseMeasures=None):
        self.TankHeight = TankHeight
        self.TankCapacityQuantity = TankCapacityQuantity
        if PartnerDefinedMeasure is None:
            self.PartnerDefinedMeasure = []
        else:
            self.PartnerDefinedMeasure = PartnerDefinedMeasure
        self.TankOpenMeasures = TankOpenMeasures
        self.TankCloseMeasures = TankCloseMeasures
    def factory(*args_, **kwargs_):
        if TankMeasures.subclass:
            return TankMeasures.subclass(*args_, **kwargs_)
        else:
            return TankMeasures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TankHeight(self): return self.TankHeight
    def set_TankHeight(self, TankHeight): self.TankHeight = TankHeight
    def get_TankCapacityQuantity(self): return self.TankCapacityQuantity
    def set_TankCapacityQuantity(self, TankCapacityQuantity): self.TankCapacityQuantity = TankCapacityQuantity
    def get_PartnerDefinedMeasure(self): return self.PartnerDefinedMeasure
    def set_PartnerDefinedMeasure(self, PartnerDefinedMeasure): self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def add_PartnerDefinedMeasure(self, value): self.PartnerDefinedMeasure.append(value)
    def insert_PartnerDefinedMeasure(self, index, value): self.PartnerDefinedMeasure[index] = value
    def get_TankOpenMeasures(self): return self.TankOpenMeasures
    def set_TankOpenMeasures(self, TankOpenMeasures): self.TankOpenMeasures = TankOpenMeasures
    def get_TankCloseMeasures(self): return self.TankCloseMeasures
    def set_TankCloseMeasures(self, TankCloseMeasures): self.TankCloseMeasures = TankCloseMeasures
    def hasContent_(self):
        if (
            self.TankHeight is not None or
            self.TankCapacityQuantity is not None or
            self.PartnerDefinedMeasure or
            self.TankOpenMeasures is not None or
            self.TankCloseMeasures is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TankMeasures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankMeasures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TankMeasures'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TankMeasures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TankHeight is not None:
            self.TankHeight.export(outfile, level, namespace_, name_='TankHeight', pretty_print=pretty_print)
        if self.TankCapacityQuantity is not None:
            self.TankCapacityQuantity.export(outfile, level, namespace_, name_='TankCapacityQuantity', pretty_print=pretty_print)
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            PartnerDefinedMeasure_.export(outfile, level, namespace_, name_='PartnerDefinedMeasure', pretty_print=pretty_print)
        if self.TankOpenMeasures is not None:
            self.TankOpenMeasures.export(outfile, level, namespace_, name_='TankOpenMeasures', pretty_print=pretty_print)
        if self.TankCloseMeasures is not None:
            self.TankCloseMeasures.export(outfile, level, namespace_, name_='TankCloseMeasures', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TankMeasures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TankHeight is not None:
            showIndent(outfile, level)
            outfile.write('TankHeight=model_.TankHeight(\n')
            self.TankHeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankCapacityQuantity is not None:
            showIndent(outfile, level)
            outfile.write('TankCapacityQuantity=model_.TankCapacityQuantity(\n')
            self.TankCapacityQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('PartnerDefinedMeasure=[\n')
        level += 1
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            showIndent(outfile, level)
            outfile.write('model_.PartnerDefinedMeasure(\n')
            PartnerDefinedMeasure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TankOpenMeasures is not None:
            showIndent(outfile, level)
            outfile.write('TankOpenMeasures=model_.TankOpenMeasures(\n')
            self.TankOpenMeasures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankCloseMeasures is not None:
            showIndent(outfile, level)
            outfile.write('TankCloseMeasures=model_.TankCloseMeasures(\n')
            self.TankCloseMeasures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TankHeight':
            obj_ = TankHeight.factory()
            obj_.build(child_)
            self.set_TankHeight(obj_)
        elif nodeName_ == 'TankCapacityQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_TankCapacityQuantity(obj_)
        elif nodeName_ == 'PartnerDefinedMeasure':
            obj_ = PartnerDefinedMeasure.factory()
            obj_.build(child_)
            self.PartnerDefinedMeasure.append(obj_)
        elif nodeName_ == 'TankOpenMeasures':
            obj_ = TankOpenMeasures.factory()
            obj_.build(child_)
            self.set_TankOpenMeasures(obj_)
        elif nodeName_ == 'TankCloseMeasures':
            obj_ = TankCloseMeasures.factory()
            obj_.build(child_)
            self.set_TankCloseMeasures(obj_)
# end class TankMeasures


class TankOpenMeasures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdjustmentQuantity=None, AmbientTemperature=None, APIGravity=None, CorrectedQuantity=None, CorrectedGravity=None, TankDateTime=None, GaugeReadingMeasure=None, GaugeQuantity=None, ReadingQuantity=None, TankWaterQuantity=None, TankWaterMeasure=None, TankTemperature=None, AdjustedRoofQuantity=None, CorrectedTemperatureLiquidFactor=None, PartnerDefinedMeasure=None):
        self.AdjustmentQuantity = AdjustmentQuantity
        self.AmbientTemperature = AmbientTemperature
        self.APIGravity = APIGravity
        self.CorrectedQuantity = CorrectedQuantity
        self.CorrectedGravity = CorrectedGravity
        self.TankDateTime = TankDateTime
        self.GaugeReadingMeasure = GaugeReadingMeasure
        self.GaugeQuantity = GaugeQuantity
        self.ReadingQuantity = ReadingQuantity
        self.TankWaterQuantity = TankWaterQuantity
        self.TankWaterMeasure = TankWaterMeasure
        self.TankTemperature = TankTemperature
        self.AdjustedRoofQuantity = AdjustedRoofQuantity
        self.CorrectedTemperatureLiquidFactor = CorrectedTemperatureLiquidFactor
        if PartnerDefinedMeasure is None:
            self.PartnerDefinedMeasure = []
        else:
            self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def factory(*args_, **kwargs_):
        if TankOpenMeasures.subclass:
            return TankOpenMeasures.subclass(*args_, **kwargs_)
        else:
            return TankOpenMeasures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdjustmentQuantity(self): return self.AdjustmentQuantity
    def set_AdjustmentQuantity(self, AdjustmentQuantity): self.AdjustmentQuantity = AdjustmentQuantity
    def get_AmbientTemperature(self): return self.AmbientTemperature
    def set_AmbientTemperature(self, AmbientTemperature): self.AmbientTemperature = AmbientTemperature
    def get_APIGravity(self): return self.APIGravity
    def set_APIGravity(self, APIGravity): self.APIGravity = APIGravity
    def get_CorrectedQuantity(self): return self.CorrectedQuantity
    def set_CorrectedQuantity(self, CorrectedQuantity): self.CorrectedQuantity = CorrectedQuantity
    def get_CorrectedGravity(self): return self.CorrectedGravity
    def set_CorrectedGravity(self, CorrectedGravity): self.CorrectedGravity = CorrectedGravity
    def get_TankDateTime(self): return self.TankDateTime
    def set_TankDateTime(self, TankDateTime): self.TankDateTime = TankDateTime
    def get_GaugeReadingMeasure(self): return self.GaugeReadingMeasure
    def set_GaugeReadingMeasure(self, GaugeReadingMeasure): self.GaugeReadingMeasure = GaugeReadingMeasure
    def get_GaugeQuantity(self): return self.GaugeQuantity
    def set_GaugeQuantity(self, GaugeQuantity): self.GaugeQuantity = GaugeQuantity
    def get_ReadingQuantity(self): return self.ReadingQuantity
    def set_ReadingQuantity(self, ReadingQuantity): self.ReadingQuantity = ReadingQuantity
    def get_TankWaterQuantity(self): return self.TankWaterQuantity
    def set_TankWaterQuantity(self, TankWaterQuantity): self.TankWaterQuantity = TankWaterQuantity
    def get_TankWaterMeasure(self): return self.TankWaterMeasure
    def set_TankWaterMeasure(self, TankWaterMeasure): self.TankWaterMeasure = TankWaterMeasure
    def get_TankTemperature(self): return self.TankTemperature
    def set_TankTemperature(self, TankTemperature): self.TankTemperature = TankTemperature
    def get_AdjustedRoofQuantity(self): return self.AdjustedRoofQuantity
    def set_AdjustedRoofQuantity(self, AdjustedRoofQuantity): self.AdjustedRoofQuantity = AdjustedRoofQuantity
    def get_CorrectedTemperatureLiquidFactor(self): return self.CorrectedTemperatureLiquidFactor
    def set_CorrectedTemperatureLiquidFactor(self, CorrectedTemperatureLiquidFactor): self.CorrectedTemperatureLiquidFactor = CorrectedTemperatureLiquidFactor
    def get_PartnerDefinedMeasure(self): return self.PartnerDefinedMeasure
    def set_PartnerDefinedMeasure(self, PartnerDefinedMeasure): self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def add_PartnerDefinedMeasure(self, value): self.PartnerDefinedMeasure.append(value)
    def insert_PartnerDefinedMeasure(self, index, value): self.PartnerDefinedMeasure[index] = value
    def hasContent_(self):
        if (
            self.AdjustmentQuantity is not None or
            self.AmbientTemperature is not None or
            self.APIGravity is not None or
            self.CorrectedQuantity is not None or
            self.CorrectedGravity is not None or
            self.TankDateTime is not None or
            self.GaugeReadingMeasure is not None or
            self.GaugeQuantity is not None or
            self.ReadingQuantity is not None or
            self.TankWaterQuantity is not None or
            self.TankWaterMeasure is not None or
            self.TankTemperature is not None or
            self.AdjustedRoofQuantity is not None or
            self.CorrectedTemperatureLiquidFactor is not None or
            self.PartnerDefinedMeasure
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TankOpenMeasures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankOpenMeasures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TankOpenMeasures'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TankOpenMeasures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdjustmentQuantity is not None:
            self.AdjustmentQuantity.export(outfile, level, namespace_, name_='AdjustmentQuantity', pretty_print=pretty_print)
        if self.AmbientTemperature is not None:
            self.AmbientTemperature.export(outfile, level, namespace_, name_='AmbientTemperature', pretty_print=pretty_print)
        if self.APIGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAPIGravity>%s</%sAPIGravity>%s' % (namespace_, self.gds_format_float(self.APIGravity, input_name='APIGravity'), namespace_, eol_))
        if self.CorrectedQuantity is not None:
            self.CorrectedQuantity.export(outfile, level, namespace_, name_='CorrectedQuantity', pretty_print=pretty_print)
        if self.CorrectedGravity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedGravity>%s</%sCorrectedGravity>%s' % (namespace_, self.gds_format_float(self.CorrectedGravity, input_name='CorrectedGravity'), namespace_, eol_))
        if self.TankDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTankDateTime>%s</%sTankDateTime>%s' % (namespace_, self.gds_format_datetime(self.TankDateTime, input_name='TankDateTime'), namespace_, eol_))
        if self.GaugeReadingMeasure is not None:
            self.GaugeReadingMeasure.export(outfile, level, namespace_, name_='GaugeReadingMeasure', pretty_print=pretty_print)
        if self.GaugeQuantity is not None:
            self.GaugeQuantity.export(outfile, level, namespace_, name_='GaugeQuantity', pretty_print=pretty_print)
        if self.ReadingQuantity is not None:
            self.ReadingQuantity.export(outfile, level, namespace_, name_='ReadingQuantity', pretty_print=pretty_print)
        if self.TankWaterQuantity is not None:
            self.TankWaterQuantity.export(outfile, level, namespace_, name_='TankWaterQuantity', pretty_print=pretty_print)
        if self.TankWaterMeasure is not None:
            self.TankWaterMeasure.export(outfile, level, namespace_, name_='TankWaterMeasure', pretty_print=pretty_print)
        if self.TankTemperature is not None:
            self.TankTemperature.export(outfile, level, namespace_, name_='TankTemperature', pretty_print=pretty_print)
        if self.AdjustedRoofQuantity is not None:
            self.AdjustedRoofQuantity.export(outfile, level, namespace_, name_='AdjustedRoofQuantity', pretty_print=pretty_print)
        if self.CorrectedTemperatureLiquidFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectedTemperatureLiquidFactor>%s</%sCorrectedTemperatureLiquidFactor>%s' % (namespace_, self.gds_format_float(self.CorrectedTemperatureLiquidFactor, input_name='CorrectedTemperatureLiquidFactor'), namespace_, eol_))
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            PartnerDefinedMeasure_.export(outfile, level, namespace_, name_='PartnerDefinedMeasure', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TankOpenMeasures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AdjustmentQuantity is not None:
            showIndent(outfile, level)
            outfile.write('AdjustmentQuantity=model_.AdjustmentQuantity(\n')
            self.AdjustmentQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AmbientTemperature is not None:
            showIndent(outfile, level)
            outfile.write('AmbientTemperature=model_.AmbientTemperature(\n')
            self.AmbientTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.APIGravity is not None:
            showIndent(outfile, level)
            outfile.write('APIGravity=%f,\n' % self.APIGravity)
        if self.CorrectedQuantity is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedQuantity=model_.CorrectedQuantity(\n')
            self.CorrectedQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrectedGravity is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedGravity=%f,\n' % self.CorrectedGravity)
        if self.TankDateTime is not None:
            showIndent(outfile, level)
            outfile.write('TankDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.TankDateTime, input_name='TankDateTime'))
        if self.GaugeReadingMeasure is not None:
            showIndent(outfile, level)
            outfile.write('GaugeReadingMeasure=model_.GaugeReadingMeasure(\n')
            self.GaugeReadingMeasure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaugeQuantity is not None:
            showIndent(outfile, level)
            outfile.write('GaugeQuantity=model_.GaugeQuantity(\n')
            self.GaugeQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingQuantity is not None:
            showIndent(outfile, level)
            outfile.write('ReadingQuantity=model_.ReadingQuantity(\n')
            self.ReadingQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankWaterQuantity is not None:
            showIndent(outfile, level)
            outfile.write('TankWaterQuantity=model_.TankWaterQuantity(\n')
            self.TankWaterQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankWaterMeasure is not None:
            showIndent(outfile, level)
            outfile.write('TankWaterMeasure=model_.TankWaterMeasure(\n')
            self.TankWaterMeasure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TankTemperature is not None:
            showIndent(outfile, level)
            outfile.write('TankTemperature=model_.TankTemperature(\n')
            self.TankTemperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AdjustedRoofQuantity is not None:
            showIndent(outfile, level)
            outfile.write('AdjustedRoofQuantity=model_.AdjustedRoofQuantity(\n')
            self.AdjustedRoofQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrectedTemperatureLiquidFactor is not None:
            showIndent(outfile, level)
            outfile.write('CorrectedTemperatureLiquidFactor=%f,\n' % self.CorrectedTemperatureLiquidFactor)
        showIndent(outfile, level)
        outfile.write('PartnerDefinedMeasure=[\n')
        level += 1
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            showIndent(outfile, level)
            outfile.write('model_.PartnerDefinedMeasure(\n')
            PartnerDefinedMeasure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdjustmentQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_AdjustmentQuantity(obj_)
        elif nodeName_ == 'AmbientTemperature':
            obj_ = AmbientTemperature.factory()
            obj_.build(child_)
            self.set_AmbientTemperature(obj_)
        elif nodeName_ == 'APIGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'APIGravity')
            self.APIGravity = fval_
        elif nodeName_ == 'CorrectedQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_CorrectedQuantity(obj_)
        elif nodeName_ == 'CorrectedGravity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedGravity')
            self.CorrectedGravity = fval_
        elif nodeName_ == 'TankDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'TankDateTime')
            self.TankDateTime = dval_
        elif nodeName_ == 'GaugeReadingMeasure':
            obj_ = GaugeReadingMeasure.factory()
            obj_.build(child_)
            self.set_GaugeReadingMeasure(obj_)
        elif nodeName_ == 'GaugeQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_GaugeQuantity(obj_)
        elif nodeName_ == 'ReadingQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_ReadingQuantity(obj_)
        elif nodeName_ == 'TankWaterQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_TankWaterQuantity(obj_)
        elif nodeName_ == 'TankWaterMeasure':
            obj_ = TankWaterMeasure.factory()
            obj_.build(child_)
            self.set_TankWaterMeasure(obj_)
        elif nodeName_ == 'TankTemperature':
            obj_ = TankTemperature.factory()
            obj_.build(child_)
            self.set_TankTemperature(obj_)
        elif nodeName_ == 'AdjustedRoofQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_AdjustedRoofQuantity(obj_)
        elif nodeName_ == 'CorrectedTemperatureLiquidFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CorrectedTemperatureLiquidFactor')
            self.CorrectedTemperatureLiquidFactor = fval_
        elif nodeName_ == 'PartnerDefinedMeasure':
            obj_ = PartnerDefinedMeasure.factory()
            obj_.build(child_)
            self.PartnerDefinedMeasure.append(obj_)
# end class TankOpenMeasures


class TankTemperature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Temperature=None, UnitOfMeasureCode=None):
        self.Temperature = Temperature
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if TankTemperature.subclass:
            return TankTemperature.subclass(*args_, **kwargs_)
        else:
            return TankTemperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Temperature is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TankTemperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankTemperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TankTemperature'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TankTemperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TankTemperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Temperature is not None:
            showIndent(outfile, level)
            outfile.write('Temperature=model_.Temperature(\n')
            self.Temperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.set_Temperature(obj_)
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class TankTemperature


class TankWaterMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Measurement=None, UnitOfMeasureCode=None):
        self.Measurement = Measurement
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if TankWaterMeasure.subclass:
            return TankWaterMeasure.subclass(*args_, **kwargs_)
        else:
            return TankWaterMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measurement(self): return self.Measurement
    def set_Measurement(self, Measurement): self.Measurement = Measurement
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Measurement is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TankWaterMeasure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankWaterMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TankWaterMeasure'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TankWaterMeasure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Measurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurement>%s</%sMeasurement>%s' % (namespace_, self.gds_format_float(self.Measurement, input_name='Measurement'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TankWaterMeasure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Measurement is not None:
            showIndent(outfile, level)
            outfile.write('Measurement=%f,\n' % self.Measurement)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measurement')
            self.Measurement = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class TankWaterMeasure


class TargetCurrency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None):
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if TargetCurrency.subclass:
            return TargetCurrency.subclass(*args_, **kwargs_)
        else:
            return TargetCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TargetCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TargetCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TargetCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TargetCurrency'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class TargetCurrency


class TaxCertificateNumber(GeneratedsSuper):
    """The identifying number for a tax certificate such as tax exemption,
    sales and use tax certificate or other such document. Indicates
    which kind of tax certificate is being given."""
    subclass = None
    superclass = None
    def __init__(self, taxCertificateType=None, valueOf_=None):
        self.taxCertificateType = _cast(None, taxCertificateType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TaxCertificateNumber.subclass:
            return TaxCertificateNumber.subclass(*args_, **kwargs_)
        else:
            return TaxCertificateNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_taxCertificateType(self): return self.taxCertificateType
    def set_taxCertificateType(self, taxCertificateType): self.taxCertificateType = taxCertificateType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TaxCertificateNumber', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxCertificateNumber')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TaxCertificateNumber'):
        if self.taxCertificateType is not None and 'taxCertificateType' not in already_processed:
            already_processed.add('taxCertificateType')
            outfile.write(' taxCertificateType=%s' % (self.gds_format_string(quote_attrib(self.taxCertificateType).encode(ExternalEncoding), input_name='taxCertificateType'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TaxCertificateNumber', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TaxCertificateNumber'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.taxCertificateType is not None and 'taxCertificateType' not in already_processed:
            already_processed.add('taxCertificateType')
            showIndent(outfile, level)
            outfile.write('taxCertificateType = "%s",\n' % (self.taxCertificateType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('taxCertificateType', node)
        if value is not None and 'taxCertificateType' not in already_processed:
            already_processed.add('taxCertificateType')
            self.taxCertificateType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TaxCertificateNumber


class TaxIdentifierNumber(GeneratedsSuper):
    """Unique number or code issued to an organization by a governmental or
    regulatory body identifying that entity for tax purposes.
    Indicates the kind of tax."""
    subclass = None
    superclass = None
    def __init__(self, taxType=None, valueOf_=None):
        self.taxType = _cast(None, taxType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TaxIdentifierNumber.subclass:
            return TaxIdentifierNumber.subclass(*args_, **kwargs_)
        else:
            return TaxIdentifierNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_taxType(self): return self.taxType
    def set_taxType(self, taxType): self.taxType = taxType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TaxIdentifierNumber', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxIdentifierNumber')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TaxIdentifierNumber'):
        if self.taxType is not None and 'taxType' not in already_processed:
            already_processed.add('taxType')
            outfile.write(' taxType=%s' % (self.gds_format_string(quote_attrib(self.taxType).encode(ExternalEncoding), input_name='taxType'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TaxIdentifierNumber', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TaxIdentifierNumber'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.taxType is not None and 'taxType' not in already_processed:
            already_processed.add('taxType')
            showIndent(outfile, level)
            outfile.write('taxType = "%s",\n' % (self.taxType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('taxType', node)
        if value is not None and 'taxType' not in already_processed:
            already_processed.add('taxType')
            self.taxType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TaxIdentifierNumber


class TaxInformation(GeneratedsSuper):
    """Structure which contains information concerning tax data."""
    subclass = None
    superclass = None
    def __init__(self, TaxIdentifierNumber=None, Jurisdiction=None, TaxCertificateNumber=None, TaxBasisAmount=None, TaxRate=None, DateTimeRange=None, TaxCertificateType=None):
        self.TaxIdentifierNumber = TaxIdentifierNumber
        self.Jurisdiction = Jurisdiction
        self.TaxCertificateNumber = TaxCertificateNumber
        self.TaxBasisAmount = TaxBasisAmount
        self.TaxRate = TaxRate
        self.DateTimeRange = DateTimeRange
        self.TaxCertificateType = TaxCertificateType
    def factory(*args_, **kwargs_):
        if TaxInformation.subclass:
            return TaxInformation.subclass(*args_, **kwargs_)
        else:
            return TaxInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxIdentifierNumber(self): return self.TaxIdentifierNumber
    def set_TaxIdentifierNumber(self, TaxIdentifierNumber): self.TaxIdentifierNumber = TaxIdentifierNumber
    def get_Jurisdiction(self): return self.Jurisdiction
    def set_Jurisdiction(self, Jurisdiction): self.Jurisdiction = Jurisdiction
    def get_TaxCertificateNumber(self): return self.TaxCertificateNumber
    def set_TaxCertificateNumber(self, TaxCertificateNumber): self.TaxCertificateNumber = TaxCertificateNumber
    def get_TaxBasisAmount(self): return self.TaxBasisAmount
    def set_TaxBasisAmount(self, TaxBasisAmount): self.TaxBasisAmount = TaxBasisAmount
    def get_TaxRate(self): return self.TaxRate
    def set_TaxRate(self, TaxRate): self.TaxRate = TaxRate
    def get_DateTimeRange(self): return self.DateTimeRange
    def set_DateTimeRange(self, DateTimeRange): self.DateTimeRange = DateTimeRange
    def get_TaxCertificateType(self): return self.TaxCertificateType
    def set_TaxCertificateType(self, TaxCertificateType): self.TaxCertificateType = TaxCertificateType
    def hasContent_(self):
        if (
            self.TaxIdentifierNumber is not None or
            self.Jurisdiction is not None or
            self.TaxCertificateNumber is not None or
            self.TaxBasisAmount is not None or
            self.TaxRate is not None or
            self.DateTimeRange is not None or
            self.TaxCertificateType is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TaxInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TaxInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TaxInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxIdentifierNumber is not None:
            self.TaxIdentifierNumber.export(outfile, level, namespace_, name_='TaxIdentifierNumber', pretty_print=pretty_print)
        if self.Jurisdiction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJurisdiction>%s</%sJurisdiction>%s' % (namespace_, self.gds_format_string(quote_xml(self.Jurisdiction).encode(ExternalEncoding), input_name='Jurisdiction'), namespace_, eol_))
        if self.TaxCertificateNumber is not None:
            self.TaxCertificateNumber.export(outfile, level, namespace_, name_='TaxCertificateNumber', pretty_print=pretty_print)
        if self.TaxBasisAmount is not None:
            self.TaxBasisAmount.export(outfile, level, namespace_, name_='TaxBasisAmount', pretty_print=pretty_print)
        if self.TaxRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxRate>%s</%sTaxRate>%s' % (namespace_, self.gds_format_float(self.TaxRate, input_name='TaxRate'), namespace_, eol_))
        if self.DateTimeRange is not None:
            self.DateTimeRange.export(outfile, level, namespace_, name_='DateTimeRange', pretty_print=pretty_print)
        if self.TaxCertificateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxCertificateType>%s</%sTaxCertificateType>%s' % (namespace_, self.gds_format_string(quote_xml(self.TaxCertificateType).encode(ExternalEncoding), input_name='TaxCertificateType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TaxInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TaxIdentifierNumber is not None:
            showIndent(outfile, level)
            outfile.write('TaxIdentifierNumber=model_.TaxIdentifierNumber(\n')
            self.TaxIdentifierNumber.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Jurisdiction is not None:
            showIndent(outfile, level)
            outfile.write('Jurisdiction=%s,\n' % quote_python(self.Jurisdiction).encode(ExternalEncoding))
        if self.TaxCertificateNumber is not None:
            showIndent(outfile, level)
            outfile.write('TaxCertificateNumber=model_.TaxCertificateNumber(\n')
            self.TaxCertificateNumber.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxBasisAmount is not None:
            showIndent(outfile, level)
            outfile.write('TaxBasisAmount=model_.TaxBasisAmount(\n')
            self.TaxBasisAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxRate is not None:
            showIndent(outfile, level)
            outfile.write('TaxRate=%f,\n' % self.TaxRate)
        if self.DateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('DateTimeRange=model_.DateTimeRange(\n')
            self.DateTimeRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxCertificateType is not None:
            showIndent(outfile, level)
            outfile.write('TaxCertificateType=%s,\n' % quote_python(self.TaxCertificateType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxIdentifierNumber':
            obj_ = TaxIdentifierNumber.factory()
            obj_.build(child_)
            self.set_TaxIdentifierNumber(obj_)
        elif nodeName_ == 'Jurisdiction':
            Jurisdiction_ = child_.text
            Jurisdiction_ = self.gds_validate_string(Jurisdiction_, node, 'Jurisdiction')
            self.Jurisdiction = Jurisdiction_
        elif nodeName_ == 'TaxCertificateNumber':
            obj_ = TaxCertificateNumber.factory()
            obj_.build(child_)
            self.set_TaxCertificateNumber(obj_)
        elif nodeName_ == 'TaxBasisAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_TaxBasisAmount(obj_)
        elif nodeName_ == 'TaxRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxRate')
            self.TaxRate = fval_
        elif nodeName_ == 'DateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_DateTimeRange(obj_)
        elif nodeName_ == 'TaxCertificateType':
            TaxCertificateType_ = child_.text
            TaxCertificateType_ = self.gds_validate_string(TaxCertificateType_, node, 'TaxCertificateType')
            self.TaxCertificateType = TaxCertificateType_
# end class TaxInformation


class TaxLocation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocationIdentifier=None, LocationName=None, LocationDescription=None, AddressInformation=None):
        self.LocationIdentifier = LocationIdentifier
        self.LocationName = LocationName
        self.LocationDescription = LocationDescription
        self.AddressInformation = AddressInformation
    def factory(*args_, **kwargs_):
        if TaxLocation.subclass:
            return TaxLocation.subclass(*args_, **kwargs_)
        else:
            return TaxLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocationIdentifier(self): return self.LocationIdentifier
    def set_LocationIdentifier(self, LocationIdentifier): self.LocationIdentifier = LocationIdentifier
    def get_LocationName(self): return self.LocationName
    def set_LocationName(self, LocationName): self.LocationName = LocationName
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def hasContent_(self):
        if (
            self.LocationIdentifier is not None or
            self.LocationName is not None or
            self.LocationDescription is not None or
            self.AddressInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TaxLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxLocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TaxLocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TaxLocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocationIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationIdentifier>%s</%sLocationIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationIdentifier).encode(ExternalEncoding), input_name='LocationIdentifier'), namespace_, eol_))
        if self.LocationName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationName>%s</%sLocationName>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationName).encode(ExternalEncoding), input_name='LocationName'), namespace_, eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationDescription>%s</%sLocationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocationDescription).encode(ExternalEncoding), input_name='LocationDescription'), namespace_, eol_))
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TaxLocation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LocationIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('LocationIdentifier=%s,\n' % quote_python(self.LocationIdentifier).encode(ExternalEncoding))
        if self.LocationName is not None:
            showIndent(outfile, level)
            outfile.write('LocationName=%s,\n' % quote_python(self.LocationName).encode(ExternalEncoding))
        if self.LocationDescription is not None:
            showIndent(outfile, level)
            outfile.write('LocationDescription=%s,\n' % quote_python(self.LocationDescription).encode(ExternalEncoding))
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocationIdentifier':
            LocationIdentifier_ = child_.text
            LocationIdentifier_ = self.gds_validate_string(LocationIdentifier_, node, 'LocationIdentifier')
            self.LocationIdentifier = LocationIdentifier_
        elif nodeName_ == 'LocationName':
            LocationName_ = child_.text
            LocationName_ = self.gds_validate_string(LocationName_, node, 'LocationName')
            self.LocationName = LocationName_
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
        elif nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
# end class TaxLocation


class Telephone(GeneratedsSuper):
    """Structure which contains the information about a telephone number."""
    subclass = None
    superclass = None
    def __init__(self, telephoneIndicator=None, PhoneNumber=None, PhoneNumberExtension=None, TelecomCountryCode=None, TelecomAreaCode=None):
        self.telephoneIndicator = _cast(None, telephoneIndicator)
        self.PhoneNumber = PhoneNumber
        self.PhoneNumberExtension = PhoneNumberExtension
        self.TelecomCountryCode = TelecomCountryCode
        self.TelecomAreaCode = TelecomAreaCode
    def factory(*args_, **kwargs_):
        if Telephone.subclass:
            return Telephone.subclass(*args_, **kwargs_)
        else:
            return Telephone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def get_PhoneNumberExtension(self): return self.PhoneNumberExtension
    def set_PhoneNumberExtension(self, PhoneNumberExtension): self.PhoneNumberExtension = PhoneNumberExtension
    def get_TelecomCountryCode(self): return self.TelecomCountryCode
    def set_TelecomCountryCode(self, TelecomCountryCode): self.TelecomCountryCode = TelecomCountryCode
    def get_TelecomAreaCode(self): return self.TelecomAreaCode
    def set_TelecomAreaCode(self, TelecomAreaCode): self.TelecomAreaCode = TelecomAreaCode
    def get_telephoneIndicator(self): return self.telephoneIndicator
    def set_telephoneIndicator(self, telephoneIndicator): self.telephoneIndicator = telephoneIndicator
    def hasContent_(self):
        if (
            self.PhoneNumber is not None or
            self.PhoneNumberExtension is not None or
            self.TelecomCountryCode is not None or
            self.TelecomAreaCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Telephone', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Telephone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Telephone'):
        if self.telephoneIndicator is not None and 'telephoneIndicator' not in already_processed:
            already_processed.add('telephoneIndicator')
            outfile.write(' telephoneIndicator=%s' % (quote_attrib(self.telephoneIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Telephone', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhoneNumber>%s</%sPhoneNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.PhoneNumber).encode(ExternalEncoding), input_name='PhoneNumber'), namespace_, eol_))
        if self.PhoneNumberExtension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhoneNumberExtension>%s</%sPhoneNumberExtension>%s' % (namespace_, self.gds_format_string(quote_xml(self.PhoneNumberExtension).encode(ExternalEncoding), input_name='PhoneNumberExtension'), namespace_, eol_))
        if self.TelecomCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTelecomCountryCode>%s</%sTelecomCountryCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TelecomCountryCode).encode(ExternalEncoding), input_name='TelecomCountryCode'), namespace_, eol_))
        if self.TelecomAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTelecomAreaCode>%s</%sTelecomAreaCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TelecomAreaCode).encode(ExternalEncoding), input_name='TelecomAreaCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Telephone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.telephoneIndicator is not None and 'telephoneIndicator' not in already_processed:
            already_processed.add('telephoneIndicator')
            showIndent(outfile, level)
            outfile.write('telephoneIndicator = %s,\n' % (self.telephoneIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PhoneNumber is not None:
            showIndent(outfile, level)
            outfile.write('PhoneNumber=%s,\n' % quote_python(self.PhoneNumber).encode(ExternalEncoding))
        if self.PhoneNumberExtension is not None:
            showIndent(outfile, level)
            outfile.write('PhoneNumberExtension=%s,\n' % quote_python(self.PhoneNumberExtension).encode(ExternalEncoding))
        if self.TelecomCountryCode is not None:
            showIndent(outfile, level)
            outfile.write('TelecomCountryCode=%s,\n' % quote_python(self.TelecomCountryCode).encode(ExternalEncoding))
        if self.TelecomAreaCode is not None:
            showIndent(outfile, level)
            outfile.write('TelecomAreaCode=%s,\n' % quote_python(self.TelecomAreaCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('telephoneIndicator', node)
        if value is not None and 'telephoneIndicator' not in already_processed:
            already_processed.add('telephoneIndicator')
            self.telephoneIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PhoneNumber':
            PhoneNumber_ = child_.text
            PhoneNumber_ = self.gds_validate_string(PhoneNumber_, node, 'PhoneNumber')
            self.PhoneNumber = PhoneNumber_
        elif nodeName_ == 'PhoneNumberExtension':
            PhoneNumberExtension_ = child_.text
            PhoneNumberExtension_ = self.gds_validate_string(PhoneNumberExtension_, node, 'PhoneNumberExtension')
            self.PhoneNumberExtension = PhoneNumberExtension_
        elif nodeName_ == 'TelecomCountryCode':
            TelecomCountryCode_ = child_.text
            TelecomCountryCode_ = self.gds_validate_string(TelecomCountryCode_, node, 'TelecomCountryCode')
            self.TelecomCountryCode = TelecomCountryCode_
        elif nodeName_ == 'TelecomAreaCode':
            TelecomAreaCode_ = child_.text
            TelecomAreaCode_ = self.gds_validate_string(TelecomAreaCode_, node, 'TelecomAreaCode')
            self.TelecomAreaCode = TelecomAreaCode_
# end class Telephone


class Temperature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TemperatureUnitOfMeasurement=None, valueOf_=None):
        self.TemperatureUnitOfMeasurement = _cast(None, TemperatureUnitOfMeasurement)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Temperature.subclass:
            return Temperature.subclass(*args_, **kwargs_)
        else:
            return Temperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TemperatureUnitOfMeasurement(self): return self.TemperatureUnitOfMeasurement
    def set_TemperatureUnitOfMeasurement(self, TemperatureUnitOfMeasurement): self.TemperatureUnitOfMeasurement = TemperatureUnitOfMeasurement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='Temperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Temperature')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='Temperature'):
        if self.TemperatureUnitOfMeasurement is not None and 'TemperatureUnitOfMeasurement' not in already_processed:
            already_processed.add('TemperatureUnitOfMeasurement')
            outfile.write(' TemperatureUnitOfMeasurement=%s' % (quote_attrib(self.TemperatureUnitOfMeasurement), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='Temperature', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Temperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TemperatureUnitOfMeasurement is not None and 'TemperatureUnitOfMeasurement' not in already_processed:
            already_processed.add('TemperatureUnitOfMeasurement')
            showIndent(outfile, level)
            outfile.write('TemperatureUnitOfMeasurement = %s,\n' % (self.TemperatureUnitOfMeasurement,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TemperatureUnitOfMeasurement', node)
        if value is not None and 'TemperatureUnitOfMeasurement' not in already_processed:
            already_processed.add('TemperatureUnitOfMeasurement')
            self.TemperatureUnitOfMeasurement = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Temperature


class TransportInformation(GeneratedsSuper):
    """Structure containing information defining how product is
    transported.Identifies the stage of the shipping route."""
    subclass = None
    superclass = None
    def __init__(self, stageIdentifier=None, ShipmentMethodOfPayment=None, RoutingSequenceCode=None, TransportMethodCode=None, PartnerInformation=None, Location=None, ShipmentTermsCode=None, Routing=None, ServiceLevelCode=None, HazardousMaterials=None, CarrierEquipmentCode=None, TransportName=None, TransportMethod=None, DocumentReference=None):
        self.stageIdentifier = _cast(None, stageIdentifier)
        self.ShipmentMethodOfPayment = ShipmentMethodOfPayment
        self.RoutingSequenceCode = RoutingSequenceCode
        self.TransportMethodCode = TransportMethodCode
        if PartnerInformation is None:
            self.PartnerInformation = []
        else:
            self.PartnerInformation = PartnerInformation
        if Location is None:
            self.Location = []
        else:
            self.Location = Location
        self.ShipmentTermsCode = ShipmentTermsCode
        self.Routing = Routing
        self.ServiceLevelCode = ServiceLevelCode
        self.HazardousMaterials = HazardousMaterials
        self.CarrierEquipmentCode = CarrierEquipmentCode
        self.TransportName = TransportName
        self.TransportMethod = TransportMethod
        if DocumentReference is None:
            self.DocumentReference = []
        else:
            self.DocumentReference = DocumentReference
    def factory(*args_, **kwargs_):
        if TransportInformation.subclass:
            return TransportInformation.subclass(*args_, **kwargs_)
        else:
            return TransportInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipmentMethodOfPayment(self): return self.ShipmentMethodOfPayment
    def set_ShipmentMethodOfPayment(self, ShipmentMethodOfPayment): self.ShipmentMethodOfPayment = ShipmentMethodOfPayment
    def get_RoutingSequenceCode(self): return self.RoutingSequenceCode
    def set_RoutingSequenceCode(self, RoutingSequenceCode): self.RoutingSequenceCode = RoutingSequenceCode
    def get_TransportMethodCode(self): return self.TransportMethodCode
    def set_TransportMethodCode(self, TransportMethodCode): self.TransportMethodCode = TransportMethodCode
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def add_PartnerInformation(self, value): self.PartnerInformation.append(value)
    def insert_PartnerInformation(self, index, value): self.PartnerInformation[index] = value
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def add_Location(self, value): self.Location.append(value)
    def insert_Location(self, index, value): self.Location[index] = value
    def get_ShipmentTermsCode(self): return self.ShipmentTermsCode
    def set_ShipmentTermsCode(self, ShipmentTermsCode): self.ShipmentTermsCode = ShipmentTermsCode
    def get_Routing(self): return self.Routing
    def set_Routing(self, Routing): self.Routing = Routing
    def get_ServiceLevelCode(self): return self.ServiceLevelCode
    def set_ServiceLevelCode(self, ServiceLevelCode): self.ServiceLevelCode = ServiceLevelCode
    def get_HazardousMaterials(self): return self.HazardousMaterials
    def set_HazardousMaterials(self, HazardousMaterials): self.HazardousMaterials = HazardousMaterials
    def get_CarrierEquipmentCode(self): return self.CarrierEquipmentCode
    def set_CarrierEquipmentCode(self, CarrierEquipmentCode): self.CarrierEquipmentCode = CarrierEquipmentCode
    def get_TransportName(self): return self.TransportName
    def set_TransportName(self, TransportName): self.TransportName = TransportName
    def get_TransportMethod(self): return self.TransportMethod
    def set_TransportMethod(self, TransportMethod): self.TransportMethod = TransportMethod
    def get_DocumentReference(self): return self.DocumentReference
    def set_DocumentReference(self, DocumentReference): self.DocumentReference = DocumentReference
    def add_DocumentReference(self, value): self.DocumentReference.append(value)
    def insert_DocumentReference(self, index, value): self.DocumentReference[index] = value
    def get_stageIdentifier(self): return self.stageIdentifier
    def set_stageIdentifier(self, stageIdentifier): self.stageIdentifier = stageIdentifier
    def hasContent_(self):
        if (
            self.ShipmentMethodOfPayment is not None or
            self.RoutingSequenceCode is not None or
            self.TransportMethodCode is not None or
            self.PartnerInformation or
            self.Location or
            self.ShipmentTermsCode is not None or
            self.Routing is not None or
            self.ServiceLevelCode is not None or
            self.HazardousMaterials is not None or
            self.CarrierEquipmentCode is not None or
            self.TransportName is not None or
            self.TransportMethod is not None or
            self.DocumentReference
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TransportInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransportInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TransportInformation'):
        if self.stageIdentifier is not None and 'stageIdentifier' not in already_processed:
            already_processed.add('stageIdentifier')
            outfile.write(' stageIdentifier=%s' % (self.gds_format_string(quote_attrib(self.stageIdentifier).encode(ExternalEncoding), input_name='stageIdentifier'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TransportInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipmentMethodOfPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShipmentMethodOfPayment>%s</%sShipmentMethodOfPayment>%s' % (namespace_, self.gds_format_string(quote_xml(self.ShipmentMethodOfPayment).encode(ExternalEncoding), input_name='ShipmentMethodOfPayment'), namespace_, eol_))
        if self.RoutingSequenceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoutingSequenceCode>%s</%sRoutingSequenceCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.RoutingSequenceCode).encode(ExternalEncoding), input_name='RoutingSequenceCode'), namespace_, eol_))
        if self.TransportMethodCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportMethodCode>%s</%sTransportMethodCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransportMethodCode).encode(ExternalEncoding), input_name='TransportMethodCode'), namespace_, eol_))
        for PartnerInformation_ in self.PartnerInformation:
            PartnerInformation_.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
        for Location_ in self.Location:
            Location_.export(outfile, level, namespace_, name_='Location', pretty_print=pretty_print)
        if self.ShipmentTermsCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShipmentTermsCode>%s</%sShipmentTermsCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ShipmentTermsCode).encode(ExternalEncoding), input_name='ShipmentTermsCode'), namespace_, eol_))
        if self.Routing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRouting>%s</%sRouting>%s' % (namespace_, self.gds_format_string(quote_xml(self.Routing).encode(ExternalEncoding), input_name='Routing'), namespace_, eol_))
        if self.ServiceLevelCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sServiceLevelCode>%s</%sServiceLevelCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ServiceLevelCode).encode(ExternalEncoding), input_name='ServiceLevelCode'), namespace_, eol_))
        if self.HazardousMaterials is not None:
            self.HazardousMaterials.export(outfile, level, namespace_, name_='HazardousMaterials', pretty_print=pretty_print)
        if self.CarrierEquipmentCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCarrierEquipmentCode>%s</%sCarrierEquipmentCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CarrierEquipmentCode).encode(ExternalEncoding), input_name='CarrierEquipmentCode'), namespace_, eol_))
        if self.TransportName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportName>%s</%sTransportName>%s' % (namespace_, self.gds_format_string(quote_xml(self.TransportName).encode(ExternalEncoding), input_name='TransportName'), namespace_, eol_))
        if self.TransportMethod is not None:
            self.TransportMethod.export(outfile, level, namespace_, name_='TransportMethod', pretty_print=pretty_print)
        for DocumentReference_ in self.DocumentReference:
            DocumentReference_.export(outfile, level, namespace_, name_='DocumentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TransportInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.stageIdentifier is not None and 'stageIdentifier' not in already_processed:
            already_processed.add('stageIdentifier')
            showIndent(outfile, level)
            outfile.write('stageIdentifier = "%s",\n' % (self.stageIdentifier,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ShipmentMethodOfPayment is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentMethodOfPayment=%s,\n' % quote_python(self.ShipmentMethodOfPayment).encode(ExternalEncoding))
        if self.RoutingSequenceCode is not None:
            showIndent(outfile, level)
            outfile.write('RoutingSequenceCode=%s,\n' % quote_python(self.RoutingSequenceCode).encode(ExternalEncoding))
        if self.TransportMethodCode is not None:
            showIndent(outfile, level)
            outfile.write('TransportMethodCode=%s,\n' % quote_python(self.TransportMethodCode).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('PartnerInformation=[\n')
        level += 1
        for PartnerInformation_ in self.PartnerInformation:
            showIndent(outfile, level)
            outfile.write('model_.PartnerInformation(\n')
            PartnerInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Location=[\n')
        level += 1
        for Location_ in self.Location:
            showIndent(outfile, level)
            outfile.write('model_.Location(\n')
            Location_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ShipmentTermsCode is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentTermsCode=%s,\n' % quote_python(self.ShipmentTermsCode).encode(ExternalEncoding))
        if self.Routing is not None:
            showIndent(outfile, level)
            outfile.write('Routing=%s,\n' % quote_python(self.Routing).encode(ExternalEncoding))
        if self.ServiceLevelCode is not None:
            showIndent(outfile, level)
            outfile.write('ServiceLevelCode=%s,\n' % quote_python(self.ServiceLevelCode).encode(ExternalEncoding))
        if self.HazardousMaterials is not None:
            showIndent(outfile, level)
            outfile.write('HazardousMaterials=model_.HazardousMaterials(\n')
            self.HazardousMaterials.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CarrierEquipmentCode is not None:
            showIndent(outfile, level)
            outfile.write('CarrierEquipmentCode=%s,\n' % quote_python(self.CarrierEquipmentCode).encode(ExternalEncoding))
        if self.TransportName is not None:
            showIndent(outfile, level)
            outfile.write('TransportName=%s,\n' % quote_python(self.TransportName).encode(ExternalEncoding))
        if self.TransportMethod is not None:
            showIndent(outfile, level)
            outfile.write('TransportMethod=model_.TransportMethod(\n')
            self.TransportMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DocumentReference=[\n')
        level += 1
        for DocumentReference_ in self.DocumentReference:
            showIndent(outfile, level)
            outfile.write('model_.DocumentReference(\n')
            DocumentReference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('stageIdentifier', node)
        if value is not None and 'stageIdentifier' not in already_processed:
            already_processed.add('stageIdentifier')
            self.stageIdentifier = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipmentMethodOfPayment':
            ShipmentMethodOfPayment_ = child_.text
            ShipmentMethodOfPayment_ = self.gds_validate_string(ShipmentMethodOfPayment_, node, 'ShipmentMethodOfPayment')
            self.ShipmentMethodOfPayment = ShipmentMethodOfPayment_
        elif nodeName_ == 'RoutingSequenceCode':
            RoutingSequenceCode_ = child_.text
            RoutingSequenceCode_ = self.gds_validate_string(RoutingSequenceCode_, node, 'RoutingSequenceCode')
            self.RoutingSequenceCode = RoutingSequenceCode_
        elif nodeName_ == 'TransportMethodCode':
            TransportMethodCode_ = child_.text
            TransportMethodCode_ = self.gds_validate_string(TransportMethodCode_, node, 'TransportMethodCode')
            self.TransportMethodCode = TransportMethodCode_
        elif nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.PartnerInformation.append(obj_)
        elif nodeName_ == 'Location':
            obj_ = Location.factory()
            obj_.build(child_)
            self.Location.append(obj_)
        elif nodeName_ == 'ShipmentTermsCode':
            ShipmentTermsCode_ = child_.text
            ShipmentTermsCode_ = self.gds_validate_string(ShipmentTermsCode_, node, 'ShipmentTermsCode')
            self.ShipmentTermsCode = ShipmentTermsCode_
        elif nodeName_ == 'Routing':
            Routing_ = child_.text
            Routing_ = self.gds_validate_string(Routing_, node, 'Routing')
            self.Routing = Routing_
        elif nodeName_ == 'ServiceLevelCode':
            ServiceLevelCode_ = child_.text
            ServiceLevelCode_ = self.gds_validate_string(ServiceLevelCode_, node, 'ServiceLevelCode')
            self.ServiceLevelCode = ServiceLevelCode_
        elif nodeName_ == 'HazardousMaterials':
            obj_ = HazardousMaterials.factory()
            obj_.build(child_)
            self.set_HazardousMaterials(obj_)
        elif nodeName_ == 'CarrierEquipmentCode':
            CarrierEquipmentCode_ = child_.text
            CarrierEquipmentCode_ = self.gds_validate_string(CarrierEquipmentCode_, node, 'CarrierEquipmentCode')
            self.CarrierEquipmentCode = CarrierEquipmentCode_
        elif nodeName_ == 'TransportName':
            TransportName_ = child_.text
            TransportName_ = self.gds_validate_string(TransportName_, node, 'TransportName')
            self.TransportName = TransportName_
        elif nodeName_ == 'TransportMethod':
            obj_ = TransportMethod.factory()
            obj_.build(child_)
            self.set_TransportMethod(obj_)
        elif nodeName_ == 'DocumentReference':
            obj_ = DocumentReference.factory()
            obj_.build(child_)
            self.DocumentReference.append(obj_)
# end class TransportInformation


class TransportMethod(GeneratedsSuper):
    """Mode of transportation used to move product.Indicates the
    organizational body who assigned the list of codes"""
    subclass = None
    superclass = None
    def __init__(self, codeListName=None, valueOf_=None):
        self.codeListName = _cast(None, codeListName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TransportMethod.subclass:
            return TransportMethod.subclass(*args_, **kwargs_)
        else:
            return TransportMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeListName(self): return self.codeListName
    def set_codeListName(self, codeListName): self.codeListName = codeListName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TransportMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransportMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TransportMethod'):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            outfile.write(' codeListName=%s' % (self.gds_format_string(quote_attrib(self.codeListName).encode(ExternalEncoding), input_name='codeListName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TransportMethod', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TransportMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeListName is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            showIndent(outfile, level)
            outfile.write('codeListName = "%s",\n' % (self.codeListName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeListName', node)
        if value is not None and 'codeListName' not in already_processed:
            already_processed.add('codeListName')
            self.codeListName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TransportMethod


class UnitPrice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MonetaryAmount=None, UnitOfMeasureCode=None, CurrencyCode=None):
        self.MonetaryAmount = MonetaryAmount
        self.UnitOfMeasureCode = UnitOfMeasureCode
        self.CurrencyCode = CurrencyCode
    def factory(*args_, **kwargs_):
        if UnitPrice.subclass:
            return UnitPrice.subclass(*args_, **kwargs_)
        else:
            return UnitPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MonetaryAmount(self): return self.MonetaryAmount
    def set_MonetaryAmount(self, MonetaryAmount): self.MonetaryAmount = MonetaryAmount
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def hasContent_(self):
        if (
            self.MonetaryAmount is not None or
            self.UnitOfMeasureCode is not None or
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='UnitPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='UnitPrice'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='UnitPrice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MonetaryAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMonetaryAmount>%s</%sMonetaryAmount>%s' % (namespace_, self.gds_format_float(self.MonetaryAmount, input_name='MonetaryAmount'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UnitPrice'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MonetaryAmount is not None:
            showIndent(outfile, level)
            outfile.write('MonetaryAmount=%f,\n' % self.MonetaryAmount)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MonetaryAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MonetaryAmount')
            self.MonetaryAmount = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class UnitPrice


class ValidityDates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FromDate=None, ToDate=None):
        self.FromDate = FromDate
        self.ToDate = ToDate
    def factory(*args_, **kwargs_):
        if ValidityDates.subclass:
            return ValidityDates.subclass(*args_, **kwargs_)
        else:
            return ValidityDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FromDate(self): return self.FromDate
    def set_FromDate(self, FromDate): self.FromDate = FromDate
    def get_ToDate(self): return self.ToDate
    def set_ToDate(self, ToDate): self.ToDate = ToDate
    def hasContent_(self):
        if (
            self.FromDate is not None or
            self.ToDate is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ValidityDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidityDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ValidityDates'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ValidityDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FromDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromDate>%s</%sFromDate>%s' % (namespace_, self.gds_format_date(self.FromDate, input_name='FromDate'), namespace_, eol_))
        if self.ToDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToDate>%s</%sToDate>%s' % (namespace_, self.gds_format_date(self.ToDate, input_name='ToDate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ValidityDates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FromDate is not None:
            showIndent(outfile, level)
            outfile.write('FromDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.FromDate, input_name='FromDate'))
        if self.ToDate is not None:
            showIndent(outfile, level)
            outfile.write('ToDate=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.ToDate, input_name='ToDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FromDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'FromDate')
            self.FromDate = dval_
        elif nodeName_ == 'ToDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'ToDate')
            self.ToDate = dval_
# end class ValidityDates


class VesselMeasures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VesselType=None, VesselDescription=None, VesselPurged=None, VaporFactor=None, VesselCapacityQuantity=None, VolumeOutageQuantity=None, PurgedQuantity=None, PartnerDefinedMeasure=None):
        self.VesselType = VesselType
        self.VesselDescription = VesselDescription
        self.VesselPurged = VesselPurged
        self.VaporFactor = VaporFactor
        self.VesselCapacityQuantity = VesselCapacityQuantity
        self.VolumeOutageQuantity = VolumeOutageQuantity
        self.PurgedQuantity = PurgedQuantity
        if PartnerDefinedMeasure is None:
            self.PartnerDefinedMeasure = []
        else:
            self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def factory(*args_, **kwargs_):
        if VesselMeasures.subclass:
            return VesselMeasures.subclass(*args_, **kwargs_)
        else:
            return VesselMeasures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VesselType(self): return self.VesselType
    def set_VesselType(self, VesselType): self.VesselType = VesselType
    def validate_VesselType(self, value):
        # Validate type VesselType, a restriction on NMTOKEN.
        pass
    def get_VesselDescription(self): return self.VesselDescription
    def set_VesselDescription(self, VesselDescription): self.VesselDescription = VesselDescription
    def get_VesselPurged(self): return self.VesselPurged
    def set_VesselPurged(self, VesselPurged): self.VesselPurged = VesselPurged
    def get_VaporFactor(self): return self.VaporFactor
    def set_VaporFactor(self, VaporFactor): self.VaporFactor = VaporFactor
    def get_VesselCapacityQuantity(self): return self.VesselCapacityQuantity
    def set_VesselCapacityQuantity(self, VesselCapacityQuantity): self.VesselCapacityQuantity = VesselCapacityQuantity
    def get_VolumeOutageQuantity(self): return self.VolumeOutageQuantity
    def set_VolumeOutageQuantity(self, VolumeOutageQuantity): self.VolumeOutageQuantity = VolumeOutageQuantity
    def get_PurgedQuantity(self): return self.PurgedQuantity
    def set_PurgedQuantity(self, PurgedQuantity): self.PurgedQuantity = PurgedQuantity
    def get_PartnerDefinedMeasure(self): return self.PartnerDefinedMeasure
    def set_PartnerDefinedMeasure(self, PartnerDefinedMeasure): self.PartnerDefinedMeasure = PartnerDefinedMeasure
    def add_PartnerDefinedMeasure(self, value): self.PartnerDefinedMeasure.append(value)
    def insert_PartnerDefinedMeasure(self, index, value): self.PartnerDefinedMeasure[index] = value
    def hasContent_(self):
        if (
            self.VesselType is not None or
            self.VesselDescription is not None or
            self.VesselPurged is not None or
            self.VaporFactor is not None or
            self.VesselCapacityQuantity is not None or
            self.VolumeOutageQuantity is not None or
            self.PurgedQuantity is not None or
            self.PartnerDefinedMeasure
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='VesselMeasures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VesselMeasures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='VesselMeasures'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='VesselMeasures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VesselType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVesselType>%s</%sVesselType>%s' % (namespace_, self.gds_format_string(quote_xml(self.VesselType).encode(ExternalEncoding), input_name='VesselType'), namespace_, eol_))
        if self.VesselDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVesselDescription>%s</%sVesselDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.VesselDescription).encode(ExternalEncoding), input_name='VesselDescription'), namespace_, eol_))
        if self.VesselPurged is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVesselPurged>%s</%sVesselPurged>%s' % (namespace_, self.gds_format_string(quote_xml(self.VesselPurged).encode(ExternalEncoding), input_name='VesselPurged'), namespace_, eol_))
        if self.VaporFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVaporFactor>%s</%sVaporFactor>%s' % (namespace_, self.gds_format_float(self.VaporFactor, input_name='VaporFactor'), namespace_, eol_))
        if self.VesselCapacityQuantity is not None:
            self.VesselCapacityQuantity.export(outfile, level, namespace_, name_='VesselCapacityQuantity', pretty_print=pretty_print)
        if self.VolumeOutageQuantity is not None:
            self.VolumeOutageQuantity.export(outfile, level, namespace_, name_='VolumeOutageQuantity', pretty_print=pretty_print)
        if self.PurgedQuantity is not None:
            self.PurgedQuantity.export(outfile, level, namespace_, name_='PurgedQuantity', pretty_print=pretty_print)
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            PartnerDefinedMeasure_.export(outfile, level, namespace_, name_='PartnerDefinedMeasure', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VesselMeasures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VesselType is not None:
            showIndent(outfile, level)
            outfile.write('VesselType=%s,\n' % quote_python(self.VesselType).encode(ExternalEncoding))
        if self.VesselDescription is not None:
            showIndent(outfile, level)
            outfile.write('VesselDescription=%s,\n' % quote_python(self.VesselDescription).encode(ExternalEncoding))
        if self.VesselPurged is not None:
            showIndent(outfile, level)
            outfile.write('VesselPurged=%s,\n' % quote_python(self.VesselPurged).encode(ExternalEncoding))
        if self.VaporFactor is not None:
            showIndent(outfile, level)
            outfile.write('VaporFactor=%f,\n' % self.VaporFactor)
        if self.VesselCapacityQuantity is not None:
            showIndent(outfile, level)
            outfile.write('VesselCapacityQuantity=model_.VesselCapacityQuantity(\n')
            self.VesselCapacityQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VolumeOutageQuantity is not None:
            showIndent(outfile, level)
            outfile.write('VolumeOutageQuantity=model_.VolumeOutageQuantity(\n')
            self.VolumeOutageQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PurgedQuantity is not None:
            showIndent(outfile, level)
            outfile.write('PurgedQuantity=model_.PurgedQuantity(\n')
            self.PurgedQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('PartnerDefinedMeasure=[\n')
        level += 1
        for PartnerDefinedMeasure_ in self.PartnerDefinedMeasure:
            showIndent(outfile, level)
            outfile.write('model_.PartnerDefinedMeasure(\n')
            PartnerDefinedMeasure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VesselType':
            VesselType_ = child_.text
            VesselType_ = self.gds_validate_string(VesselType_, node, 'VesselType')
            self.VesselType = VesselType_
            self.validate_VesselType(self.VesselType)    # validate type VesselType
        elif nodeName_ == 'VesselDescription':
            VesselDescription_ = child_.text
            VesselDescription_ = self.gds_validate_string(VesselDescription_, node, 'VesselDescription')
            self.VesselDescription = VesselDescription_
        elif nodeName_ == 'VesselPurged':
            VesselPurged_ = child_.text
            VesselPurged_ = self.gds_validate_string(VesselPurged_, node, 'VesselPurged')
            self.VesselPurged = VesselPurged_
        elif nodeName_ == 'VaporFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'VaporFactor')
            self.VaporFactor = fval_
        elif nodeName_ == 'VesselCapacityQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_VesselCapacityQuantity(obj_)
        elif nodeName_ == 'VolumeOutageQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_VolumeOutageQuantity(obj_)
        elif nodeName_ == 'PurgedQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PurgedQuantity(obj_)
        elif nodeName_ == 'PartnerDefinedMeasure':
            obj_ = PartnerDefinedMeasure.factory()
            obj_.build(child_)
            self.PartnerDefinedMeasure.append(obj_)
# end class VesselMeasures


class WellInformation(GeneratedsSuper):
    """Structure which contains information about a well."""
    subclass = None
    superclass = None
    def __init__(self, WellIdentifier=None, WellName=None, WellType=None, WellCategory=None):
        if WellIdentifier is None:
            self.WellIdentifier = []
        else:
            self.WellIdentifier = WellIdentifier
        self.WellName = WellName
        self.WellType = WellType
        self.WellCategory = WellCategory
    def factory(*args_, **kwargs_):
        if WellInformation.subclass:
            return WellInformation.subclass(*args_, **kwargs_)
        else:
            return WellInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WellIdentifier(self): return self.WellIdentifier
    def set_WellIdentifier(self, WellIdentifier): self.WellIdentifier = WellIdentifier
    def add_WellIdentifier(self, value): self.WellIdentifier.append(value)
    def insert_WellIdentifier(self, index, value): self.WellIdentifier[index] = value
    def get_WellName(self): return self.WellName
    def set_WellName(self, WellName): self.WellName = WellName
    def get_WellType(self): return self.WellType
    def set_WellType(self, WellType): self.WellType = WellType
    def validate_WellType(self, value):
        # Validate type WellType, a restriction on NMTOKEN.
        pass
    def get_WellCategory(self): return self.WellCategory
    def set_WellCategory(self, WellCategory): self.WellCategory = WellCategory
    def hasContent_(self):
        if (
            self.WellIdentifier or
            self.WellName is not None or
            self.WellType is not None or
            self.WellCategory is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='WellInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WellInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='WellInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='WellInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WellIdentifier_ in self.WellIdentifier:
            WellIdentifier_.export(outfile, level, namespace_, name_='WellIdentifier', pretty_print=pretty_print)
        if self.WellName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellName>%s</%sWellName>%s' % (namespace_, self.gds_format_string(quote_xml(self.WellName).encode(ExternalEncoding), input_name='WellName'), namespace_, eol_))
        if self.WellType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellType>%s</%sWellType>%s' % (namespace_, self.gds_format_string(quote_xml(self.WellType).encode(ExternalEncoding), input_name='WellType'), namespace_, eol_))
        if self.WellCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWellCategory>%s</%sWellCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.WellCategory).encode(ExternalEncoding), input_name='WellCategory'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='WellInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('WellIdentifier=[\n')
        level += 1
        for WellIdentifier_ in self.WellIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.WellIdentifier(\n')
            WellIdentifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.WellName is not None:
            showIndent(outfile, level)
            outfile.write('WellName=%s,\n' % quote_python(self.WellName).encode(ExternalEncoding))
        if self.WellType is not None:
            showIndent(outfile, level)
            outfile.write('WellType=%s,\n' % quote_python(self.WellType).encode(ExternalEncoding))
        if self.WellCategory is not None:
            showIndent(outfile, level)
            outfile.write('WellCategory=%s,\n' % quote_python(self.WellCategory).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WellIdentifier':
            obj_ = WellIdentifierType.factory()
            obj_.build(child_)
            self.WellIdentifier.append(obj_)
        elif nodeName_ == 'WellName':
            WellName_ = child_.text
            WellName_ = self.gds_validate_string(WellName_, node, 'WellName')
            self.WellName = WellName_
        elif nodeName_ == 'WellType':
            WellType_ = child_.text
            WellType_ = self.gds_validate_string(WellType_, node, 'WellType')
            self.WellType = WellType_
            self.validate_WellType(self.WellType)    # validate type WellType
        elif nodeName_ == 'WellCategory':
            WellCategory_ = child_.text
            WellCategory_ = self.gds_validate_string(WellCategory_, node, 'WellCategory')
            self.WellCategory = WellCategory_
# end class WellInformation


class AdvancedShipNoticeLineItemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LineItemNumber=None, EquipmentDetailsLineNumber=None, RevisionNumber=None, ProductInformation=None, ShippedQuantity=None, OrderQuantity=None, InvoiceQuantity=None, PackagingQuantity=None, CumulativeTotalQuantity=None, LineItemText=None, DocumentReference=None, ShipmentIndicator=None, PartnerInformation=None, DateTimeRange=None, ShipmentTerms=None, ScheduleDateTime=None, ScheduleDateTimeRange=None, SpecialInstructions=None, RequestedDocument=None, Routing=None, CustomerSpecificInformation=None, PercentActive=None, ProductSubLineItems=None, PackagingInformation=None, Comment=None):
        self.LineItemNumber = LineItemNumber
        self.EquipmentDetailsLineNumber = EquipmentDetailsLineNumber
        self.RevisionNumber = RevisionNumber
        if ProductInformation is None:
            self.ProductInformation = []
        else:
            self.ProductInformation = ProductInformation
        self.ShippedQuantity = ShippedQuantity
        self.OrderQuantity = OrderQuantity
        self.InvoiceQuantity = InvoiceQuantity
        self.PackagingQuantity = PackagingQuantity
        self.CumulativeTotalQuantity = CumulativeTotalQuantity
        if LineItemText is None:
            self.LineItemText = []
        else:
            self.LineItemText = LineItemText
        if DocumentReference is None:
            self.DocumentReference = []
        else:
            self.DocumentReference = DocumentReference
        self.ShipmentIndicator = ShipmentIndicator
        if PartnerInformation is None:
            self.PartnerInformation = []
        else:
            self.PartnerInformation = PartnerInformation
        self.DateTimeRange = DateTimeRange
        self.ShipmentTerms = ShipmentTerms
        self.ScheduleDateTime = ScheduleDateTime
        self.ScheduleDateTimeRange = ScheduleDateTimeRange
        if SpecialInstructions is None:
            self.SpecialInstructions = []
        else:
            self.SpecialInstructions = SpecialInstructions
        if RequestedDocument is None:
            self.RequestedDocument = []
        else:
            self.RequestedDocument = RequestedDocument
        self.Routing = Routing
        if CustomerSpecificInformation is None:
            self.CustomerSpecificInformation = []
        else:
            self.CustomerSpecificInformation = CustomerSpecificInformation
        self.PercentActive = PercentActive
        if ProductSubLineItems is None:
            self.ProductSubLineItems = []
        else:
            self.ProductSubLineItems = ProductSubLineItems
        if PackagingInformation is None:
            self.PackagingInformation = []
        else:
            self.PackagingInformation = PackagingInformation
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AdvancedShipNoticeLineItemsType.subclass:
            return AdvancedShipNoticeLineItemsType.subclass(*args_, **kwargs_)
        else:
            return AdvancedShipNoticeLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineItemNumber(self): return self.LineItemNumber
    def set_LineItemNumber(self, LineItemNumber): self.LineItemNumber = LineItemNumber
    def get_EquipmentDetailsLineNumber(self): return self.EquipmentDetailsLineNumber
    def set_EquipmentDetailsLineNumber(self, EquipmentDetailsLineNumber): self.EquipmentDetailsLineNumber = EquipmentDetailsLineNumber
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def get_ProductInformation(self): return self.ProductInformation
    def set_ProductInformation(self, ProductInformation): self.ProductInformation = ProductInformation
    def add_ProductInformation(self, value): self.ProductInformation.append(value)
    def insert_ProductInformation(self, index, value): self.ProductInformation[index] = value
    def get_ShippedQuantity(self): return self.ShippedQuantity
    def set_ShippedQuantity(self, ShippedQuantity): self.ShippedQuantity = ShippedQuantity
    def get_OrderQuantity(self): return self.OrderQuantity
    def set_OrderQuantity(self, OrderQuantity): self.OrderQuantity = OrderQuantity
    def get_InvoiceQuantity(self): return self.InvoiceQuantity
    def set_InvoiceQuantity(self, InvoiceQuantity): self.InvoiceQuantity = InvoiceQuantity
    def get_PackagingQuantity(self): return self.PackagingQuantity
    def set_PackagingQuantity(self, PackagingQuantity): self.PackagingQuantity = PackagingQuantity
    def get_CumulativeTotalQuantity(self): return self.CumulativeTotalQuantity
    def set_CumulativeTotalQuantity(self, CumulativeTotalQuantity): self.CumulativeTotalQuantity = CumulativeTotalQuantity
    def get_LineItemText(self): return self.LineItemText
    def set_LineItemText(self, LineItemText): self.LineItemText = LineItemText
    def add_LineItemText(self, value): self.LineItemText.append(value)
    def insert_LineItemText(self, index, value): self.LineItemText[index] = value
    def get_DocumentReference(self): return self.DocumentReference
    def set_DocumentReference(self, DocumentReference): self.DocumentReference = DocumentReference
    def add_DocumentReference(self, value): self.DocumentReference.append(value)
    def insert_DocumentReference(self, index, value): self.DocumentReference[index] = value
    def get_ShipmentIndicator(self): return self.ShipmentIndicator
    def set_ShipmentIndicator(self, ShipmentIndicator): self.ShipmentIndicator = ShipmentIndicator
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def add_PartnerInformation(self, value): self.PartnerInformation.append(value)
    def insert_PartnerInformation(self, index, value): self.PartnerInformation[index] = value
    def get_DateTimeRange(self): return self.DateTimeRange
    def set_DateTimeRange(self, DateTimeRange): self.DateTimeRange = DateTimeRange
    def get_ShipmentTerms(self): return self.ShipmentTerms
    def set_ShipmentTerms(self, ShipmentTerms): self.ShipmentTerms = ShipmentTerms
    def get_ScheduleDateTime(self): return self.ScheduleDateTime
    def set_ScheduleDateTime(self, ScheduleDateTime): self.ScheduleDateTime = ScheduleDateTime
    def get_ScheduleDateTimeRange(self): return self.ScheduleDateTimeRange
    def set_ScheduleDateTimeRange(self, ScheduleDateTimeRange): self.ScheduleDateTimeRange = ScheduleDateTimeRange
    def get_SpecialInstructions(self): return self.SpecialInstructions
    def set_SpecialInstructions(self, SpecialInstructions): self.SpecialInstructions = SpecialInstructions
    def add_SpecialInstructions(self, value): self.SpecialInstructions.append(value)
    def insert_SpecialInstructions(self, index, value): self.SpecialInstructions[index] = value
    def get_RequestedDocument(self): return self.RequestedDocument
    def set_RequestedDocument(self, RequestedDocument): self.RequestedDocument = RequestedDocument
    def add_RequestedDocument(self, value): self.RequestedDocument.append(value)
    def insert_RequestedDocument(self, index, value): self.RequestedDocument[index] = value
    def get_Routing(self): return self.Routing
    def set_Routing(self, Routing): self.Routing = Routing
    def get_CustomerSpecificInformation(self): return self.CustomerSpecificInformation
    def set_CustomerSpecificInformation(self, CustomerSpecificInformation): self.CustomerSpecificInformation = CustomerSpecificInformation
    def add_CustomerSpecificInformation(self, value): self.CustomerSpecificInformation.append(value)
    def insert_CustomerSpecificInformation(self, index, value): self.CustomerSpecificInformation[index] = value
    def get_PercentActive(self): return self.PercentActive
    def set_PercentActive(self, PercentActive): self.PercentActive = PercentActive
    def get_ProductSubLineItems(self): return self.ProductSubLineItems
    def set_ProductSubLineItems(self, ProductSubLineItems): self.ProductSubLineItems = ProductSubLineItems
    def add_ProductSubLineItems(self, value): self.ProductSubLineItems.append(value)
    def insert_ProductSubLineItems(self, index, value): self.ProductSubLineItems[index] = value
    def get_PackagingInformation(self): return self.PackagingInformation
    def set_PackagingInformation(self, PackagingInformation): self.PackagingInformation = PackagingInformation
    def add_PackagingInformation(self, value): self.PackagingInformation.append(value)
    def insert_PackagingInformation(self, index, value): self.PackagingInformation[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.LineItemNumber is not None or
            self.EquipmentDetailsLineNumber is not None or
            self.RevisionNumber is not None or
            self.ProductInformation or
            self.ShippedQuantity is not None or
            self.OrderQuantity is not None or
            self.InvoiceQuantity is not None or
            self.PackagingQuantity is not None or
            self.CumulativeTotalQuantity is not None or
            self.LineItemText or
            self.DocumentReference or
            self.ShipmentIndicator is not None or
            self.PartnerInformation or
            self.DateTimeRange is not None or
            self.ShipmentTerms is not None or
            self.ScheduleDateTime is not None or
            self.ScheduleDateTimeRange is not None or
            self.SpecialInstructions or
            self.RequestedDocument or
            self.Routing is not None or
            self.CustomerSpecificInformation or
            self.PercentActive is not None or
            self.ProductSubLineItems or
            self.PackagingInformation or
            self.Comment
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AdvancedShipNoticeLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedShipNoticeLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AdvancedShipNoticeLineItemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AdvancedShipNoticeLineItemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LineItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemNumber>%s</%sLineItemNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemNumber).encode(ExternalEncoding), input_name='LineItemNumber'), namespace_, eol_))
        if self.EquipmentDetailsLineNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEquipmentDetailsLineNumber>%s</%sEquipmentDetailsLineNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.EquipmentDetailsLineNumber).encode(ExternalEncoding), input_name='EquipmentDetailsLineNumber'), namespace_, eol_))
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
        for ProductInformation_ in self.ProductInformation:
            ProductInformation_.export(outfile, level, namespace_, name_='ProductInformation', pretty_print=pretty_print)
        if self.ShippedQuantity is not None:
            self.ShippedQuantity.export(outfile, level, namespace_, name_='ShippedQuantity', pretty_print=pretty_print)
        if self.OrderQuantity is not None:
            self.OrderQuantity.export(outfile, level, namespace_, name_='OrderQuantity', pretty_print=pretty_print)
        if self.InvoiceQuantity is not None:
            self.InvoiceQuantity.export(outfile, level, namespace_, name_='InvoiceQuantity', pretty_print=pretty_print)
        if self.PackagingQuantity is not None:
            self.PackagingQuantity.export(outfile, level, namespace_, name_='PackagingQuantity', pretty_print=pretty_print)
        if self.CumulativeTotalQuantity is not None:
            self.CumulativeTotalQuantity.export(outfile, level, namespace_, name_='CumulativeTotalQuantity', pretty_print=pretty_print)
        for LineItemText_ in self.LineItemText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemText>%s</%sLineItemText>%s' % (namespace_, self.gds_format_string(quote_xml(LineItemText_).encode(ExternalEncoding), input_name='LineItemText'), namespace_, eol_))
        for DocumentReference_ in self.DocumentReference:
            DocumentReference_.export(outfile, level, namespace_, name_='DocumentReference', pretty_print=pretty_print)
        if self.ShipmentIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShipmentIndicator>%s</%sShipmentIndicator>%s' % (namespace_, self.gds_format_string(quote_xml(self.ShipmentIndicator).encode(ExternalEncoding), input_name='ShipmentIndicator'), namespace_, eol_))
        for PartnerInformation_ in self.PartnerInformation:
            PartnerInformation_.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
        if self.DateTimeRange is not None:
            self.DateTimeRange.export(outfile, level, namespace_, name_='DateTimeRange', pretty_print=pretty_print)
        if self.ShipmentTerms is not None:
            self.ShipmentTerms.export(outfile, level, namespace_, name_='ShipmentTerms', pretty_print=pretty_print)
        if self.ScheduleDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sScheduleDateTime>%s</%sScheduleDateTime>%s' % (namespace_, self.gds_format_datetime(self.ScheduleDateTime, input_name='ScheduleDateTime'), namespace_, eol_))
        if self.ScheduleDateTimeRange is not None:
            self.ScheduleDateTimeRange.export(outfile, level, namespace_, name_='ScheduleDateTimeRange', pretty_print=pretty_print)
        for SpecialInstructions_ in self.SpecialInstructions:
            SpecialInstructions_.export(outfile, level, namespace_, name_='SpecialInstructions', pretty_print=pretty_print)
        for RequestedDocument_ in self.RequestedDocument:
            RequestedDocument_.export(outfile, level, namespace_, name_='RequestedDocument', pretty_print=pretty_print)
        if self.Routing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRouting>%s</%sRouting>%s' % (namespace_, self.gds_format_string(quote_xml(self.Routing).encode(ExternalEncoding), input_name='Routing'), namespace_, eol_))
        for CustomerSpecificInformation_ in self.CustomerSpecificInformation:
            CustomerSpecificInformation_.export(outfile, level, namespace_, name_='CustomerSpecificInformation', pretty_print=pretty_print)
        if self.PercentActive is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentActive>%s</%sPercentActive>%s' % (namespace_, self.gds_format_float(self.PercentActive, input_name='PercentActive'), namespace_, eol_))
        for ProductSubLineItems_ in self.ProductSubLineItems:
            ProductSubLineItems_.export(outfile, level, namespace_, name_='ProductSubLineItems', pretty_print=pretty_print)
        for PackagingInformation_ in self.PackagingInformation:
            PackagingInformation_.export(outfile, level, namespace_, name_='PackagingInformation', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(Comment_).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AdvancedShipNoticeLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LineItemNumber is not None:
            showIndent(outfile, level)
            outfile.write('LineItemNumber=%s,\n' % quote_python(self.LineItemNumber).encode(ExternalEncoding))
        if self.EquipmentDetailsLineNumber is not None:
            showIndent(outfile, level)
            outfile.write('EquipmentDetailsLineNumber=%s,\n' % quote_python(self.EquipmentDetailsLineNumber).encode(ExternalEncoding))
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ProductInformation=[\n')
        level += 1
        for ProductInformation_ in self.ProductInformation:
            showIndent(outfile, level)
            outfile.write('model_.ProductInformation(\n')
            ProductInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ShippedQuantity is not None:
            showIndent(outfile, level)
            outfile.write('ShippedQuantity=model_.ShippedQuantity(\n')
            self.ShippedQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrderQuantity is not None:
            showIndent(outfile, level)
            outfile.write('OrderQuantity=model_.OrderQuantity(\n')
            self.OrderQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InvoiceQuantity is not None:
            showIndent(outfile, level)
            outfile.write('InvoiceQuantity=model_.InvoiceQuantity(\n')
            self.InvoiceQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PackagingQuantity is not None:
            showIndent(outfile, level)
            outfile.write('PackagingQuantity=model_.PackagingQuantity(\n')
            self.PackagingQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CumulativeTotalQuantity is not None:
            showIndent(outfile, level)
            outfile.write('CumulativeTotalQuantity=model_.CumulativeTotalQuantity(\n')
            self.CumulativeTotalQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('LineItemText=[\n')
        level += 1
        for LineItemText_ in self.LineItemText:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LineItemText_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentReference=[\n')
        level += 1
        for DocumentReference_ in self.DocumentReference:
            showIndent(outfile, level)
            outfile.write('model_.DocumentReference(\n')
            DocumentReference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ShipmentIndicator is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentIndicator=%s,\n' % quote_python(self.ShipmentIndicator).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('PartnerInformation=[\n')
        level += 1
        for PartnerInformation_ in self.PartnerInformation:
            showIndent(outfile, level)
            outfile.write('model_.PartnerInformation(\n')
            PartnerInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('DateTimeRange=model_.DateTimeRange(\n')
            self.DateTimeRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShipmentTerms is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentTerms=model_.ShipmentTerms(\n')
            self.ShipmentTerms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ScheduleDateTime is not None:
            showIndent(outfile, level)
            outfile.write('ScheduleDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.ScheduleDateTime, input_name='ScheduleDateTime'))
        if self.ScheduleDateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('ScheduleDateTimeRange=model_.ScheduleDateTimeRange(\n')
            self.ScheduleDateTimeRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SpecialInstructions=[\n')
        level += 1
        for SpecialInstructions_ in self.SpecialInstructions:
            showIndent(outfile, level)
            outfile.write('model_.SpecialInstructions(\n')
            SpecialInstructions_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RequestedDocument=[\n')
        level += 1
        for RequestedDocument_ in self.RequestedDocument:
            showIndent(outfile, level)
            outfile.write('model_.RequestedDocument(\n')
            RequestedDocument_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Routing is not None:
            showIndent(outfile, level)
            outfile.write('Routing=%s,\n' % quote_python(self.Routing).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CustomerSpecificInformation=[\n')
        level += 1
        for CustomerSpecificInformation_ in self.CustomerSpecificInformation:
            showIndent(outfile, level)
            outfile.write('model_.CustomerSpecificInformation(\n')
            CustomerSpecificInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PercentActive is not None:
            showIndent(outfile, level)
            outfile.write('PercentActive=%f,\n' % self.PercentActive)
        showIndent(outfile, level)
        outfile.write('ProductSubLineItems=[\n')
        level += 1
        for ProductSubLineItems_ in self.ProductSubLineItems:
            showIndent(outfile, level)
            outfile.write('model_.ProductSubLineItems(\n')
            ProductSubLineItems_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PackagingInformation=[\n')
        level += 1
        for PackagingInformation_ in self.PackagingInformation:
            showIndent(outfile, level)
            outfile.write('model_.PackagingInformation(\n')
            PackagingInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineItemNumber':
            LineItemNumber_ = child_.text
            LineItemNumber_ = self.gds_validate_string(LineItemNumber_, node, 'LineItemNumber')
            self.LineItemNumber = LineItemNumber_
        elif nodeName_ == 'EquipmentDetailsLineNumber':
            EquipmentDetailsLineNumber_ = child_.text
            EquipmentDetailsLineNumber_ = self.gds_validate_string(EquipmentDetailsLineNumber_, node, 'EquipmentDetailsLineNumber')
            self.EquipmentDetailsLineNumber = EquipmentDetailsLineNumber_
        elif nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
        elif nodeName_ == 'ProductInformation':
            obj_ = ProductInformation.factory()
            obj_.build(child_)
            self.ProductInformation.append(obj_)
        elif nodeName_ == 'ShippedQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_ShippedQuantity(obj_)
        elif nodeName_ == 'OrderQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_OrderQuantity(obj_)
        elif nodeName_ == 'InvoiceQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_InvoiceQuantity(obj_)
        elif nodeName_ == 'PackagingQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PackagingQuantity(obj_)
        elif nodeName_ == 'CumulativeTotalQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_CumulativeTotalQuantity(obj_)
        elif nodeName_ == 'LineItemText':
            LineItemText_ = child_.text
            LineItemText_ = self.gds_validate_string(LineItemText_, node, 'LineItemText')
            self.LineItemText.append(LineItemText_)
        elif nodeName_ == 'DocumentReference':
            obj_ = DocumentReference.factory()
            obj_.build(child_)
            self.DocumentReference.append(obj_)
        elif nodeName_ == 'ShipmentIndicator':
            ShipmentIndicator_ = child_.text
            ShipmentIndicator_ = self.gds_validate_string(ShipmentIndicator_, node, 'ShipmentIndicator')
            self.ShipmentIndicator = ShipmentIndicator_
        elif nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.PartnerInformation.append(obj_)
        elif nodeName_ == 'DateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_DateTimeRange(obj_)
        elif nodeName_ == 'ShipmentTerms':
            obj_ = ShipmentTerms.factory()
            obj_.build(child_)
            self.set_ShipmentTerms(obj_)
        elif nodeName_ == 'ScheduleDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'ScheduleDateTime')
            self.ScheduleDateTime = dval_
        elif nodeName_ == 'ScheduleDateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_ScheduleDateTimeRange(obj_)
        elif nodeName_ == 'SpecialInstructions':
            obj_ = SpecialInstructions.factory()
            obj_.build(child_)
            self.SpecialInstructions.append(obj_)
        elif nodeName_ == 'RequestedDocument':
            obj_ = RequestedDocument.factory()
            obj_.build(child_)
            self.RequestedDocument.append(obj_)
        elif nodeName_ == 'Routing':
            Routing_ = child_.text
            Routing_ = self.gds_validate_string(Routing_, node, 'Routing')
            self.Routing = Routing_
        elif nodeName_ == 'CustomerSpecificInformation':
            obj_ = CustomerSpecificInformation.factory()
            obj_.build(child_)
            self.CustomerSpecificInformation.append(obj_)
        elif nodeName_ == 'PercentActive':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentActive')
            self.PercentActive = fval_
        elif nodeName_ == 'ProductSubLineItems':
            obj_ = ProductSubLineItems.factory()
            obj_.build(child_)
            self.ProductSubLineItems.append(obj_)
        elif nodeName_ == 'PackagingInformation':
            obj_ = PackagingInformation.factory()
            obj_.build(child_)
            self.PackagingInformation.append(obj_)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment.append(Comment_)
# end class AdvancedShipNoticeLineItemsType


class CompanyInformationType(GeneratedsSuper):
    """Specifies information about a company.An alpha-numeric field, from
    the PIDX company code list, that is used to identify the
    company.2 numerics followed by a dash, followed by 7 digits."""
    subclass = None
    superclass = None
    def __init__(self, CompanyCode=None, CompanyFEIN=None, CompanyName=None):
        self.CompanyCode = _cast(None, CompanyCode)
        self.CompanyFEIN = _cast(None, CompanyFEIN)
        self.CompanyName = _cast(None, CompanyName)
        pass
    def factory(*args_, **kwargs_):
        if CompanyInformationType.subclass:
            return CompanyInformationType.subclass(*args_, **kwargs_)
        else:
            return CompanyInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompanyCode(self): return self.CompanyCode
    def set_CompanyCode(self, CompanyCode): self.CompanyCode = CompanyCode
    def get_CompanyFEIN(self): return self.CompanyFEIN
    def set_CompanyFEIN(self, CompanyFEIN): self.CompanyFEIN = CompanyFEIN
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CompanyInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompanyInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CompanyInformationType'):
        if self.CompanyCode is not None and 'CompanyCode' not in already_processed:
            already_processed.add('CompanyCode')
            outfile.write(' CompanyCode=%s' % (self.gds_format_string(quote_attrib(self.CompanyCode).encode(ExternalEncoding), input_name='CompanyCode'), ))
        if self.CompanyFEIN is not None and 'CompanyFEIN' not in already_processed:
            already_processed.add('CompanyFEIN')
            outfile.write(' CompanyFEIN=%s' % (quote_attrib(self.CompanyFEIN), ))
        if self.CompanyName is not None and 'CompanyName' not in already_processed:
            already_processed.add('CompanyName')
            outfile.write(' CompanyName=%s' % (self.gds_format_string(quote_attrib(self.CompanyName).encode(ExternalEncoding), input_name='CompanyName'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CompanyInformationType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CompanyInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CompanyCode is not None and 'CompanyCode' not in already_processed:
            already_processed.add('CompanyCode')
            showIndent(outfile, level)
            outfile.write('CompanyCode = "%s",\n' % (self.CompanyCode,))
        if self.CompanyFEIN is not None and 'CompanyFEIN' not in already_processed:
            already_processed.add('CompanyFEIN')
            showIndent(outfile, level)
            outfile.write('CompanyFEIN = %s,\n' % (self.CompanyFEIN,))
        if self.CompanyName is not None and 'CompanyName' not in already_processed:
            already_processed.add('CompanyName')
            showIndent(outfile, level)
            outfile.write('CompanyName = "%s",\n' % (self.CompanyName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CompanyCode', node)
        if value is not None and 'CompanyCode' not in already_processed:
            already_processed.add('CompanyCode')
            self.CompanyCode = value
        value = find_attr_value_('CompanyFEIN', node)
        if value is not None and 'CompanyFEIN' not in already_processed:
            already_processed.add('CompanyFEIN')
            self.CompanyFEIN = value
        value = find_attr_value_('CompanyName', node)
        if value is not None and 'CompanyName' not in already_processed:
            already_processed.add('CompanyName')
            self.CompanyName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CompanyInformationType


class CustodyPartnerType(GeneratedsSuper):
    """Information about a trading partner that is participating in a
    custody transfer."""
    subclass = None
    superclass = None
    def __init__(self, PartnerInformation=None, PartnerEntityIdentifier=None, PartnerFacilityIdentifier=None):
        self.PartnerInformation = PartnerInformation
        self.PartnerEntityIdentifier = PartnerEntityIdentifier
        self.PartnerFacilityIdentifier = PartnerFacilityIdentifier
    def factory(*args_, **kwargs_):
        if CustodyPartnerType.subclass:
            return CustodyPartnerType.subclass(*args_, **kwargs_)
        else:
            return CustodyPartnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def get_PartnerEntityIdentifier(self): return self.PartnerEntityIdentifier
    def set_PartnerEntityIdentifier(self, PartnerEntityIdentifier): self.PartnerEntityIdentifier = PartnerEntityIdentifier
    def get_PartnerFacilityIdentifier(self): return self.PartnerFacilityIdentifier
    def set_PartnerFacilityIdentifier(self, PartnerFacilityIdentifier): self.PartnerFacilityIdentifier = PartnerFacilityIdentifier
    def hasContent_(self):
        if (
            self.PartnerInformation is not None or
            self.PartnerEntityIdentifier is not None or
            self.PartnerFacilityIdentifier is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CustodyPartnerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodyPartnerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CustodyPartnerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CustodyPartnerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartnerInformation is not None:
            self.PartnerInformation.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
        if self.PartnerEntityIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartnerEntityIdentifier>%s</%sPartnerEntityIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.PartnerEntityIdentifier).encode(ExternalEncoding), input_name='PartnerEntityIdentifier'), namespace_, eol_))
        if self.PartnerFacilityIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartnerFacilityIdentifier>%s</%sPartnerFacilityIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.PartnerFacilityIdentifier).encode(ExternalEncoding), input_name='PartnerFacilityIdentifier'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CustodyPartnerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PartnerInformation is not None:
            showIndent(outfile, level)
            outfile.write('PartnerInformation=model_.PartnerInformation(\n')
            self.PartnerInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PartnerEntityIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('PartnerEntityIdentifier=%s,\n' % quote_python(self.PartnerEntityIdentifier).encode(ExternalEncoding))
        if self.PartnerFacilityIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('PartnerFacilityIdentifier=%s,\n' % quote_python(self.PartnerFacilityIdentifier).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.set_PartnerInformation(obj_)
        elif nodeName_ == 'PartnerEntityIdentifier':
            PartnerEntityIdentifier_ = child_.text
            PartnerEntityIdentifier_ = self.gds_validate_string(PartnerEntityIdentifier_, node, 'PartnerEntityIdentifier')
            self.PartnerEntityIdentifier = PartnerEntityIdentifier_
        elif nodeName_ == 'PartnerFacilityIdentifier':
            PartnerFacilityIdentifier_ = child_.text
            PartnerFacilityIdentifier_ = self.gds_validate_string(PartnerFacilityIdentifier_, node, 'PartnerFacilityIdentifier')
            self.PartnerFacilityIdentifier = PartnerFacilityIdentifier_
# end class CustodyPartnerType


class DateTimeRangeType(GeneratedsSuper):
    """Type holding the structure for date/time range elements. The
    starting date and time of a range."""
    subclass = None
    superclass = None
    def __init__(self, definitionOfOther=None, rangeType=None, FromDateTime=None, ToDateTime=None):
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.rangeType = _cast(None, rangeType)
        self.FromDateTime = FromDateTime
        self.ToDateTime = ToDateTime
    def factory(*args_, **kwargs_):
        if DateTimeRangeType.subclass:
            return DateTimeRangeType.subclass(*args_, **kwargs_)
        else:
            return DateTimeRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FromDateTime(self): return self.FromDateTime
    def set_FromDateTime(self, FromDateTime): self.FromDateTime = FromDateTime
    def get_ToDateTime(self): return self.ToDateTime
    def set_ToDateTime(self, ToDateTime): self.ToDateTime = ToDateTime
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_rangeType(self): return self.rangeType
    def set_rangeType(self, rangeType): self.rangeType = rangeType
    def hasContent_(self):
        if (
            self.FromDateTime is not None or
            self.ToDateTime is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='DateTimeRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='DateTimeRangeType'):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
        if self.rangeType is not None and 'rangeType' not in already_processed:
            already_processed.add('rangeType')
            outfile.write(' rangeType=%s' % (quote_attrib(self.rangeType), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='DateTimeRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FromDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromDateTime>%s</%sFromDateTime>%s' % (namespace_, self.gds_format_datetime(self.FromDateTime, input_name='FromDateTime'), namespace_, eol_))
        if self.ToDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToDateTime>%s</%sToDateTime>%s' % (namespace_, self.gds_format_datetime(self.ToDateTime, input_name='ToDateTime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DateTimeRangeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
        if self.rangeType is not None and 'rangeType' not in already_processed:
            already_processed.add('rangeType')
            showIndent(outfile, level)
            outfile.write('rangeType = %s,\n' % (self.rangeType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FromDateTime is not None:
            showIndent(outfile, level)
            outfile.write('FromDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.FromDateTime, input_name='FromDateTime'))
        if self.ToDateTime is not None:
            showIndent(outfile, level)
            outfile.write('ToDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.ToDateTime, input_name='ToDateTime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
        value = find_attr_value_('rangeType', node)
        if value is not None and 'rangeType' not in already_processed:
            already_processed.add('rangeType')
            self.rangeType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FromDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'FromDateTime')
            self.FromDateTime = dval_
        elif nodeName_ == 'ToDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'ToDateTime')
            self.ToDateTime = dval_
# end class DateTimeRangeType


class DescriptionType(GeneratedsSuper):
    """Type holding the structure for description elements."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, LanguageCode=None):
        self.Description = Description
        self.LanguageCode = LanguageCode
    def factory(*args_, **kwargs_):
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def hasContent_(self):
        if (
            self.Description is not None or
            self.LanguageCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='DescriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='DescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='DescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.LanguageCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLanguageCode>%s</%sLanguageCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.LanguageCode is not None:
            showIndent(outfile, level)
            outfile.write('LanguageCode=%s,\n' % quote_python(self.LanguageCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'LanguageCode':
            LanguageCode_ = child_.text
            LanguageCode_ = self.gds_validate_string(LanguageCode_, node, 'LanguageCode')
            self.LanguageCode = LanguageCode_
# end class DescriptionType


class ErrorsType(GeneratedsSuper):
    """A collection of errors that occurred during the processing of a
    message."""
    subclass = None
    superclass = None
    def __init__(self, Error=None):
        if Error is None:
            self.Error = []
        else:
            self.Error = Error
    def factory(*args_, **kwargs_):
        if ErrorsType.subclass:
            return ErrorsType.subclass(*args_, **kwargs_)
        else:
            return ErrorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Error(self): return self.Error
    def set_Error(self, Error): self.Error = Error
    def add_Error(self, value): self.Error.append(value)
    def insert_Error(self, index, value): self.Error[index] = value
    def hasContent_(self):
        if (
            self.Error
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ErrorsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ErrorsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ErrorsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Error_ in self.Error:
            Error_.export(outfile, level, namespace_, name_='Error', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ErrorsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Error=[\n')
        level += 1
        for Error_ in self.Error:
            showIndent(outfile, level)
            outfile.write('model_.ErrorWarningType(\n')
            Error_.exportLiteral(outfile, level, name_='ErrorWarningType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Error':
            obj_ = ErrorWarningType.factory()
            obj_.build(child_)
            self.Error.append(obj_)
# end class ErrorsType


class FreeTextType(GeneratedsSuper):
    """Textual information to provide descriptions and/or additional
    information."""
    subclass = None
    superclass = None
    def __init__(self, Language=None, valueOf_=None, extensiontype_=None):
        self.Language = _cast(None, Language)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if FreeTextType.subclass:
            return FreeTextType.subclass(*args_, **kwargs_)
        else:
            return FreeTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FreeTextType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeTextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FreeTextType'):
        if self.Language is not None and 'Language' not in already_processed:
            already_processed.add('Language')
            outfile.write(' Language=%s' % (self.gds_format_string(quote_attrib(self.Language).encode(ExternalEncoding), input_name='Language'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FreeTextType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FreeTextType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Language is not None and 'Language' not in already_processed:
            already_processed.add('Language')
            showIndent(outfile, level)
            outfile.write('Language = "%s",\n' % (self.Language,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Language', node)
        if value is not None and 'Language' not in already_processed:
            already_processed.add('Language')
            self.Language = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FreeTextType


class InvoiceResponseReasonType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResponseReasonCode=None, ResponseReasonCodeXPath=None, ResponseReasonComments=None):
        self.ResponseReasonCode = ResponseReasonCode
        self.ResponseReasonCodeXPath = ResponseReasonCodeXPath
        self.ResponseReasonComments = ResponseReasonComments
    def factory(*args_, **kwargs_):
        if InvoiceResponseReasonType.subclass:
            return InvoiceResponseReasonType.subclass(*args_, **kwargs_)
        else:
            return InvoiceResponseReasonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponseReasonCode(self): return self.ResponseReasonCode
    def set_ResponseReasonCode(self, ResponseReasonCode): self.ResponseReasonCode = ResponseReasonCode
    def get_ResponseReasonCodeXPath(self): return self.ResponseReasonCodeXPath
    def set_ResponseReasonCodeXPath(self, ResponseReasonCodeXPath): self.ResponseReasonCodeXPath = ResponseReasonCodeXPath
    def get_ResponseReasonComments(self): return self.ResponseReasonComments
    def set_ResponseReasonComments(self, ResponseReasonComments): self.ResponseReasonComments = ResponseReasonComments
    def hasContent_(self):
        if (
            self.ResponseReasonCode is not None or
            self.ResponseReasonCodeXPath is not None or
            self.ResponseReasonComments is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='InvoiceResponseReasonType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InvoiceResponseReasonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='InvoiceResponseReasonType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='InvoiceResponseReasonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponseReasonCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResponseReasonCode>%s</%sResponseReasonCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResponseReasonCode).encode(ExternalEncoding), input_name='ResponseReasonCode'), namespace_, eol_))
        if self.ResponseReasonCodeXPath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResponseReasonCodeXPath>%s</%sResponseReasonCodeXPath>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResponseReasonCodeXPath).encode(ExternalEncoding), input_name='ResponseReasonCodeXPath'), namespace_, eol_))
        if self.ResponseReasonComments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResponseReasonComments>%s</%sResponseReasonComments>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResponseReasonComments).encode(ExternalEncoding), input_name='ResponseReasonComments'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InvoiceResponseReasonType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ResponseReasonCode is not None:
            showIndent(outfile, level)
            outfile.write('ResponseReasonCode=%s,\n' % quote_python(self.ResponseReasonCode).encode(ExternalEncoding))
        if self.ResponseReasonCodeXPath is not None:
            showIndent(outfile, level)
            outfile.write('ResponseReasonCodeXPath=%s,\n' % quote_python(self.ResponseReasonCodeXPath).encode(ExternalEncoding))
        if self.ResponseReasonComments is not None:
            showIndent(outfile, level)
            outfile.write('ResponseReasonComments=%s,\n' % quote_python(self.ResponseReasonComments).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponseReasonCode':
            ResponseReasonCode_ = child_.text
            ResponseReasonCode_ = self.gds_validate_string(ResponseReasonCode_, node, 'ResponseReasonCode')
            self.ResponseReasonCode = ResponseReasonCode_
        elif nodeName_ == 'ResponseReasonCodeXPath':
            ResponseReasonCodeXPath_ = child_.text
            ResponseReasonCodeXPath_ = self.gds_validate_string(ResponseReasonCodeXPath_, node, 'ResponseReasonCodeXPath')
            self.ResponseReasonCodeXPath = ResponseReasonCodeXPath_
        elif nodeName_ == 'ResponseReasonComments':
            ResponseReasonComments_ = child_.text
            ResponseReasonComments_ = self.gds_validate_string(ResponseReasonComments_, node, 'ResponseReasonComments')
            self.ResponseReasonComments = ResponseReasonComments_
# end class InvoiceResponseReasonType


class LineItemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, extensiontype_=None):
        self.LineItemNumber = LineItemNumber
        if DocumentReference is None:
            self.DocumentReference = []
        else:
            self.DocumentReference = DocumentReference
        if PartnerInformation is None:
            self.PartnerInformation = []
        else:
            self.PartnerInformation = PartnerInformation
        if CustomerSpecificInformation is None:
            self.CustomerSpecificInformation = []
        else:
            self.CustomerSpecificInformation = CustomerSpecificInformation
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if LineItemsType.subclass:
            return LineItemsType.subclass(*args_, **kwargs_)
        else:
            return LineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineItemNumber(self): return self.LineItemNumber
    def set_LineItemNumber(self, LineItemNumber): self.LineItemNumber = LineItemNumber
    def get_DocumentReference(self): return self.DocumentReference
    def set_DocumentReference(self, DocumentReference): self.DocumentReference = DocumentReference
    def add_DocumentReference(self, value): self.DocumentReference.append(value)
    def insert_DocumentReference(self, index, value): self.DocumentReference[index] = value
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def add_PartnerInformation(self, value): self.PartnerInformation.append(value)
    def insert_PartnerInformation(self, index, value): self.PartnerInformation[index] = value
    def get_CustomerSpecificInformation(self): return self.CustomerSpecificInformation
    def set_CustomerSpecificInformation(self, CustomerSpecificInformation): self.CustomerSpecificInformation = CustomerSpecificInformation
    def add_CustomerSpecificInformation(self, value): self.CustomerSpecificInformation.append(value)
    def insert_CustomerSpecificInformation(self, index, value): self.CustomerSpecificInformation[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.LineItemNumber is not None or
            self.DocumentReference or
            self.PartnerInformation or
            self.CustomerSpecificInformation or
            self.Comment
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LineItemsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LineItemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LineItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemNumber>%s</%sLineItemNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemNumber).encode(ExternalEncoding), input_name='LineItemNumber'), namespace_, eol_))
        for DocumentReference_ in self.DocumentReference:
            DocumentReference_.export(outfile, level, namespace_, name_='DocumentReference', pretty_print=pretty_print)
        for PartnerInformation_ in self.PartnerInformation:
            PartnerInformation_.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
        for CustomerSpecificInformation_ in self.CustomerSpecificInformation:
            CustomerSpecificInformation_.export(outfile, level, namespace_, name_='CustomerSpecificInformation', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(Comment_).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LineItemNumber is not None:
            showIndent(outfile, level)
            outfile.write('LineItemNumber=%s,\n' % quote_python(self.LineItemNumber).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('DocumentReference=[\n')
        level += 1
        for DocumentReference_ in self.DocumentReference:
            showIndent(outfile, level)
            outfile.write('model_.DocumentReference(\n')
            DocumentReference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PartnerInformation=[\n')
        level += 1
        for PartnerInformation_ in self.PartnerInformation:
            showIndent(outfile, level)
            outfile.write('model_.PartnerInformation(\n')
            PartnerInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomerSpecificInformation=[\n')
        level += 1
        for CustomerSpecificInformation_ in self.CustomerSpecificInformation:
            showIndent(outfile, level)
            outfile.write('model_.CustomerSpecificInformation(\n')
            CustomerSpecificInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineItemNumber':
            LineItemNumber_ = child_.text
            LineItemNumber_ = self.gds_validate_string(LineItemNumber_, node, 'LineItemNumber')
            self.LineItemNumber = LineItemNumber_
        elif nodeName_ == 'DocumentReference':
            obj_ = DocumentReference.factory()
            obj_.build(child_)
            self.DocumentReference.append(obj_)
        elif nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.PartnerInformation.append(obj_)
        elif nodeName_ == 'CustomerSpecificInformation':
            obj_ = CustomerSpecificInformation.factory()
            obj_.build(child_)
            self.CustomerSpecificInformation.append(obj_)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment.append(Comment_)
# end class LineItemsType


class MeasurementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Measurement=None, UnitOfMeasureCode=None):
        self.Measurement = Measurement
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if MeasurementType.subclass:
            return MeasurementType.subclass(*args_, **kwargs_)
        else:
            return MeasurementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measurement(self): return self.Measurement
    def set_Measurement(self, Measurement): self.Measurement = Measurement
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Measurement is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='MeasurementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasurementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='MeasurementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='MeasurementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Measurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurement>%s</%sMeasurement>%s' % (namespace_, self.gds_format_float(self.Measurement, input_name='Measurement'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MeasurementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Measurement is not None:
            showIndent(outfile, level)
            outfile.write('Measurement=%f,\n' % self.Measurement)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measurement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measurement')
            self.Measurement = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class MeasurementType


class MonetaryType(GeneratedsSuper):
    """Type holding the structure for monetary elements."""
    subclass = None
    superclass = None
    def __init__(self, MonetaryAmount=None, CurrencyCode=None, extensiontype_=None):
        self.MonetaryAmount = MonetaryAmount
        self.CurrencyCode = CurrencyCode
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MonetaryType.subclass:
            return MonetaryType.subclass(*args_, **kwargs_)
        else:
            return MonetaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MonetaryAmount(self): return self.MonetaryAmount
    def set_MonetaryAmount(self, MonetaryAmount): self.MonetaryAmount = MonetaryAmount
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.MonetaryAmount is not None or
            self.CurrencyCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='MonetaryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonetaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='MonetaryType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='MonetaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MonetaryAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMonetaryAmount>%s</%sMonetaryAmount>%s' % (namespace_, self.gds_format_float(self.MonetaryAmount, input_name='MonetaryAmount'), namespace_, eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CurrencyCode).encode(ExternalEncoding), input_name='CurrencyCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MonetaryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MonetaryAmount is not None:
            showIndent(outfile, level)
            outfile.write('MonetaryAmount=%f,\n' % self.MonetaryAmount)
        if self.CurrencyCode is not None:
            showIndent(outfile, level)
            outfile.write('CurrencyCode=%s,\n' % quote_python(self.CurrencyCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MonetaryAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MonetaryAmount')
            self.MonetaryAmount = fval_
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
# end class MonetaryType


class OrderChangeCancelLineItemsType(LineItemsType):
    subclass = None
    superclass = LineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, PurchaseOrderReferenceInformation=None, LineItemRequestedAction=None, AccompanyingSampleCode=None):
        super(OrderChangeCancelLineItemsType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, )
        self.PurchaseOrderReferenceInformation = PurchaseOrderReferenceInformation
        self.LineItemRequestedAction = LineItemRequestedAction
        self.AccompanyingSampleCode = AccompanyingSampleCode
    def factory(*args_, **kwargs_):
        if OrderChangeCancelLineItemsType.subclass:
            return OrderChangeCancelLineItemsType.subclass(*args_, **kwargs_)
        else:
            return OrderChangeCancelLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PurchaseOrderReferenceInformation(self): return self.PurchaseOrderReferenceInformation
    def set_PurchaseOrderReferenceInformation(self, PurchaseOrderReferenceInformation): self.PurchaseOrderReferenceInformation = PurchaseOrderReferenceInformation
    def get_LineItemRequestedAction(self): return self.LineItemRequestedAction
    def set_LineItemRequestedAction(self, LineItemRequestedAction): self.LineItemRequestedAction = LineItemRequestedAction
    def get_AccompanyingSampleCode(self): return self.AccompanyingSampleCode
    def set_AccompanyingSampleCode(self, AccompanyingSampleCode): self.AccompanyingSampleCode = AccompanyingSampleCode
    def hasContent_(self):
        if (
            self.PurchaseOrderReferenceInformation is not None or
            self.LineItemRequestedAction is not None or
            self.AccompanyingSampleCode is not None or
            super(OrderChangeCancelLineItemsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OrderChangeCancelLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderChangeCancelLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OrderChangeCancelLineItemsType'):
        super(OrderChangeCancelLineItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrderChangeCancelLineItemsType')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OrderChangeCancelLineItemsType', fromsubclass_=False, pretty_print=True):
        super(OrderChangeCancelLineItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PurchaseOrderReferenceInformation is not None:
            self.PurchaseOrderReferenceInformation.export(outfile, level, namespace_, name_='PurchaseOrderReferenceInformation', pretty_print=pretty_print)
        if self.LineItemRequestedAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLineItemRequestedAction>%s</%sLineItemRequestedAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.LineItemRequestedAction).encode(ExternalEncoding), input_name='LineItemRequestedAction'), namespace_, eol_))
        if self.AccompanyingSampleCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccompanyingSampleCode>%s</%sAccompanyingSampleCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccompanyingSampleCode).encode(ExternalEncoding), input_name='AccompanyingSampleCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrderChangeCancelLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrderChangeCancelLineItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrderChangeCancelLineItemsType, self).exportLiteralChildren(outfile, level, name_)
        if self.PurchaseOrderReferenceInformation is not None:
            showIndent(outfile, level)
            outfile.write('PurchaseOrderReferenceInformation=model_.PurchaseOrderReferenceInformation(\n')
            self.PurchaseOrderReferenceInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LineItemRequestedAction is not None:
            showIndent(outfile, level)
            outfile.write('LineItemRequestedAction=%s,\n' % quote_python(self.LineItemRequestedAction).encode(ExternalEncoding))
        if self.AccompanyingSampleCode is not None:
            showIndent(outfile, level)
            outfile.write('AccompanyingSampleCode=%s,\n' % quote_python(self.AccompanyingSampleCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OrderChangeCancelLineItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PurchaseOrderReferenceInformation':
            obj_ = PurchaseOrderReferenceInformation.factory()
            obj_.build(child_)
            self.set_PurchaseOrderReferenceInformation(obj_)
        elif nodeName_ == 'LineItemRequestedAction':
            LineItemRequestedAction_ = child_.text
            LineItemRequestedAction_ = self.gds_validate_string(LineItemRequestedAction_, node, 'LineItemRequestedAction')
            self.LineItemRequestedAction = LineItemRequestedAction_
        elif nodeName_ == 'AccompanyingSampleCode':
            AccompanyingSampleCode_ = child_.text
            AccompanyingSampleCode_ = self.gds_validate_string(AccompanyingSampleCode_, node, 'AccompanyingSampleCode')
            self.AccompanyingSampleCode = AccompanyingSampleCode_
        super(OrderChangeCancelLineItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class OrderChangeCancelLineItemsType


class OrderStatusLineItemsRequestType(LineItemsType):
    subclass = None
    superclass = LineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None):
        super(OrderStatusLineItemsRequestType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, )
        pass
    def factory(*args_, **kwargs_):
        if OrderStatusLineItemsRequestType.subclass:
            return OrderStatusLineItemsRequestType.subclass(*args_, **kwargs_)
        else:
            return OrderStatusLineItemsRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(OrderStatusLineItemsRequestType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OrderStatusLineItemsRequestType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderStatusLineItemsRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OrderStatusLineItemsRequestType'):
        super(OrderStatusLineItemsRequestType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrderStatusLineItemsRequestType')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OrderStatusLineItemsRequestType', fromsubclass_=False, pretty_print=True):
        super(OrderStatusLineItemsRequestType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrderStatusLineItemsRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrderStatusLineItemsRequestType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrderStatusLineItemsRequestType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OrderStatusLineItemsRequestType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OrderStatusLineItemsRequestType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OrderStatusLineItemsRequestType


class OrderLineItemsType(LineItemsType):
    subclass = None
    superclass = LineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, RevisionNumber=None, ProductInformation=None, OrderQuantity=None, PackagingQuantity=None, LineItemPurposeCode=None, EngineeringChangeOrderIdentifier=None, BatchNumber=None, CountryOfOrigin=None, CountryOfFinalDestination=None, DeliveryTolerances=None, ShipmentTerms=None, ScheduleDateTime=None, ScheduleDateTimeRange=None, TransportInformation=None, RequestedDocument=None, Routing=None, SpecialServicesRequest=None, PackListRequirements=None, QuoteIdentifier=None, Label=None, ImportLicenseNeededFlag=None, ImportLicenseAvailableFlag=None, AccompanyingSampleCode=None, JobLocationClassCode=None, extensiontype_=None):
        super(OrderLineItemsType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, extensiontype_, )
        self.RevisionNumber = RevisionNumber
        if ProductInformation is None:
            self.ProductInformation = []
        else:
            self.ProductInformation = ProductInformation
        self.OrderQuantity = OrderQuantity
        self.PackagingQuantity = PackagingQuantity
        self.LineItemPurposeCode = LineItemPurposeCode
        self.EngineeringChangeOrderIdentifier = EngineeringChangeOrderIdentifier
        self.BatchNumber = BatchNumber
        self.CountryOfOrigin = CountryOfOrigin
        self.CountryOfFinalDestination = CountryOfFinalDestination
        self.DeliveryTolerances = DeliveryTolerances
        self.ShipmentTerms = ShipmentTerms
        self.ScheduleDateTime = ScheduleDateTime
        self.ScheduleDateTimeRange = ScheduleDateTimeRange
        if TransportInformation is None:
            self.TransportInformation = []
        else:
            self.TransportInformation = TransportInformation
        if RequestedDocument is None:
            self.RequestedDocument = []
        else:
            self.RequestedDocument = RequestedDocument
        self.Routing = Routing
        if SpecialServicesRequest is None:
            self.SpecialServicesRequest = []
        else:
            self.SpecialServicesRequest = SpecialServicesRequest
        self.PackListRequirements = PackListRequirements
        self.QuoteIdentifier = QuoteIdentifier
        if Label is None:
            self.Label = []
        else:
            self.Label = Label
        self.ImportLicenseNeededFlag = ImportLicenseNeededFlag
        self.ImportLicenseAvailableFlag = ImportLicenseAvailableFlag
        self.AccompanyingSampleCode = AccompanyingSampleCode
        self.JobLocationClassCode = JobLocationClassCode
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if OrderLineItemsType.subclass:
            return OrderLineItemsType.subclass(*args_, **kwargs_)
        else:
            return OrderLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RevisionNumber(self): return self.RevisionNumber
    def set_RevisionNumber(self, RevisionNumber): self.RevisionNumber = RevisionNumber
    def get_ProductInformation(self): return self.ProductInformation
    def set_ProductInformation(self, ProductInformation): self.ProductInformation = ProductInformation
    def add_ProductInformation(self, value): self.ProductInformation.append(value)
    def insert_ProductInformation(self, index, value): self.ProductInformation[index] = value
    def get_OrderQuantity(self): return self.OrderQuantity
    def set_OrderQuantity(self, OrderQuantity): self.OrderQuantity = OrderQuantity
    def get_PackagingQuantity(self): return self.PackagingQuantity
    def set_PackagingQuantity(self, PackagingQuantity): self.PackagingQuantity = PackagingQuantity
    def get_LineItemPurposeCode(self): return self.LineItemPurposeCode
    def set_LineItemPurposeCode(self, LineItemPurposeCode): self.LineItemPurposeCode = LineItemPurposeCode
    def get_EngineeringChangeOrderIdentifier(self): return self.EngineeringChangeOrderIdentifier
    def set_EngineeringChangeOrderIdentifier(self, EngineeringChangeOrderIdentifier): self.EngineeringChangeOrderIdentifier = EngineeringChangeOrderIdentifier
    def get_BatchNumber(self): return self.BatchNumber
    def set_BatchNumber(self, BatchNumber): self.BatchNumber = BatchNumber
    def get_CountryOfOrigin(self): return self.CountryOfOrigin
    def set_CountryOfOrigin(self, CountryOfOrigin): self.CountryOfOrigin = CountryOfOrigin
    def get_CountryOfFinalDestination(self): return self.CountryOfFinalDestination
    def set_CountryOfFinalDestination(self, CountryOfFinalDestination): self.CountryOfFinalDestination = CountryOfFinalDestination
    def get_DeliveryTolerances(self): return self.DeliveryTolerances
    def set_DeliveryTolerances(self, DeliveryTolerances): self.DeliveryTolerances = DeliveryTolerances
    def get_ShipmentTerms(self): return self.ShipmentTerms
    def set_ShipmentTerms(self, ShipmentTerms): self.ShipmentTerms = ShipmentTerms
    def get_ScheduleDateTime(self): return self.ScheduleDateTime
    def set_ScheduleDateTime(self, ScheduleDateTime): self.ScheduleDateTime = ScheduleDateTime
    def get_ScheduleDateTimeRange(self): return self.ScheduleDateTimeRange
    def set_ScheduleDateTimeRange(self, ScheduleDateTimeRange): self.ScheduleDateTimeRange = ScheduleDateTimeRange
    def get_TransportInformation(self): return self.TransportInformation
    def set_TransportInformation(self, TransportInformation): self.TransportInformation = TransportInformation
    def add_TransportInformation(self, value): self.TransportInformation.append(value)
    def insert_TransportInformation(self, index, value): self.TransportInformation[index] = value
    def get_RequestedDocument(self): return self.RequestedDocument
    def set_RequestedDocument(self, RequestedDocument): self.RequestedDocument = RequestedDocument
    def add_RequestedDocument(self, value): self.RequestedDocument.append(value)
    def insert_RequestedDocument(self, index, value): self.RequestedDocument[index] = value
    def get_Routing(self): return self.Routing
    def set_Routing(self, Routing): self.Routing = Routing
    def get_SpecialServicesRequest(self): return self.SpecialServicesRequest
    def set_SpecialServicesRequest(self, SpecialServicesRequest): self.SpecialServicesRequest = SpecialServicesRequest
    def add_SpecialServicesRequest(self, value): self.SpecialServicesRequest.append(value)
    def insert_SpecialServicesRequest(self, index, value): self.SpecialServicesRequest[index] = value
    def get_PackListRequirements(self): return self.PackListRequirements
    def set_PackListRequirements(self, PackListRequirements): self.PackListRequirements = PackListRequirements
    def get_QuoteIdentifier(self): return self.QuoteIdentifier
    def set_QuoteIdentifier(self, QuoteIdentifier): self.QuoteIdentifier = QuoteIdentifier
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def add_Label(self, value): self.Label.append(value)
    def insert_Label(self, index, value): self.Label[index] = value
    def get_ImportLicenseNeededFlag(self): return self.ImportLicenseNeededFlag
    def set_ImportLicenseNeededFlag(self, ImportLicenseNeededFlag): self.ImportLicenseNeededFlag = ImportLicenseNeededFlag
    def get_ImportLicenseAvailableFlag(self): return self.ImportLicenseAvailableFlag
    def set_ImportLicenseAvailableFlag(self, ImportLicenseAvailableFlag): self.ImportLicenseAvailableFlag = ImportLicenseAvailableFlag
    def get_AccompanyingSampleCode(self): return self.AccompanyingSampleCode
    def set_AccompanyingSampleCode(self, AccompanyingSampleCode): self.AccompanyingSampleCode = AccompanyingSampleCode
    def get_JobLocationClassCode(self): return self.JobLocationClassCode
    def set_JobLocationClassCode(self, JobLocationClassCode): self.JobLocationClassCode = JobLocationClassCode
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.RevisionNumber is not None or
            self.ProductInformation or
            self.OrderQuantity is not None or
            self.PackagingQuantity is not None or
            self.LineItemPurposeCode is not None or
            self.EngineeringChangeOrderIdentifier is not None or
            self.BatchNumber is not None or
            self.CountryOfOrigin is not None or
            self.CountryOfFinalDestination is not None or
            self.DeliveryTolerances is not None or
            self.ShipmentTerms is not None or
            self.ScheduleDateTime is not None or
            self.ScheduleDateTimeRange is not None or
            self.TransportInformation or
            self.RequestedDocument or
            self.Routing is not None or
            self.SpecialServicesRequest or
            self.PackListRequirements is not None or
            self.QuoteIdentifier is not None or
            self.Label or
            self.ImportLicenseNeededFlag is not None or
            self.ImportLicenseAvailableFlag is not None or
            self.AccompanyingSampleCode is not None or
            self.JobLocationClassCode is not None or
            super(OrderLineItemsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OrderLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OrderLineItemsType'):
        super(OrderLineItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrderLineItemsType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OrderLineItemsType', fromsubclass_=False, pretty_print=True):
        super(OrderLineItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RevisionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRevisionNumber>%s</%sRevisionNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.RevisionNumber).encode(ExternalEncoding), input_name='RevisionNumber'), namespace_, eol_))
        for ProductInformation_ in self.ProductInformation:
            ProductInformation_.export(outfile, level, namespace_, name_='ProductInformation', pretty_print=pretty_print)
        if self.OrderQuantity is not None:
            self.OrderQuantity.export(outfile, level, namespace_, name_='OrderQuantity', pretty_print=pretty_print)
        if self.PackagingQuantity is not None:
            self.PackagingQuantity.export(outfile, level, namespace_, name_='PackagingQuantity', pretty_print=pretty_print)
        if self.LineItemPurposeCode is not None:
            self.LineItemPurposeCode.export(outfile, level, namespace_, name_='LineItemPurposeCode', pretty_print=pretty_print)
        if self.EngineeringChangeOrderIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEngineeringChangeOrderIdentifier>%s</%sEngineeringChangeOrderIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.EngineeringChangeOrderIdentifier).encode(ExternalEncoding), input_name='EngineeringChangeOrderIdentifier'), namespace_, eol_))
        if self.BatchNumber is not None:
            self.BatchNumber.export(outfile, level, namespace_, name_='BatchNumber', pretty_print=pretty_print)
        if self.CountryOfOrigin is not None:
            self.CountryOfOrigin.export(outfile, level, namespace_, name_='CountryOfOrigin', pretty_print=pretty_print)
        if self.CountryOfFinalDestination is not None:
            self.CountryOfFinalDestination.export(outfile, level, namespace_, name_='CountryOfFinalDestination', pretty_print=pretty_print)
        if self.DeliveryTolerances is not None:
            self.DeliveryTolerances.export(outfile, level, namespace_, name_='DeliveryTolerances', pretty_print=pretty_print)
        if self.ShipmentTerms is not None:
            self.ShipmentTerms.export(outfile, level, namespace_, name_='ShipmentTerms', pretty_print=pretty_print)
        if self.ScheduleDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sScheduleDateTime>%s</%sScheduleDateTime>%s' % (namespace_, self.gds_format_datetime(self.ScheduleDateTime, input_name='ScheduleDateTime'), namespace_, eol_))
        if self.ScheduleDateTimeRange is not None:
            self.ScheduleDateTimeRange.export(outfile, level, namespace_, name_='ScheduleDateTimeRange', pretty_print=pretty_print)
        for TransportInformation_ in self.TransportInformation:
            TransportInformation_.export(outfile, level, namespace_, name_='TransportInformation', pretty_print=pretty_print)
        for RequestedDocument_ in self.RequestedDocument:
            RequestedDocument_.export(outfile, level, namespace_, name_='RequestedDocument', pretty_print=pretty_print)
        if self.Routing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRouting>%s</%sRouting>%s' % (namespace_, self.gds_format_string(quote_xml(self.Routing).encode(ExternalEncoding), input_name='Routing'), namespace_, eol_))
        for SpecialServicesRequest_ in self.SpecialServicesRequest:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialServicesRequest>%s</%sSpecialServicesRequest>%s' % (namespace_, self.gds_format_string(quote_xml(SpecialServicesRequest_).encode(ExternalEncoding), input_name='SpecialServicesRequest'), namespace_, eol_))
        if self.PackListRequirements is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPackListRequirements>%s</%sPackListRequirements>%s' % (namespace_, self.gds_format_string(quote_xml(self.PackListRequirements).encode(ExternalEncoding), input_name='PackListRequirements'), namespace_, eol_))
        if self.QuoteIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuoteIdentifier>%s</%sQuoteIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.QuoteIdentifier).encode(ExternalEncoding), input_name='QuoteIdentifier'), namespace_, eol_))
        for Label_ in self.Label:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLabel>%s</%sLabel>%s' % (namespace_, self.gds_format_string(quote_xml(Label_).encode(ExternalEncoding), input_name='Label'), namespace_, eol_))
        if self.ImportLicenseNeededFlag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImportLicenseNeededFlag>%s</%sImportLicenseNeededFlag>%s' % (namespace_, self.gds_format_boolean(self.ImportLicenseNeededFlag, input_name='ImportLicenseNeededFlag'), namespace_, eol_))
        if self.ImportLicenseAvailableFlag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImportLicenseAvailableFlag>%s</%sImportLicenseAvailableFlag>%s' % (namespace_, self.gds_format_boolean(self.ImportLicenseAvailableFlag, input_name='ImportLicenseAvailableFlag'), namespace_, eol_))
        if self.AccompanyingSampleCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccompanyingSampleCode>%s</%sAccompanyingSampleCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccompanyingSampleCode).encode(ExternalEncoding), input_name='AccompanyingSampleCode'), namespace_, eol_))
        if self.JobLocationClassCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJobLocationClassCode>%s</%sJobLocationClassCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.JobLocationClassCode).encode(ExternalEncoding), input_name='JobLocationClassCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrderLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrderLineItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrderLineItemsType, self).exportLiteralChildren(outfile, level, name_)
        if self.RevisionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RevisionNumber=%s,\n' % quote_python(self.RevisionNumber).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ProductInformation=[\n')
        level += 1
        for ProductInformation_ in self.ProductInformation:
            showIndent(outfile, level)
            outfile.write('model_.ProductInformation(\n')
            ProductInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.OrderQuantity is not None:
            showIndent(outfile, level)
            outfile.write('OrderQuantity=model_.OrderQuantity(\n')
            self.OrderQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PackagingQuantity is not None:
            showIndent(outfile, level)
            outfile.write('PackagingQuantity=model_.PackagingQuantity(\n')
            self.PackagingQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LineItemPurposeCode is not None:
            showIndent(outfile, level)
            outfile.write('LineItemPurposeCode=model_.LineItemPurposeCode(\n')
            self.LineItemPurposeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EngineeringChangeOrderIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('EngineeringChangeOrderIdentifier=%s,\n' % quote_python(self.EngineeringChangeOrderIdentifier).encode(ExternalEncoding))
        if self.BatchNumber is not None:
            showIndent(outfile, level)
            outfile.write('BatchNumber=model_.BatchNumber(\n')
            self.BatchNumber.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CountryOfOrigin is not None:
            showIndent(outfile, level)
            outfile.write('CountryOfOrigin=model_.CountryOfOrigin(\n')
            self.CountryOfOrigin.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CountryOfFinalDestination is not None:
            showIndent(outfile, level)
            outfile.write('CountryOfFinalDestination=model_.CountryOfFinalDestination(\n')
            self.CountryOfFinalDestination.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DeliveryTolerances is not None:
            showIndent(outfile, level)
            outfile.write('DeliveryTolerances=model_.DeliveryTolerances(\n')
            self.DeliveryTolerances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShipmentTerms is not None:
            showIndent(outfile, level)
            outfile.write('ShipmentTerms=model_.ShipmentTerms(\n')
            self.ShipmentTerms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ScheduleDateTime is not None:
            showIndent(outfile, level)
            outfile.write('ScheduleDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.ScheduleDateTime, input_name='ScheduleDateTime'))
        if self.ScheduleDateTimeRange is not None:
            showIndent(outfile, level)
            outfile.write('ScheduleDateTimeRange=model_.ScheduleDateTimeRange(\n')
            self.ScheduleDateTimeRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('TransportInformation=[\n')
        level += 1
        for TransportInformation_ in self.TransportInformation:
            showIndent(outfile, level)
            outfile.write('model_.TransportInformation(\n')
            TransportInformation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RequestedDocument=[\n')
        level += 1
        for RequestedDocument_ in self.RequestedDocument:
            showIndent(outfile, level)
            outfile.write('model_.RequestedDocument(\n')
            RequestedDocument_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Routing is not None:
            showIndent(outfile, level)
            outfile.write('Routing=%s,\n' % quote_python(self.Routing).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SpecialServicesRequest=[\n')
        level += 1
        for SpecialServicesRequest_ in self.SpecialServicesRequest:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SpecialServicesRequest_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PackListRequirements is not None:
            showIndent(outfile, level)
            outfile.write('PackListRequirements=%s,\n' % quote_python(self.PackListRequirements).encode(ExternalEncoding))
        if self.QuoteIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('QuoteIdentifier=%s,\n' % quote_python(self.QuoteIdentifier).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Label=[\n')
        level += 1
        for Label_ in self.Label:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Label_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ImportLicenseNeededFlag is not None:
            showIndent(outfile, level)
            outfile.write('ImportLicenseNeededFlag=%s,\n' % self.ImportLicenseNeededFlag)
        if self.ImportLicenseAvailableFlag is not None:
            showIndent(outfile, level)
            outfile.write('ImportLicenseAvailableFlag=%s,\n' % self.ImportLicenseAvailableFlag)
        if self.AccompanyingSampleCode is not None:
            showIndent(outfile, level)
            outfile.write('AccompanyingSampleCode=%s,\n' % quote_python(self.AccompanyingSampleCode).encode(ExternalEncoding))
        if self.JobLocationClassCode is not None:
            showIndent(outfile, level)
            outfile.write('JobLocationClassCode=%s,\n' % quote_python(self.JobLocationClassCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OrderLineItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RevisionNumber':
            RevisionNumber_ = child_.text
            RevisionNumber_ = self.gds_validate_string(RevisionNumber_, node, 'RevisionNumber')
            self.RevisionNumber = RevisionNumber_
        elif nodeName_ == 'ProductInformation':
            obj_ = ProductInformation.factory()
            obj_.build(child_)
            self.ProductInformation.append(obj_)
        elif nodeName_ == 'OrderQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_OrderQuantity(obj_)
        elif nodeName_ == 'PackagingQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_PackagingQuantity(obj_)
        elif nodeName_ == 'LineItemPurposeCode':
            obj_ = LineItemPurposeCode.factory()
            obj_.build(child_)
            self.set_LineItemPurposeCode(obj_)
        elif nodeName_ == 'EngineeringChangeOrderIdentifier':
            EngineeringChangeOrderIdentifier_ = child_.text
            EngineeringChangeOrderIdentifier_ = self.gds_validate_string(EngineeringChangeOrderIdentifier_, node, 'EngineeringChangeOrderIdentifier')
            self.EngineeringChangeOrderIdentifier = EngineeringChangeOrderIdentifier_
        elif nodeName_ == 'BatchNumber':
            obj_ = BatchNumber.factory()
            obj_.build(child_)
            self.set_BatchNumber(obj_)
        elif nodeName_ == 'CountryOfOrigin':
            obj_ = CountryOfOrigin.factory()
            obj_.build(child_)
            self.set_CountryOfOrigin(obj_)
        elif nodeName_ == 'CountryOfFinalDestination':
            obj_ = CountryOfFinalDestination.factory()
            obj_.build(child_)
            self.set_CountryOfFinalDestination(obj_)
        elif nodeName_ == 'DeliveryTolerances':
            obj_ = DeliveryTolerances.factory()
            obj_.build(child_)
            self.set_DeliveryTolerances(obj_)
        elif nodeName_ == 'ShipmentTerms':
            obj_ = ShipmentTerms.factory()
            obj_.build(child_)
            self.set_ShipmentTerms(obj_)
        elif nodeName_ == 'ScheduleDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'ScheduleDateTime')
            self.ScheduleDateTime = dval_
        elif nodeName_ == 'ScheduleDateTimeRange':
            obj_ = DateTimeRangeType.factory()
            obj_.build(child_)
            self.set_ScheduleDateTimeRange(obj_)
        elif nodeName_ == 'TransportInformation':
            obj_ = TransportInformation.factory()
            obj_.build(child_)
            self.TransportInformation.append(obj_)
        elif nodeName_ == 'RequestedDocument':
            obj_ = RequestedDocument.factory()
            obj_.build(child_)
            self.RequestedDocument.append(obj_)
        elif nodeName_ == 'Routing':
            Routing_ = child_.text
            Routing_ = self.gds_validate_string(Routing_, node, 'Routing')
            self.Routing = Routing_
        elif nodeName_ == 'SpecialServicesRequest':
            SpecialServicesRequest_ = child_.text
            SpecialServicesRequest_ = self.gds_validate_string(SpecialServicesRequest_, node, 'SpecialServicesRequest')
            self.SpecialServicesRequest.append(SpecialServicesRequest_)
        elif nodeName_ == 'PackListRequirements':
            PackListRequirements_ = child_.text
            PackListRequirements_ = self.gds_validate_string(PackListRequirements_, node, 'PackListRequirements')
            self.PackListRequirements = PackListRequirements_
        elif nodeName_ == 'QuoteIdentifier':
            QuoteIdentifier_ = child_.text
            QuoteIdentifier_ = self.gds_validate_string(QuoteIdentifier_, node, 'QuoteIdentifier')
            self.QuoteIdentifier = QuoteIdentifier_
        elif nodeName_ == 'Label':
            Label_ = child_.text
            Label_ = self.gds_validate_string(Label_, node, 'Label')
            self.Label.append(Label_)
        elif nodeName_ == 'ImportLicenseNeededFlag':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ImportLicenseNeededFlag')
            self.ImportLicenseNeededFlag = ival_
        elif nodeName_ == 'ImportLicenseAvailableFlag':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ImportLicenseAvailableFlag')
            self.ImportLicenseAvailableFlag = ival_
        elif nodeName_ == 'AccompanyingSampleCode':
            AccompanyingSampleCode_ = child_.text
            AccompanyingSampleCode_ = self.gds_validate_string(AccompanyingSampleCode_, node, 'AccompanyingSampleCode')
            self.AccompanyingSampleCode = AccompanyingSampleCode_
        elif nodeName_ == 'JobLocationClassCode':
            JobLocationClassCode_ = child_.text
            JobLocationClassCode_ = self.gds_validate_string(JobLocationClassCode_, node, 'JobLocationClassCode')
            self.JobLocationClassCode = JobLocationClassCode_
        super(OrderLineItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class OrderLineItemsType


class PartnerConfirmationStatusType(GeneratedsSuper):
    """Structure which contains information about the Partner's action in
    the transaction."""
    subclass = None
    superclass = None
    def __init__(self, PartnerInformation=None, ConfirmationDateTime=None, ConfirmationStatusCode=None):
        self.PartnerInformation = PartnerInformation
        self.ConfirmationDateTime = ConfirmationDateTime
        self.ConfirmationStatusCode = ConfirmationStatusCode
    def factory(*args_, **kwargs_):
        if PartnerConfirmationStatusType.subclass:
            return PartnerConfirmationStatusType.subclass(*args_, **kwargs_)
        else:
            return PartnerConfirmationStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def get_ConfirmationDateTime(self): return self.ConfirmationDateTime
    def set_ConfirmationDateTime(self, ConfirmationDateTime): self.ConfirmationDateTime = ConfirmationDateTime
    def get_ConfirmationStatusCode(self): return self.ConfirmationStatusCode
    def set_ConfirmationStatusCode(self, ConfirmationStatusCode): self.ConfirmationStatusCode = ConfirmationStatusCode
    def hasContent_(self):
        if (
            self.PartnerInformation is not None or
            self.ConfirmationDateTime is not None or
            self.ConfirmationStatusCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PartnerConfirmationStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerConfirmationStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PartnerConfirmationStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PartnerConfirmationStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartnerInformation is not None:
            self.PartnerInformation.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
        if self.ConfirmationDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConfirmationDateTime>%s</%sConfirmationDateTime>%s' % (namespace_, self.gds_format_datetime(self.ConfirmationDateTime, input_name='ConfirmationDateTime'), namespace_, eol_))
        if self.ConfirmationStatusCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConfirmationStatusCode>%s</%sConfirmationStatusCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConfirmationStatusCode).encode(ExternalEncoding), input_name='ConfirmationStatusCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PartnerConfirmationStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PartnerInformation is not None:
            showIndent(outfile, level)
            outfile.write('PartnerInformation=model_.PartnerInformation(\n')
            self.PartnerInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfirmationDateTime is not None:
            showIndent(outfile, level)
            outfile.write('ConfirmationDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.ConfirmationDateTime, input_name='ConfirmationDateTime'))
        if self.ConfirmationStatusCode is not None:
            showIndent(outfile, level)
            outfile.write('ConfirmationStatusCode=%s,\n' % quote_python(self.ConfirmationStatusCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.set_PartnerInformation(obj_)
        elif nodeName_ == 'ConfirmationDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'ConfirmationDateTime')
            self.ConfirmationDateTime = dval_
        elif nodeName_ == 'ConfirmationStatusCode':
            ConfirmationStatusCode_ = child_.text
            ConfirmationStatusCode_ = self.gds_validate_string(ConfirmationStatusCode_, node, 'ConfirmationStatusCode')
            self.ConfirmationStatusCode = ConfirmationStatusCode_
# end class PartnerConfirmationStatusType


class PartnerEventAction(GeneratedsSuper):
    """Structure which contains information about the Partner's action in
    the transaction, such as created by."""
    subclass = None
    superclass = None
    def __init__(self, PartnerInformation=None, EventDateTime=None):
        self.PartnerInformation = PartnerInformation
        self.EventDateTime = EventDateTime
    def factory(*args_, **kwargs_):
        if PartnerEventAction.subclass:
            return PartnerEventAction.subclass(*args_, **kwargs_)
        else:
            return PartnerEventAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def get_EventDateTime(self): return self.EventDateTime
    def set_EventDateTime(self, EventDateTime): self.EventDateTime = EventDateTime
    def hasContent_(self):
        if (
            self.PartnerInformation is not None or
            self.EventDateTime is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PartnerEventAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerEventAction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PartnerEventAction'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PartnerEventAction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartnerInformation is not None:
            self.PartnerInformation.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
        if self.EventDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEventDateTime>%s</%sEventDateTime>%s' % (namespace_, self.gds_format_datetime(self.EventDateTime, input_name='EventDateTime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PartnerEventAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PartnerInformation is not None:
            showIndent(outfile, level)
            outfile.write('PartnerInformation=model_.PartnerInformation(\n')
            self.PartnerInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EventDateTime is not None:
            showIndent(outfile, level)
            outfile.write('EventDateTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.EventDateTime, input_name='EventDateTime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.set_PartnerInformation(obj_)
        elif nodeName_ == 'EventDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'EventDateTime')
            self.EventDateTime = dval_
# end class PartnerEventAction


class PipelineEventInformationType(GeneratedsSuper):
    """Structure which contains information about the Pipeline Event in the
    transaction."""
    subclass = None
    superclass = None
    def __init__(self, PipelineEvent=None, PipelineEventVolumeAffect=None, PipelineEventStatus=None, PipelineEventDescription=None, PipelineCustodyEvent=None, AllowPartnerChange=None, AffectShipperInventory=None):
        self.PipelineEvent = PipelineEvent
        self.PipelineEventVolumeAffect = PipelineEventVolumeAffect
        self.PipelineEventStatus = PipelineEventStatus
        self.PipelineEventDescription = PipelineEventDescription
        self.PipelineCustodyEvent = PipelineCustodyEvent
        self.AllowPartnerChange = AllowPartnerChange
        self.AffectShipperInventory = AffectShipperInventory
    def factory(*args_, **kwargs_):
        if PipelineEventInformationType.subclass:
            return PipelineEventInformationType.subclass(*args_, **kwargs_)
        else:
            return PipelineEventInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PipelineEvent(self): return self.PipelineEvent
    def set_PipelineEvent(self, PipelineEvent): self.PipelineEvent = PipelineEvent
    def get_PipelineEventVolumeAffect(self): return self.PipelineEventVolumeAffect
    def set_PipelineEventVolumeAffect(self, PipelineEventVolumeAffect): self.PipelineEventVolumeAffect = PipelineEventVolumeAffect
    def get_PipelineEventStatus(self): return self.PipelineEventStatus
    def set_PipelineEventStatus(self, PipelineEventStatus): self.PipelineEventStatus = PipelineEventStatus
    def get_PipelineEventDescription(self): return self.PipelineEventDescription
    def set_PipelineEventDescription(self, PipelineEventDescription): self.PipelineEventDescription = PipelineEventDescription
    def get_PipelineCustodyEvent(self): return self.PipelineCustodyEvent
    def set_PipelineCustodyEvent(self, PipelineCustodyEvent): self.PipelineCustodyEvent = PipelineCustodyEvent
    def get_AllowPartnerChange(self): return self.AllowPartnerChange
    def set_AllowPartnerChange(self, AllowPartnerChange): self.AllowPartnerChange = AllowPartnerChange
    def get_AffectShipperInventory(self): return self.AffectShipperInventory
    def set_AffectShipperInventory(self, AffectShipperInventory): self.AffectShipperInventory = AffectShipperInventory
    def hasContent_(self):
        if (
            self.PipelineEvent is not None or
            self.PipelineEventVolumeAffect is not None or
            self.PipelineEventStatus is not None or
            self.PipelineEventDescription is not None or
            self.PipelineCustodyEvent is not None or
            self.AllowPartnerChange is not None or
            self.AffectShipperInventory is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PipelineEventInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineEventInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PipelineEventInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PipelineEventInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PipelineEvent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPipelineEvent>%s</%sPipelineEvent>%s' % (namespace_, self.gds_format_string(quote_xml(self.PipelineEvent).encode(ExternalEncoding), input_name='PipelineEvent'), namespace_, eol_))
        if self.PipelineEventVolumeAffect is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPipelineEventVolumeAffect>%s</%sPipelineEventVolumeAffect>%s' % (namespace_, self.gds_format_string(quote_xml(self.PipelineEventVolumeAffect).encode(ExternalEncoding), input_name='PipelineEventVolumeAffect'), namespace_, eol_))
        if self.PipelineEventStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPipelineEventStatus>%s</%sPipelineEventStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.PipelineEventStatus).encode(ExternalEncoding), input_name='PipelineEventStatus'), namespace_, eol_))
        if self.PipelineEventDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPipelineEventDescription>%s</%sPipelineEventDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.PipelineEventDescription).encode(ExternalEncoding), input_name='PipelineEventDescription'), namespace_, eol_))
        if self.PipelineCustodyEvent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPipelineCustodyEvent>%s</%sPipelineCustodyEvent>%s' % (namespace_, self.gds_format_string(quote_xml(self.PipelineCustodyEvent).encode(ExternalEncoding), input_name='PipelineCustodyEvent'), namespace_, eol_))
        if self.AllowPartnerChange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllowPartnerChange>%s</%sAllowPartnerChange>%s' % (namespace_, self.gds_format_string(quote_xml(self.AllowPartnerChange).encode(ExternalEncoding), input_name='AllowPartnerChange'), namespace_, eol_))
        if self.AffectShipperInventory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAffectShipperInventory>%s</%sAffectShipperInventory>%s' % (namespace_, self.gds_format_string(quote_xml(self.AffectShipperInventory).encode(ExternalEncoding), input_name='AffectShipperInventory'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PipelineEventInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PipelineEvent is not None:
            showIndent(outfile, level)
            outfile.write('PipelineEvent=%s,\n' % quote_python(self.PipelineEvent).encode(ExternalEncoding))
        if self.PipelineEventVolumeAffect is not None:
            showIndent(outfile, level)
            outfile.write('PipelineEventVolumeAffect=%s,\n' % quote_python(self.PipelineEventVolumeAffect).encode(ExternalEncoding))
        if self.PipelineEventStatus is not None:
            showIndent(outfile, level)
            outfile.write('PipelineEventStatus=%s,\n' % quote_python(self.PipelineEventStatus).encode(ExternalEncoding))
        if self.PipelineEventDescription is not None:
            showIndent(outfile, level)
            outfile.write('PipelineEventDescription=%s,\n' % quote_python(self.PipelineEventDescription).encode(ExternalEncoding))
        if self.PipelineCustodyEvent is not None:
            showIndent(outfile, level)
            outfile.write('PipelineCustodyEvent=%s,\n' % quote_python(self.PipelineCustodyEvent).encode(ExternalEncoding))
        if self.AllowPartnerChange is not None:
            showIndent(outfile, level)
            outfile.write('AllowPartnerChange=%s,\n' % quote_python(self.AllowPartnerChange).encode(ExternalEncoding))
        if self.AffectShipperInventory is not None:
            showIndent(outfile, level)
            outfile.write('AffectShipperInventory=%s,\n' % quote_python(self.AffectShipperInventory).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PipelineEvent':
            PipelineEvent_ = child_.text
            PipelineEvent_ = self.gds_validate_string(PipelineEvent_, node, 'PipelineEvent')
            self.PipelineEvent = PipelineEvent_
        elif nodeName_ == 'PipelineEventVolumeAffect':
            PipelineEventVolumeAffect_ = child_.text
            PipelineEventVolumeAffect_ = self.gds_validate_string(PipelineEventVolumeAffect_, node, 'PipelineEventVolumeAffect')
            self.PipelineEventVolumeAffect = PipelineEventVolumeAffect_
        elif nodeName_ == 'PipelineEventStatus':
            PipelineEventStatus_ = child_.text
            PipelineEventStatus_ = self.gds_validate_string(PipelineEventStatus_, node, 'PipelineEventStatus')
            self.PipelineEventStatus = PipelineEventStatus_
        elif nodeName_ == 'PipelineEventDescription':
            PipelineEventDescription_ = child_.text
            PipelineEventDescription_ = self.gds_validate_string(PipelineEventDescription_, node, 'PipelineEventDescription')
            self.PipelineEventDescription = PipelineEventDescription_
        elif nodeName_ == 'PipelineCustodyEvent':
            PipelineCustodyEvent_ = child_.text
            PipelineCustodyEvent_ = self.gds_validate_string(PipelineCustodyEvent_, node, 'PipelineCustodyEvent')
            self.PipelineCustodyEvent = PipelineCustodyEvent_
        elif nodeName_ == 'AllowPartnerChange':
            AllowPartnerChange_ = child_.text
            AllowPartnerChange_ = self.gds_validate_string(AllowPartnerChange_, node, 'AllowPartnerChange')
            self.AllowPartnerChange = AllowPartnerChange_
        elif nodeName_ == 'AffectShipperInventory':
            AffectShipperInventory_ = child_.text
            AffectShipperInventory_ = self.gds_validate_string(AffectShipperInventory_, node, 'AffectShipperInventory')
            self.AffectShipperInventory = AffectShipperInventory_
# end class PipelineEventInformationType


class ProductCharacteristicsType(GeneratedsSuper):
    """Indicates whether the product is additized and if so, with what.
    Additives are proprietary if it is the proprietary additive of
    the final seller of the product.The numeric value of the cetane
    or octane. For example, 87.0 would be a typical octane value for
    gasoline; 42.0 would be a typical cetane value for #2 diesel.A
    single alpha-numeric character indicating if the product
    contains a dye. Acceptable values are: Y=Yes, N=No.Indicates
    whether the product is fungible or segregated.Regulatory Oxy
    percentage. This is a percentage value (e.g. 2.7 means
    2.7%).Volume percent of oxygenate. This is a percentage value
    (e.g. 10.0 means 10%).Indicates whether the product type is
    reformulated gasoline.Reid Vapor Pressure. This is a percentage
    value (e.g. 8.5 means 8.5%).A numeric indication of the sulphur
    content of the product. This is a percentage value (e.g. 1.0
    means 1%). (If the sulphur content is .06% or higher, the
    product is considered to be a high sulphur product. If the
    sulphur content is .05% or lower, the product is considered to
    be a low sulphur product.)"""
    subclass = None
    superclass = None
    def __init__(self, DyesFlag=None, OXY=None, CetaneOctane=None, FungibleSegregated=None, SulfurContent=None, RVP=None, Additized=None, OxygenatePercent=None, RFGFlag=None):
        self.DyesFlag = _cast(None, DyesFlag)
        self.OXY = _cast(float, OXY)
        self.CetaneOctane = _cast(float, CetaneOctane)
        self.FungibleSegregated = _cast(None, FungibleSegregated)
        self.SulfurContent = _cast(float, SulfurContent)
        self.RVP = _cast(float, RVP)
        self.Additized = _cast(None, Additized)
        self.OxygenatePercent = _cast(float, OxygenatePercent)
        self.RFGFlag = _cast(bool, RFGFlag)
        pass
    def factory(*args_, **kwargs_):
        if ProductCharacteristicsType.subclass:
            return ProductCharacteristicsType.subclass(*args_, **kwargs_)
        else:
            return ProductCharacteristicsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DyesFlag(self): return self.DyesFlag
    def set_DyesFlag(self, DyesFlag): self.DyesFlag = DyesFlag
    def get_OXY(self): return self.OXY
    def set_OXY(self, OXY): self.OXY = OXY
    def get_CetaneOctane(self): return self.CetaneOctane
    def set_CetaneOctane(self, CetaneOctane): self.CetaneOctane = CetaneOctane
    def get_FungibleSegregated(self): return self.FungibleSegregated
    def set_FungibleSegregated(self, FungibleSegregated): self.FungibleSegregated = FungibleSegregated
    def get_SulfurContent(self): return self.SulfurContent
    def set_SulfurContent(self, SulfurContent): self.SulfurContent = SulfurContent
    def get_RVP(self): return self.RVP
    def set_RVP(self, RVP): self.RVP = RVP
    def get_Additized(self): return self.Additized
    def set_Additized(self, Additized): self.Additized = Additized
    def get_OxygenatePercent(self): return self.OxygenatePercent
    def set_OxygenatePercent(self, OxygenatePercent): self.OxygenatePercent = OxygenatePercent
    def get_RFGFlag(self): return self.RFGFlag
    def set_RFGFlag(self, RFGFlag): self.RFGFlag = RFGFlag
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ProductCharacteristicsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductCharacteristicsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ProductCharacteristicsType'):
        if self.DyesFlag is not None and 'DyesFlag' not in already_processed:
            already_processed.add('DyesFlag')
            outfile.write(' DyesFlag=%s' % (self.gds_format_string(quote_attrib(self.DyesFlag).encode(ExternalEncoding), input_name='DyesFlag'), ))
        if self.OXY is not None and 'OXY' not in already_processed:
            already_processed.add('OXY')
            outfile.write(' OXY="%s"' % self.gds_format_float(self.OXY, input_name='OXY'))
        if self.CetaneOctane is not None and 'CetaneOctane' not in already_processed:
            already_processed.add('CetaneOctane')
            outfile.write(' CetaneOctane="%s"' % self.gds_format_float(self.CetaneOctane, input_name='CetaneOctane'))
        if self.FungibleSegregated is not None and 'FungibleSegregated' not in already_processed:
            already_processed.add('FungibleSegregated')
            outfile.write(' FungibleSegregated=%s' % (quote_attrib(self.FungibleSegregated), ))
        if self.SulfurContent is not None and 'SulfurContent' not in already_processed:
            already_processed.add('SulfurContent')
            outfile.write(' SulfurContent="%s"' % self.gds_format_float(self.SulfurContent, input_name='SulfurContent'))
        if self.RVP is not None and 'RVP' not in already_processed:
            already_processed.add('RVP')
            outfile.write(' RVP="%s"' % self.gds_format_float(self.RVP, input_name='RVP'))
        if self.Additized is not None and 'Additized' not in already_processed:
            already_processed.add('Additized')
            outfile.write(' Additized=%s' % (quote_attrib(self.Additized), ))
        if self.OxygenatePercent is not None and 'OxygenatePercent' not in already_processed:
            already_processed.add('OxygenatePercent')
            outfile.write(' OxygenatePercent="%s"' % self.gds_format_float(self.OxygenatePercent, input_name='OxygenatePercent'))
        if self.RFGFlag is not None and 'RFGFlag' not in already_processed:
            already_processed.add('RFGFlag')
            outfile.write(' RFGFlag="%s"' % self.gds_format_boolean(self.RFGFlag, input_name='RFGFlag'))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ProductCharacteristicsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ProductCharacteristicsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DyesFlag is not None and 'DyesFlag' not in already_processed:
            already_processed.add('DyesFlag')
            showIndent(outfile, level)
            outfile.write('DyesFlag = "%s",\n' % (self.DyesFlag,))
        if self.OXY is not None and 'OXY' not in already_processed:
            already_processed.add('OXY')
            showIndent(outfile, level)
            outfile.write('OXY = %f,\n' % (self.OXY,))
        if self.CetaneOctane is not None and 'CetaneOctane' not in already_processed:
            already_processed.add('CetaneOctane')
            showIndent(outfile, level)
            outfile.write('CetaneOctane = %f,\n' % (self.CetaneOctane,))
        if self.FungibleSegregated is not None and 'FungibleSegregated' not in already_processed:
            already_processed.add('FungibleSegregated')
            showIndent(outfile, level)
            outfile.write('FungibleSegregated = %s,\n' % (self.FungibleSegregated,))
        if self.SulfurContent is not None and 'SulfurContent' not in already_processed:
            already_processed.add('SulfurContent')
            showIndent(outfile, level)
            outfile.write('SulfurContent = %f,\n' % (self.SulfurContent,))
        if self.RVP is not None and 'RVP' not in already_processed:
            already_processed.add('RVP')
            showIndent(outfile, level)
            outfile.write('RVP = %f,\n' % (self.RVP,))
        if self.Additized is not None and 'Additized' not in already_processed:
            already_processed.add('Additized')
            showIndent(outfile, level)
            outfile.write('Additized = %s,\n' % (self.Additized,))
        if self.OxygenatePercent is not None and 'OxygenatePercent' not in already_processed:
            already_processed.add('OxygenatePercent')
            showIndent(outfile, level)
            outfile.write('OxygenatePercent = %f,\n' % (self.OxygenatePercent,))
        if self.RFGFlag is not None and 'RFGFlag' not in already_processed:
            already_processed.add('RFGFlag')
            showIndent(outfile, level)
            outfile.write('RFGFlag = %s,\n' % (self.RFGFlag,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DyesFlag', node)
        if value is not None and 'DyesFlag' not in already_processed:
            already_processed.add('DyesFlag')
            self.DyesFlag = value
        value = find_attr_value_('OXY', node)
        if value is not None and 'OXY' not in already_processed:
            already_processed.add('OXY')
            try:
                self.OXY = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (OXY): %s' % exp)
        value = find_attr_value_('CetaneOctane', node)
        if value is not None and 'CetaneOctane' not in already_processed:
            already_processed.add('CetaneOctane')
            try:
                self.CetaneOctane = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (CetaneOctane): %s' % exp)
        value = find_attr_value_('FungibleSegregated', node)
        if value is not None and 'FungibleSegregated' not in already_processed:
            already_processed.add('FungibleSegregated')
            self.FungibleSegregated = value
        value = find_attr_value_('SulfurContent', node)
        if value is not None and 'SulfurContent' not in already_processed:
            already_processed.add('SulfurContent')
            try:
                self.SulfurContent = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (SulfurContent): %s' % exp)
        value = find_attr_value_('RVP', node)
        if value is not None and 'RVP' not in already_processed:
            already_processed.add('RVP')
            try:
                self.RVP = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (RVP): %s' % exp)
        value = find_attr_value_('Additized', node)
        if value is not None and 'Additized' not in already_processed:
            already_processed.add('Additized')
            self.Additized = value
        value = find_attr_value_('OxygenatePercent', node)
        if value is not None and 'OxygenatePercent' not in already_processed:
            already_processed.add('OxygenatePercent')
            try:
                self.OxygenatePercent = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (OxygenatePercent): %s' % exp)
        value = find_attr_value_('RFGFlag', node)
        if value is not None and 'RFGFlag' not in already_processed:
            already_processed.add('RFGFlag')
            if value in ('true', '1'):
                self.RFGFlag = True
            elif value in ('false', '0'):
                self.RFGFlag = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductCharacteristicsType


class ProductType(GeneratedsSuper):
    """A code which identifies the product loaded. Codes used are the Oil
    Industry Common Product Codes. The codes are maintained and
    available from the PIDX Downstream E-Business Subcommittee. If
    there was no blending, the Component and Finished Product Codes
    should be the same code."""
    subclass = None
    superclass = None
    def __init__(self, ProductCode=None, ProductName=None, ProductDescription=None, GrossQuantity=None, Temperature=None, Gravity=None, NetQuantity=None, ProductCharacteristics=None, extensiontype_=None):
        self.ProductCode = _cast(None, ProductCode)
        self.ProductName = _cast(None, ProductName)
        self.ProductDescription = ProductDescription
        self.GrossQuantity = GrossQuantity
        self.Temperature = Temperature
        self.Gravity = Gravity
        self.NetQuantity = NetQuantity
        self.ProductCharacteristics = ProductCharacteristics
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ProductType.subclass:
            return ProductType.subclass(*args_, **kwargs_)
        else:
            return ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductDescription(self): return self.ProductDescription
    def set_ProductDescription(self, ProductDescription): self.ProductDescription = ProductDescription
    def get_GrossQuantity(self): return self.GrossQuantity
    def set_GrossQuantity(self, GrossQuantity): self.GrossQuantity = GrossQuantity
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_Gravity(self): return self.Gravity
    def set_Gravity(self, Gravity): self.Gravity = Gravity
    def get_NetQuantity(self): return self.NetQuantity
    def set_NetQuantity(self, NetQuantity): self.NetQuantity = NetQuantity
    def get_ProductCharacteristics(self): return self.ProductCharacteristics
    def set_ProductCharacteristics(self, ProductCharacteristics): self.ProductCharacteristics = ProductCharacteristics
    def get_ProductCode(self): return self.ProductCode
    def set_ProductCode(self, ProductCode): self.ProductCode = ProductCode
    def get_ProductName(self): return self.ProductName
    def set_ProductName(self, ProductName): self.ProductName = ProductName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.ProductDescription is not None or
            self.GrossQuantity is not None or
            self.Temperature is not None or
            self.Gravity is not None or
            self.NetQuantity is not None or
            self.ProductCharacteristics is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ProductType'):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            outfile.write(' ProductCode=%s' % (self.gds_format_string(quote_attrib(self.ProductCode).encode(ExternalEncoding), input_name='ProductCode'), ))
        if self.ProductName is not None and 'ProductName' not in already_processed:
            already_processed.add('ProductName')
            outfile.write(' ProductName=%s' % (self.gds_format_string(quote_attrib(self.ProductName).encode(ExternalEncoding), input_name='ProductName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ProductType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProductDescription is not None:
            self.ProductDescription.export(outfile, level, namespace_, name_='ProductDescription', pretty_print=pretty_print)
        if self.GrossQuantity is not None:
            self.GrossQuantity.export(outfile, level, namespace_, name_='GrossQuantity', pretty_print=pretty_print)
        if self.Temperature is not None:
            self.Temperature.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.Gravity is not None:
            self.Gravity.export(outfile, level, namespace_, name_='Gravity', pretty_print=pretty_print)
        if self.NetQuantity is not None:
            self.NetQuantity.export(outfile, level, namespace_, name_='NetQuantity', pretty_print=pretty_print)
        if self.ProductCharacteristics is not None:
            self.ProductCharacteristics.export(outfile, level, namespace_, name_='ProductCharacteristics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            showIndent(outfile, level)
            outfile.write('ProductCode = "%s",\n' % (self.ProductCode,))
        if self.ProductName is not None and 'ProductName' not in already_processed:
            already_processed.add('ProductName')
            showIndent(outfile, level)
            outfile.write('ProductName = "%s",\n' % (self.ProductName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProductDescription is not None:
            showIndent(outfile, level)
            outfile.write('ProductDescription=model_.ProductDescription(\n')
            self.ProductDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GrossQuantity is not None:
            showIndent(outfile, level)
            outfile.write('GrossQuantity=model_.GrossQuantity(\n')
            self.GrossQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Temperature is not None:
            showIndent(outfile, level)
            outfile.write('Temperature=model_.Temperature(\n')
            self.Temperature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Gravity is not None:
            showIndent(outfile, level)
            outfile.write('Gravity=model_.Gravity(\n')
            self.Gravity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NetQuantity is not None:
            showIndent(outfile, level)
            outfile.write('NetQuantity=model_.NetQuantity(\n')
            self.NetQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProductCharacteristics is not None:
            showIndent(outfile, level)
            outfile.write('ProductCharacteristics=model_.ProductCharacteristics(\n')
            self.ProductCharacteristics.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ProductCode', node)
        if value is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            self.ProductCode = value
        value = find_attr_value_('ProductName', node)
        if value is not None and 'ProductName' not in already_processed:
            already_processed.add('ProductName')
            self.ProductName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProductDescription':
            obj_ = DescriptionType.factory()
            obj_.build(child_)
            self.set_ProductDescription(obj_)
        elif nodeName_ == 'GrossQuantity':
            obj_ = GrossQuantity.factory()
            obj_.build(child_)
            self.set_GrossQuantity(obj_)
        elif nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.set_Temperature(obj_)
        elif nodeName_ == 'Gravity':
            obj_ = Gravity.factory()
            obj_.build(child_)
            self.set_Gravity(obj_)
        elif nodeName_ == 'NetQuantity':
            obj_ = NetQuantity.factory()
            obj_.build(child_)
            self.set_NetQuantity(obj_)
        elif nodeName_ == 'ProductCharacteristics':
            obj_ = ProductCharacteristicsType.factory()
            obj_.build(child_)
            self.set_ProductCharacteristics(obj_)
# end class ProductType


class QuantityType(GeneratedsSuper):
    """Type holding the structure for quantity elements."""
    subclass = None
    superclass = None
    def __init__(self, Quantity=None, UnitOfMeasureCode=None):
        self.Quantity = Quantity
        self.UnitOfMeasureCode = UnitOfMeasureCode
    def factory(*args_, **kwargs_):
        if QuantityType.subclass:
            return QuantityType.subclass(*args_, **kwargs_)
        else:
            return QuantityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_UnitOfMeasureCode(self): return self.UnitOfMeasureCode
    def set_UnitOfMeasureCode(self, UnitOfMeasureCode): self.UnitOfMeasureCode = UnitOfMeasureCode
    def hasContent_(self):
        if (
            self.Quantity is not None or
            self.UnitOfMeasureCode is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='QuantityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='QuantityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='QuantityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuantity>%s</%sQuantity>%s' % (namespace_, self.gds_format_float(self.Quantity, input_name='Quantity'), namespace_, eol_))
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasureCode>%s</%sUnitOfMeasureCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnitOfMeasureCode).encode(ExternalEncoding), input_name='UnitOfMeasureCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='QuantityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Quantity is not None:
            showIndent(outfile, level)
            outfile.write('Quantity=%f,\n' % self.Quantity)
        if self.UnitOfMeasureCode is not None:
            showIndent(outfile, level)
            outfile.write('UnitOfMeasureCode=%s,\n' % quote_python(self.UnitOfMeasureCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Quantity')
            self.Quantity = fval_
        elif nodeName_ == 'UnitOfMeasureCode':
            UnitOfMeasureCode_ = child_.text
            UnitOfMeasureCode_ = self.gds_validate_string(UnitOfMeasureCode_, node, 'UnitOfMeasureCode')
            self.UnitOfMeasureCode = UnitOfMeasureCode_
# end class QuantityType


class ReceiptLineItemsType(LineItemsType):
    subclass = None
    superclass = LineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, StorageTankIdentifier=None):
        super(ReceiptLineItemsType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, )
        self.StorageTankIdentifier = StorageTankIdentifier
    def factory(*args_, **kwargs_):
        if ReceiptLineItemsType.subclass:
            return ReceiptLineItemsType.subclass(*args_, **kwargs_)
        else:
            return ReceiptLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StorageTankIdentifier(self): return self.StorageTankIdentifier
    def set_StorageTankIdentifier(self, StorageTankIdentifier): self.StorageTankIdentifier = StorageTankIdentifier
    def hasContent_(self):
        if (
            self.StorageTankIdentifier is not None or
            super(ReceiptLineItemsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ReceiptLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReceiptLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ReceiptLineItemsType'):
        super(ReceiptLineItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReceiptLineItemsType')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ReceiptLineItemsType', fromsubclass_=False, pretty_print=True):
        super(ReceiptLineItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageTankIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageTankIdentifier>%s</%sStorageTankIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.StorageTankIdentifier).encode(ExternalEncoding), input_name='StorageTankIdentifier'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReceiptLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReceiptLineItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReceiptLineItemsType, self).exportLiteralChildren(outfile, level, name_)
        if self.StorageTankIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('StorageTankIdentifier=%s,\n' % quote_python(self.StorageTankIdentifier).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ReceiptLineItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageTankIdentifier':
            StorageTankIdentifier_ = child_.text
            StorageTankIdentifier_ = self.gds_validate_string(StorageTankIdentifier_, node, 'StorageTankIdentifier')
            self.StorageTankIdentifier = StorageTankIdentifier_
        super(ReceiptLineItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class ReceiptLineItemsType


class SuccessType(GeneratedsSuper):
    """Standard way to indicate successful processing of an OTA message.
    Returning an empty element of this type indicates success."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if SuccessType.subclass:
            return SuccessType.subclass(*args_, **kwargs_)
        else:
            return SuccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SuccessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SuccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SuccessType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SuccessType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SuccessType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SuccessType


class TaxType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxTypeCode=None, MixedRateIndicator=None, TaxIdentifierNumber=None, TaxExemptCode=None, TaxLocation=None, TaxRate=None, TaxBasisAmount=None, TaxAmount=None, TaxReference=None, DeferredAmount=None, extensiontype_=None):
        self.TaxTypeCode = TaxTypeCode
        self.MixedRateIndicator = MixedRateIndicator
        self.TaxIdentifierNumber = TaxIdentifierNumber
        self.TaxExemptCode = TaxExemptCode
        self.TaxLocation = TaxLocation
        self.TaxRate = TaxRate
        self.TaxBasisAmount = TaxBasisAmount
        self.TaxAmount = TaxAmount
        self.TaxReference = TaxReference
        self.DeferredAmount = DeferredAmount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TaxType.subclass:
            return TaxType.subclass(*args_, **kwargs_)
        else:
            return TaxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxTypeCode(self): return self.TaxTypeCode
    def set_TaxTypeCode(self, TaxTypeCode): self.TaxTypeCode = TaxTypeCode
    def get_MixedRateIndicator(self): return self.MixedRateIndicator
    def set_MixedRateIndicator(self, MixedRateIndicator): self.MixedRateIndicator = MixedRateIndicator
    def get_TaxIdentifierNumber(self): return self.TaxIdentifierNumber
    def set_TaxIdentifierNumber(self, TaxIdentifierNumber): self.TaxIdentifierNumber = TaxIdentifierNumber
    def get_TaxExemptCode(self): return self.TaxExemptCode
    def set_TaxExemptCode(self, TaxExemptCode): self.TaxExemptCode = TaxExemptCode
    def get_TaxLocation(self): return self.TaxLocation
    def set_TaxLocation(self, TaxLocation): self.TaxLocation = TaxLocation
    def get_TaxRate(self): return self.TaxRate
    def set_TaxRate(self, TaxRate): self.TaxRate = TaxRate
    def get_TaxBasisAmount(self): return self.TaxBasisAmount
    def set_TaxBasisAmount(self, TaxBasisAmount): self.TaxBasisAmount = TaxBasisAmount
    def get_TaxAmount(self): return self.TaxAmount
    def set_TaxAmount(self, TaxAmount): self.TaxAmount = TaxAmount
    def get_TaxReference(self): return self.TaxReference
    def set_TaxReference(self, TaxReference): self.TaxReference = TaxReference
    def get_DeferredAmount(self): return self.DeferredAmount
    def set_DeferredAmount(self, DeferredAmount): self.DeferredAmount = DeferredAmount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.TaxTypeCode is not None or
            self.MixedRateIndicator is not None or
            self.TaxIdentifierNumber is not None or
            self.TaxExemptCode is not None or
            self.TaxLocation is not None or
            self.TaxRate is not None or
            self.TaxBasisAmount is not None or
            self.TaxAmount is not None or
            self.TaxReference is not None or
            self.DeferredAmount is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TaxType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TaxType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TaxType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxTypeCode>%s</%sTaxTypeCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TaxTypeCode).encode(ExternalEncoding), input_name='TaxTypeCode'), namespace_, eol_))
        if self.MixedRateIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMixedRateIndicator>%s</%sMixedRateIndicator>%s' % (namespace_, self.gds_format_string(quote_xml(self.MixedRateIndicator).encode(ExternalEncoding), input_name='MixedRateIndicator'), namespace_, eol_))
        if self.TaxIdentifierNumber is not None:
            self.TaxIdentifierNumber.export(outfile, level, namespace_, name_='TaxIdentifierNumber', pretty_print=pretty_print)
        if self.TaxExemptCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxExemptCode>%s</%sTaxExemptCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TaxExemptCode).encode(ExternalEncoding), input_name='TaxExemptCode'), namespace_, eol_))
        if self.TaxLocation is not None:
            self.TaxLocation.export(outfile, level, namespace_, name_='TaxLocation', pretty_print=pretty_print)
        if self.TaxRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxRate>%s</%sTaxRate>%s' % (namespace_, self.gds_format_float(self.TaxRate, input_name='TaxRate'), namespace_, eol_))
        if self.TaxBasisAmount is not None:
            self.TaxBasisAmount.export(outfile, level, namespace_, name_='TaxBasisAmount', pretty_print=pretty_print)
        if self.TaxAmount is not None:
            self.TaxAmount.export(outfile, level, namespace_, name_='TaxAmount', pretty_print=pretty_print)
        if self.TaxReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxReference>%s</%sTaxReference>%s' % (namespace_, self.gds_format_string(quote_xml(self.TaxReference).encode(ExternalEncoding), input_name='TaxReference'), namespace_, eol_))
        if self.DeferredAmount is not None:
            self.DeferredAmount.export(outfile, level, namespace_, name_='DeferredAmount', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TaxType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TaxTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('TaxTypeCode=%s,\n' % quote_python(self.TaxTypeCode).encode(ExternalEncoding))
        if self.MixedRateIndicator is not None:
            showIndent(outfile, level)
            outfile.write('MixedRateIndicator=%s,\n' % quote_python(self.MixedRateIndicator).encode(ExternalEncoding))
        if self.TaxIdentifierNumber is not None:
            showIndent(outfile, level)
            outfile.write('TaxIdentifierNumber=model_.TaxIdentifierNumber(\n')
            self.TaxIdentifierNumber.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxExemptCode is not None:
            showIndent(outfile, level)
            outfile.write('TaxExemptCode=%s,\n' % quote_python(self.TaxExemptCode).encode(ExternalEncoding))
        if self.TaxLocation is not None:
            showIndent(outfile, level)
            outfile.write('TaxLocation=model_.TaxLocation(\n')
            self.TaxLocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxRate is not None:
            showIndent(outfile, level)
            outfile.write('TaxRate=%f,\n' % self.TaxRate)
        if self.TaxBasisAmount is not None:
            showIndent(outfile, level)
            outfile.write('TaxBasisAmount=model_.TaxBasisAmount(\n')
            self.TaxBasisAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxAmount is not None:
            showIndent(outfile, level)
            outfile.write('TaxAmount=model_.TaxAmount(\n')
            self.TaxAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TaxReference is not None:
            showIndent(outfile, level)
            outfile.write('TaxReference=%s,\n' % quote_python(self.TaxReference).encode(ExternalEncoding))
        if self.DeferredAmount is not None:
            showIndent(outfile, level)
            outfile.write('DeferredAmount=model_.DeferredAmount(\n')
            self.DeferredAmount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxTypeCode':
            TaxTypeCode_ = child_.text
            TaxTypeCode_ = self.gds_validate_string(TaxTypeCode_, node, 'TaxTypeCode')
            self.TaxTypeCode = TaxTypeCode_
        elif nodeName_ == 'MixedRateIndicator':
            MixedRateIndicator_ = child_.text
            MixedRateIndicator_ = self.gds_validate_string(MixedRateIndicator_, node, 'MixedRateIndicator')
            self.MixedRateIndicator = MixedRateIndicator_
        elif nodeName_ == 'TaxIdentifierNumber':
            obj_ = TaxIdentifierNumber.factory()
            obj_.build(child_)
            self.set_TaxIdentifierNumber(obj_)
        elif nodeName_ == 'TaxExemptCode':
            TaxExemptCode_ = child_.text
            TaxExemptCode_ = self.gds_validate_string(TaxExemptCode_, node, 'TaxExemptCode')
            self.TaxExemptCode = TaxExemptCode_
        elif nodeName_ == 'TaxLocation':
            obj_ = TaxLocation.factory()
            obj_.build(child_)
            self.set_TaxLocation(obj_)
        elif nodeName_ == 'TaxRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxRate')
            self.TaxRate = fval_
        elif nodeName_ == 'TaxBasisAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_TaxBasisAmount(obj_)
        elif nodeName_ == 'TaxAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_TaxAmount(obj_)
        elif nodeName_ == 'TaxReference':
            TaxReference_ = child_.text
            TaxReference_ = self.gds_validate_string(TaxReference_, node, 'TaxReference')
            self.TaxReference = TaxReference_
        elif nodeName_ == 'DeferredAmount':
            class_obj_ = self.get_class_obj_(child_, MonetaryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DeferredAmount(obj_)
# end class TaxType


class TerminalInformationType(GeneratedsSuper):
    """The four-character EPA-assigned ID for the entity (I believe this
    will be assigned to the operating company at the terminal)The
    five-character EPA-assigned ID for the facility. Filled with
    leading zeroes if applicable.An alpha-numeric field identifying
    the Internal Revenue Service’s Terminal Control Number. (Use
    “NON-IRS” if not applicable such as for an asphalt terminal
    or refinery)A numeric field used to identify the physical
    location of the terminal from which the product was withdrawn."""
    subclass = None
    superclass = None
    def __init__(self, TerminalSPLC=None, TerminalTimeZone=None, TerminalControlNumber=None, TerminalName=None, EPAFacilityID=None, EPAEntityID=None, AddressInformation=None):
        self.TerminalSPLC = _cast(None, TerminalSPLC)
        self.TerminalTimeZone = _cast(None, TerminalTimeZone)
        self.TerminalControlNumber = _cast(None, TerminalControlNumber)
        self.TerminalName = _cast(None, TerminalName)
        self.EPAFacilityID = _cast(None, EPAFacilityID)
        self.EPAEntityID = _cast(None, EPAEntityID)
        self.AddressInformation = AddressInformation
    def factory(*args_, **kwargs_):
        if TerminalInformationType.subclass:
            return TerminalInformationType.subclass(*args_, **kwargs_)
        else:
            return TerminalInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressInformation(self): return self.AddressInformation
    def set_AddressInformation(self, AddressInformation): self.AddressInformation = AddressInformation
    def get_TerminalSPLC(self): return self.TerminalSPLC
    def set_TerminalSPLC(self, TerminalSPLC): self.TerminalSPLC = TerminalSPLC
    def get_TerminalTimeZone(self): return self.TerminalTimeZone
    def set_TerminalTimeZone(self, TerminalTimeZone): self.TerminalTimeZone = TerminalTimeZone
    def get_TerminalControlNumber(self): return self.TerminalControlNumber
    def set_TerminalControlNumber(self, TerminalControlNumber): self.TerminalControlNumber = TerminalControlNumber
    def get_TerminalName(self): return self.TerminalName
    def set_TerminalName(self, TerminalName): self.TerminalName = TerminalName
    def get_EPAFacilityID(self): return self.EPAFacilityID
    def set_EPAFacilityID(self, EPAFacilityID): self.EPAFacilityID = EPAFacilityID
    def get_EPAEntityID(self): return self.EPAEntityID
    def set_EPAEntityID(self, EPAEntityID): self.EPAEntityID = EPAEntityID
    def hasContent_(self):
        if (
            self.AddressInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TerminalInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TerminalInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TerminalInformationType'):
        if self.TerminalSPLC is not None and 'TerminalSPLC' not in already_processed:
            already_processed.add('TerminalSPLC')
            outfile.write(' TerminalSPLC=%s' % (quote_attrib(self.TerminalSPLC), ))
        if self.TerminalTimeZone is not None and 'TerminalTimeZone' not in already_processed:
            already_processed.add('TerminalTimeZone')
            outfile.write(' TerminalTimeZone=%s' % (self.gds_format_string(quote_attrib(self.TerminalTimeZone).encode(ExternalEncoding), input_name='TerminalTimeZone'), ))
        if self.TerminalControlNumber is not None and 'TerminalControlNumber' not in already_processed:
            already_processed.add('TerminalControlNumber')
            outfile.write(' TerminalControlNumber=%s' % (self.gds_format_string(quote_attrib(self.TerminalControlNumber).encode(ExternalEncoding), input_name='TerminalControlNumber'), ))
        if self.TerminalName is not None and 'TerminalName' not in already_processed:
            already_processed.add('TerminalName')
            outfile.write(' TerminalName=%s' % (self.gds_format_string(quote_attrib(self.TerminalName).encode(ExternalEncoding), input_name='TerminalName'), ))
        if self.EPAFacilityID is not None and 'EPAFacilityID' not in already_processed:
            already_processed.add('EPAFacilityID')
            outfile.write(' EPAFacilityID=%s' % (self.gds_format_string(quote_attrib(self.EPAFacilityID).encode(ExternalEncoding), input_name='EPAFacilityID'), ))
        if self.EPAEntityID is not None and 'EPAEntityID' not in already_processed:
            already_processed.add('EPAEntityID')
            outfile.write(' EPAEntityID=%s' % (self.gds_format_string(quote_attrib(self.EPAEntityID).encode(ExternalEncoding), input_name='EPAEntityID'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TerminalInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressInformation is not None:
            self.AddressInformation.export(outfile, level, namespace_, name_='AddressInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TerminalInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TerminalSPLC is not None and 'TerminalSPLC' not in already_processed:
            already_processed.add('TerminalSPLC')
            showIndent(outfile, level)
            outfile.write('TerminalSPLC = %s,\n' % (self.TerminalSPLC,))
        if self.TerminalTimeZone is not None and 'TerminalTimeZone' not in already_processed:
            already_processed.add('TerminalTimeZone')
            showIndent(outfile, level)
            outfile.write('TerminalTimeZone = "%s",\n' % (self.TerminalTimeZone,))
        if self.TerminalControlNumber is not None and 'TerminalControlNumber' not in already_processed:
            already_processed.add('TerminalControlNumber')
            showIndent(outfile, level)
            outfile.write('TerminalControlNumber = "%s",\n' % (self.TerminalControlNumber,))
        if self.TerminalName is not None and 'TerminalName' not in already_processed:
            already_processed.add('TerminalName')
            showIndent(outfile, level)
            outfile.write('TerminalName = "%s",\n' % (self.TerminalName,))
        if self.EPAFacilityID is not None and 'EPAFacilityID' not in already_processed:
            already_processed.add('EPAFacilityID')
            showIndent(outfile, level)
            outfile.write('EPAFacilityID = "%s",\n' % (self.EPAFacilityID,))
        if self.EPAEntityID is not None and 'EPAEntityID' not in already_processed:
            already_processed.add('EPAEntityID')
            showIndent(outfile, level)
            outfile.write('EPAEntityID = "%s",\n' % (self.EPAEntityID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AddressInformation is not None:
            showIndent(outfile, level)
            outfile.write('AddressInformation=model_.AddressInformation(\n')
            self.AddressInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TerminalSPLC', node)
        if value is not None and 'TerminalSPLC' not in already_processed:
            already_processed.add('TerminalSPLC')
            self.TerminalSPLC = value
        value = find_attr_value_('TerminalTimeZone', node)
        if value is not None and 'TerminalTimeZone' not in already_processed:
            already_processed.add('TerminalTimeZone')
            self.TerminalTimeZone = value
        value = find_attr_value_('TerminalControlNumber', node)
        if value is not None and 'TerminalControlNumber' not in already_processed:
            already_processed.add('TerminalControlNumber')
            self.TerminalControlNumber = value
        value = find_attr_value_('TerminalName', node)
        if value is not None and 'TerminalName' not in already_processed:
            already_processed.add('TerminalName')
            self.TerminalName = value
        value = find_attr_value_('EPAFacilityID', node)
        if value is not None and 'EPAFacilityID' not in already_processed:
            already_processed.add('EPAFacilityID')
            self.EPAFacilityID = value
        value = find_attr_value_('EPAEntityID', node)
        if value is not None and 'EPAEntityID' not in already_processed:
            already_processed.add('EPAEntityID')
            self.EPAEntityID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressInformation':
            obj_ = AddressInformation.factory()
            obj_.build(child_)
            self.set_AddressInformation(obj_)
# end class TerminalInformationType


class WarningsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Warning=None):
        if Warning is None:
            self.Warning = []
        else:
            self.Warning = Warning
    def factory(*args_, **kwargs_):
        if WarningsType.subclass:
            return WarningsType.subclass(*args_, **kwargs_)
        else:
            return WarningsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Warning(self): return self.Warning
    def set_Warning(self, Warning): self.Warning = Warning
    def add_Warning(self, value): self.Warning.append(value)
    def insert_Warning(self, index, value): self.Warning[index] = value
    def hasContent_(self):
        if (
            self.Warning
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='WarningsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WarningsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='WarningsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='WarningsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Warning_ in self.Warning:
            Warning_.export(outfile, level, namespace_, name_='Warning', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='WarningsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Warning=[\n')
        level += 1
        for Warning_ in self.Warning:
            showIndent(outfile, level)
            outfile.write('model_.ErrorWarningType(\n')
            Warning_.exportLiteral(outfile, level, name_='ErrorWarningType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Warning':
            obj_ = ErrorWarningType.factory()
            obj_.build(child_)
            self.Warning.append(obj_)
# end class WarningsType


class WellIdentifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, wellIdentifierIndicator=None, valueOf_=None):
        self.wellIdentifierIndicator = _cast(None, wellIdentifierIndicator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if WellIdentifierType.subclass:
            return WellIdentifierType.subclass(*args_, **kwargs_)
        else:
            return WellIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wellIdentifierIndicator(self): return self.wellIdentifierIndicator
    def set_wellIdentifierIndicator(self, wellIdentifierIndicator): self.wellIdentifierIndicator = wellIdentifierIndicator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='WellIdentifierType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WellIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='WellIdentifierType'):
        if self.wellIdentifierIndicator is not None and 'wellIdentifierIndicator' not in already_processed:
            already_processed.add('wellIdentifierIndicator')
            outfile.write(' wellIdentifierIndicator=%s' % (self.gds_format_string(quote_attrib(self.wellIdentifierIndicator).encode(ExternalEncoding), input_name='wellIdentifierIndicator'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='WellIdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='WellIdentifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.wellIdentifierIndicator is not None and 'wellIdentifierIndicator' not in already_processed:
            already_processed.add('wellIdentifierIndicator')
            showIndent(outfile, level)
            outfile.write('wellIdentifierIndicator = "%s",\n' % (self.wellIdentifierIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('wellIdentifierIndicator', node)
        if value is not None and 'wellIdentifierIndicator' not in already_processed:
            already_processed.add('wellIdentifierIndicator')
            self.wellIdentifierIndicator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WellIdentifierType


class CompartmentInfoType(GeneratedsSuper):
    """An identifier used for the vehicle/transport involved. This should
    reference a VehicleNumber from
    CarrierInformation.VehicleInformation in the
    BillOfLadingHeader.Identifier the compartment within the
    vehicle/transport involved."""
    subclass = None
    superclass = None
    def __init__(self, CompartmentId=None, VehicleNumber=None):
        self.CompartmentId = _cast(None, CompartmentId)
        self.VehicleNumber = _cast(None, VehicleNumber)
        pass
    def factory(*args_, **kwargs_):
        if CompartmentInfoType.subclass:
            return CompartmentInfoType.subclass(*args_, **kwargs_)
        else:
            return CompartmentInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompartmentId(self): return self.CompartmentId
    def set_CompartmentId(self, CompartmentId): self.CompartmentId = CompartmentId
    def get_VehicleNumber(self): return self.VehicleNumber
    def set_VehicleNumber(self, VehicleNumber): self.VehicleNumber = VehicleNumber
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='CompartmentInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompartmentInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='CompartmentInfoType'):
        if self.CompartmentId is not None and 'CompartmentId' not in already_processed:
            already_processed.add('CompartmentId')
            outfile.write(' CompartmentId=%s' % (self.gds_format_string(quote_attrib(self.CompartmentId).encode(ExternalEncoding), input_name='CompartmentId'), ))
        if self.VehicleNumber is not None and 'VehicleNumber' not in already_processed:
            already_processed.add('VehicleNumber')
            outfile.write(' VehicleNumber=%s' % (self.gds_format_string(quote_attrib(self.VehicleNumber).encode(ExternalEncoding), input_name='VehicleNumber'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='CompartmentInfoType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CompartmentInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CompartmentId is not None and 'CompartmentId' not in already_processed:
            already_processed.add('CompartmentId')
            showIndent(outfile, level)
            outfile.write('CompartmentId = "%s",\n' % (self.CompartmentId,))
        if self.VehicleNumber is not None and 'VehicleNumber' not in already_processed:
            already_processed.add('VehicleNumber')
            showIndent(outfile, level)
            outfile.write('VehicleNumber = "%s",\n' % (self.VehicleNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CompartmentId', node)
        if value is not None and 'CompartmentId' not in already_processed:
            already_processed.add('CompartmentId')
            self.CompartmentId = value
        value = find_attr_value_('VehicleNumber', node)
        if value is not None and 'VehicleNumber' not in already_processed:
            already_processed.add('VehicleNumber')
            self.VehicleNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CompartmentInfoType


class AdvisingBankType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartnerInformation=None):
        self.PartnerInformation = PartnerInformation
    def factory(*args_, **kwargs_):
        if AdvisingBankType.subclass:
            return AdvisingBankType.subclass(*args_, **kwargs_)
        else:
            return AdvisingBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerInformation(self): return self.PartnerInformation
    def set_PartnerInformation(self, PartnerInformation): self.PartnerInformation = PartnerInformation
    def hasContent_(self):
        if (
            self.PartnerInformation is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AdvisingBankType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvisingBankType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AdvisingBankType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AdvisingBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartnerInformation is not None:
            self.PartnerInformation.export(outfile, level, namespace_, name_='PartnerInformation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AdvisingBankType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PartnerInformation is not None:
            showIndent(outfile, level)
            outfile.write('PartnerInformation=model_.PartnerInformation(\n')
            self.PartnerInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartnerInformation':
            obj_ = PartnerInformation.factory()
            obj_.build(child_)
            self.set_PartnerInformation(obj_)
# end class AdvisingBankType


class LetterOfCreditQuantityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MinimumQuantity=None, ActualQuantity=None, MaximumQuantity=None):
        self.MinimumQuantity = MinimumQuantity
        self.ActualQuantity = ActualQuantity
        self.MaximumQuantity = MaximumQuantity
    def factory(*args_, **kwargs_):
        if LetterOfCreditQuantityType.subclass:
            return LetterOfCreditQuantityType.subclass(*args_, **kwargs_)
        else:
            return LetterOfCreditQuantityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MinimumQuantity(self): return self.MinimumQuantity
    def set_MinimumQuantity(self, MinimumQuantity): self.MinimumQuantity = MinimumQuantity
    def get_ActualQuantity(self): return self.ActualQuantity
    def set_ActualQuantity(self, ActualQuantity): self.ActualQuantity = ActualQuantity
    def get_MaximumQuantity(self): return self.MaximumQuantity
    def set_MaximumQuantity(self, MaximumQuantity): self.MaximumQuantity = MaximumQuantity
    def hasContent_(self):
        if (
            self.MinimumQuantity is not None or
            self.ActualQuantity is not None or
            self.MaximumQuantity is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='LetterOfCreditQuantityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LetterOfCreditQuantityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='LetterOfCreditQuantityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='LetterOfCreditQuantityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MinimumQuantity is not None:
            self.MinimumQuantity.export(outfile, level, namespace_, name_='MinimumQuantity', pretty_print=pretty_print)
        if self.ActualQuantity is not None:
            self.ActualQuantity.export(outfile, level, namespace_, name_='ActualQuantity', pretty_print=pretty_print)
        if self.MaximumQuantity is not None:
            self.MaximumQuantity.export(outfile, level, namespace_, name_='MaximumQuantity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LetterOfCreditQuantityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MinimumQuantity is not None:
            showIndent(outfile, level)
            outfile.write('MinimumQuantity=model_.MinimumQuantity(\n')
            self.MinimumQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ActualQuantity is not None:
            showIndent(outfile, level)
            outfile.write('ActualQuantity=model_.ActualQuantity(\n')
            self.ActualQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MaximumQuantity is not None:
            showIndent(outfile, level)
            outfile.write('MaximumQuantity=model_.MaximumQuantity(\n')
            self.MaximumQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MinimumQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_MinimumQuantity(obj_)
        elif nodeName_ == 'ActualQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_ActualQuantity(obj_)
        elif nodeName_ == 'MaximumQuantity':
            obj_ = QuantityType.factory()
            obj_.build(child_)
            self.set_MaximumQuantity(obj_)
# end class LetterOfCreditQuantityType


class OrderResponseLineItemsType(OrderLineItemsType):
    subclass = None
    superclass = OrderLineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, RevisionNumber=None, ProductInformation=None, OrderQuantity=None, PackagingQuantity=None, LineItemPurposeCode=None, EngineeringChangeOrderIdentifier=None, BatchNumber=None, CountryOfOrigin=None, CountryOfFinalDestination=None, DeliveryTolerances=None, ShipmentTerms=None, ScheduleDateTime=None, ScheduleDateTimeRange=None, TransportInformation=None, RequestedDocument=None, Routing=None, SpecialServicesRequest=None, PackListRequirements=None, QuoteIdentifier=None, Label=None, ImportLicenseNeededFlag=None, ImportLicenseAvailableFlag=None, AccompanyingSampleCode=None, JobLocationClassCode=None, StatusCode=None, ResponseReason=None, extensiontype_=None):
        super(OrderResponseLineItemsType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, RevisionNumber, ProductInformation, OrderQuantity, PackagingQuantity, LineItemPurposeCode, EngineeringChangeOrderIdentifier, BatchNumber, CountryOfOrigin, CountryOfFinalDestination, DeliveryTolerances, ShipmentTerms, ScheduleDateTime, ScheduleDateTimeRange, TransportInformation, RequestedDocument, Routing, SpecialServicesRequest, PackListRequirements, QuoteIdentifier, Label, ImportLicenseNeededFlag, ImportLicenseAvailableFlag, AccompanyingSampleCode, JobLocationClassCode, extensiontype_, )
        self.StatusCode = StatusCode
        self.ResponseReason = ResponseReason
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if OrderResponseLineItemsType.subclass:
            return OrderResponseLineItemsType.subclass(*args_, **kwargs_)
        else:
            return OrderResponseLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StatusCode(self): return self.StatusCode
    def set_StatusCode(self, StatusCode): self.StatusCode = StatusCode
    def get_ResponseReason(self): return self.ResponseReason
    def set_ResponseReason(self, ResponseReason): self.ResponseReason = ResponseReason
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.StatusCode is not None or
            self.ResponseReason is not None or
            super(OrderResponseLineItemsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OrderResponseLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderResponseLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OrderResponseLineItemsType'):
        super(OrderResponseLineItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrderResponseLineItemsType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OrderResponseLineItemsType', fromsubclass_=False, pretty_print=True):
        super(OrderResponseLineItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StatusCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatusCode>%s</%sStatusCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.StatusCode).encode(ExternalEncoding), input_name='StatusCode'), namespace_, eol_))
        if self.ResponseReason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResponseReason>%s</%sResponseReason>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResponseReason).encode(ExternalEncoding), input_name='ResponseReason'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrderResponseLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrderResponseLineItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrderResponseLineItemsType, self).exportLiteralChildren(outfile, level, name_)
        if self.StatusCode is not None:
            showIndent(outfile, level)
            outfile.write('StatusCode=%s,\n' % quote_python(self.StatusCode).encode(ExternalEncoding))
        if self.ResponseReason is not None:
            showIndent(outfile, level)
            outfile.write('ResponseReason=%s,\n' % quote_python(self.ResponseReason).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OrderResponseLineItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StatusCode':
            StatusCode_ = child_.text
            StatusCode_ = self.gds_validate_string(StatusCode_, node, 'StatusCode')
            self.StatusCode = StatusCode_
        elif nodeName_ == 'ResponseReason':
            ResponseReason_ = child_.text
            ResponseReason_ = self.gds_validate_string(ResponseReason_, node, 'ResponseReason')
            self.ResponseReason = ResponseReason_
        super(OrderResponseLineItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class OrderResponseLineItemsType


class ErrorWarningType(FreeTextType):
    """Standard way to indicate that either: a) successful processing of an
    message, but one in which warnings are generated b) an error
    occurred during the processing of an OTA messageThe Warning
    element MUST contain the Type attribute that uses a recommended
    set of values to indicate the warning type. The validating XSD
    can expect to accept values that it has NOT been explicitly
    coded for and process them by using Type ="Unknown"."""
    subclass = None
    superclass = FreeTextType
    def __init__(self, Language=None, Status=None, Code=None, RecordID=None, ShortText=None, Tag=None, Type=None, DocURL=None, valueOf_=None):
        super(ErrorWarningType, self).__init__(Language, valueOf_, )
        self.Status = _cast(None, Status)
        self.Code = _cast(None, Code)
        self.RecordID = _cast(None, RecordID)
        self.ShortText = _cast(None, ShortText)
        self.Tag = _cast(None, Tag)
        self.Type = _cast(None, Type)
        self.DocURL = _cast(None, DocURL)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ErrorWarningType.subclass:
            return ErrorWarningType.subclass(*args_, **kwargs_)
        else:
            return ErrorWarningType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_RecordID(self): return self.RecordID
    def set_RecordID(self, RecordID): self.RecordID = RecordID
    def get_ShortText(self): return self.ShortText
    def set_ShortText(self, ShortText): self.ShortText = ShortText
    def get_Tag(self): return self.Tag
    def set_Tag(self, Tag): self.Tag = Tag
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_DocURL(self): return self.DocURL
    def set_DocURL(self, DocURL): self.DocURL = DocURL
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ErrorWarningType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='ErrorWarningType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorWarningType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='ErrorWarningType'):
        super(ErrorWarningType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorWarningType')
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_format_string(quote_attrib(self.Status).encode(ExternalEncoding), input_name='Status'), ))
        if self.Code is not None and 'Code' not in already_processed:
            already_processed.add('Code')
            outfile.write(' Code=%s' % (self.gds_format_string(quote_attrib(self.Code).encode(ExternalEncoding), input_name='Code'), ))
        if self.RecordID is not None and 'RecordID' not in already_processed:
            already_processed.add('RecordID')
            outfile.write(' RecordID=%s' % (self.gds_format_string(quote_attrib(self.RecordID).encode(ExternalEncoding), input_name='RecordID'), ))
        if self.ShortText is not None and 'ShortText' not in already_processed:
            already_processed.add('ShortText')
            outfile.write(' ShortText=%s' % (self.gds_format_string(quote_attrib(self.ShortText).encode(ExternalEncoding), input_name='ShortText'), ))
        if self.Tag is not None and 'Tag' not in already_processed:
            already_processed.add('Tag')
            outfile.write(' Tag=%s' % (self.gds_format_string(quote_attrib(self.Tag).encode(ExternalEncoding), input_name='Tag'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.DocURL is not None and 'DocURL' not in already_processed:
            already_processed.add('DocURL')
            outfile.write(' DocURL=%s' % (self.gds_format_string(quote_attrib(self.DocURL).encode(ExternalEncoding), input_name='DocURL'), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='ErrorWarningType', fromsubclass_=False, pretty_print=True):
        super(ErrorWarningType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ErrorWarningType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            showIndent(outfile, level)
            outfile.write('Status = "%s",\n' % (self.Status,))
        if self.Code is not None and 'Code' not in already_processed:
            already_processed.add('Code')
            showIndent(outfile, level)
            outfile.write('Code = "%s",\n' % (self.Code,))
        if self.RecordID is not None and 'RecordID' not in already_processed:
            already_processed.add('RecordID')
            showIndent(outfile, level)
            outfile.write('RecordID = "%s",\n' % (self.RecordID,))
        if self.ShortText is not None and 'ShortText' not in already_processed:
            already_processed.add('ShortText')
            showIndent(outfile, level)
            outfile.write('ShortText = "%s",\n' % (self.ShortText,))
        if self.Tag is not None and 'Tag' not in already_processed:
            already_processed.add('Tag')
            showIndent(outfile, level)
            outfile.write('Tag = "%s",\n' % (self.Tag,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.DocURL is not None and 'DocURL' not in already_processed:
            already_processed.add('DocURL')
            showIndent(outfile, level)
            outfile.write('DocURL = "%s",\n' % (self.DocURL,))
        super(ErrorWarningType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ErrorWarningType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
        value = find_attr_value_('Code', node)
        if value is not None and 'Code' not in already_processed:
            already_processed.add('Code')
            self.Code = value
        value = find_attr_value_('RecordID', node)
        if value is not None and 'RecordID' not in already_processed:
            already_processed.add('RecordID')
            self.RecordID = value
        value = find_attr_value_('ShortText', node)
        if value is not None and 'ShortText' not in already_processed:
            already_processed.add('ShortText')
            self.ShortText = value
        value = find_attr_value_('Tag', node)
        if value is not None and 'Tag' not in already_processed:
            already_processed.add('Tag')
            self.Tag = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('DocURL', node)
        if value is not None and 'DocURL' not in already_processed:
            already_processed.add('DocURL')
            self.DocURL = value
        super(ErrorWarningType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ErrorWarningType


class AdvancedShipmentNoticeLineItemsType(LineItemsType):
    subclass = None
    superclass = LineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, StorageTankIdentifier=None):
        super(AdvancedShipmentNoticeLineItemsType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, )
        self.StorageTankIdentifier = StorageTankIdentifier
    def factory(*args_, **kwargs_):
        if AdvancedShipmentNoticeLineItemsType.subclass:
            return AdvancedShipmentNoticeLineItemsType.subclass(*args_, **kwargs_)
        else:
            return AdvancedShipmentNoticeLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StorageTankIdentifier(self): return self.StorageTankIdentifier
    def set_StorageTankIdentifier(self, StorageTankIdentifier): self.StorageTankIdentifier = StorageTankIdentifier
    def hasContent_(self):
        if (
            self.StorageTankIdentifier is not None or
            super(AdvancedShipmentNoticeLineItemsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='AdvancedShipmentNoticeLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedShipmentNoticeLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='AdvancedShipmentNoticeLineItemsType'):
        super(AdvancedShipmentNoticeLineItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedShipmentNoticeLineItemsType')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='AdvancedShipmentNoticeLineItemsType', fromsubclass_=False, pretty_print=True):
        super(AdvancedShipmentNoticeLineItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageTankIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageTankIdentifier>%s</%sStorageTankIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.StorageTankIdentifier).encode(ExternalEncoding), input_name='StorageTankIdentifier'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AdvancedShipmentNoticeLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AdvancedShipmentNoticeLineItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AdvancedShipmentNoticeLineItemsType, self).exportLiteralChildren(outfile, level, name_)
        if self.StorageTankIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('StorageTankIdentifier=%s,\n' % quote_python(self.StorageTankIdentifier).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AdvancedShipmentNoticeLineItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageTankIdentifier':
            StorageTankIdentifier_ = child_.text
            StorageTankIdentifier_ = self.gds_validate_string(StorageTankIdentifier_, node, 'StorageTankIdentifier')
            self.StorageTankIdentifier = StorageTankIdentifier_
        super(AdvancedShipmentNoticeLineItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedShipmentNoticeLineItemsType


class TaxSummary(TaxType):
    subclass = None
    superclass = TaxType
    def __init__(self, TaxTypeCode=None, MixedRateIndicator=None, TaxIdentifierNumber=None, TaxExemptCode=None, TaxLocation=None, TaxRate=None, TaxBasisAmount=None, TaxAmount=None, TaxReference=None, DeferredAmount=None):
        super(TaxSummary, self).__init__(TaxTypeCode, MixedRateIndicator, TaxIdentifierNumber, TaxExemptCode, TaxLocation, TaxRate, TaxBasisAmount, TaxAmount, TaxReference, DeferredAmount, )
        pass
    def factory(*args_, **kwargs_):
        if TaxSummary.subclass:
            return TaxSummary.subclass(*args_, **kwargs_)
        else:
            return TaxSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TaxSummary, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='TaxSummary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxSummary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='TaxSummary'):
        super(TaxSummary, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TaxSummary')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='TaxSummary', fromsubclass_=False, pretty_print=True):
        super(TaxSummary, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TaxSummary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TaxSummary, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaxSummary, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TaxSummary, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TaxSummary, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TaxSummary


class SubTotalAmount(MonetaryType):
    subclass = None
    superclass = MonetaryType
    def __init__(self, MonetaryAmount=None, CurrencyCode=None, subTotalIndicator=None):
        super(SubTotalAmount, self).__init__(MonetaryAmount, CurrencyCode, )
        self.subTotalIndicator = _cast(None, subTotalIndicator)
        pass
    def factory(*args_, **kwargs_):
        if SubTotalAmount.subclass:
            return SubTotalAmount.subclass(*args_, **kwargs_)
        else:
            return SubTotalAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subTotalIndicator(self): return self.subTotalIndicator
    def set_subTotalIndicator(self, subTotalIndicator): self.subTotalIndicator = subTotalIndicator
    def hasContent_(self):
        if (
            super(SubTotalAmount, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='SubTotalAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubTotalAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='SubTotalAmount'):
        super(SubTotalAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubTotalAmount')
        if self.subTotalIndicator is not None and 'subTotalIndicator' not in already_processed:
            already_processed.add('subTotalIndicator')
            outfile.write(' subTotalIndicator=%s' % (quote_attrib(self.subTotalIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='SubTotalAmount', fromsubclass_=False, pretty_print=True):
        super(SubTotalAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubTotalAmount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subTotalIndicator is not None and 'subTotalIndicator' not in already_processed:
            already_processed.add('subTotalIndicator')
            showIndent(outfile, level)
            outfile.write('subTotalIndicator = %s,\n' % (self.subTotalIndicator,))
        super(SubTotalAmount, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubTotalAmount, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subTotalIndicator', node)
        if value is not None and 'subTotalIndicator' not in already_processed:
            already_processed.add('subTotalIndicator')
            self.subTotalIndicator = value
        super(SubTotalAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubTotalAmount, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubTotalAmount


class PriceAmount(MonetaryType):
    """The monetary price of an item in a stated currency.Indicates whether
    a price is gross or net.Identifies what "Other" is if chosen
    from an attribute enumeration list"""
    subclass = None
    superclass = MonetaryType
    def __init__(self, MonetaryAmount=None, CurrencyCode=None, definitionOfOther=None, priceType=None):
        super(PriceAmount, self).__init__(MonetaryAmount, CurrencyCode, )
        self.definitionOfOther = _cast(None, definitionOfOther)
        self.priceType = _cast(None, priceType)
        pass
    def factory(*args_, **kwargs_):
        if PriceAmount.subclass:
            return PriceAmount.subclass(*args_, **kwargs_)
        else:
            return PriceAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definitionOfOther(self): return self.definitionOfOther
    def set_definitionOfOther(self, definitionOfOther): self.definitionOfOther = definitionOfOther
    def get_priceType(self): return self.priceType
    def set_priceType(self, priceType): self.priceType = priceType
    def hasContent_(self):
        if (
            super(PriceAmount, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='PriceAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='PriceAmount'):
        super(PriceAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PriceAmount')
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            outfile.write(' definitionOfOther=%s' % (self.gds_format_string(quote_attrib(self.definitionOfOther).encode(ExternalEncoding), input_name='definitionOfOther'), ))
        if self.priceType is not None and 'priceType' not in already_processed:
            already_processed.add('priceType')
            outfile.write(' priceType=%s' % (quote_attrib(self.priceType), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='PriceAmount', fromsubclass_=False, pretty_print=True):
        super(PriceAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PriceAmount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definitionOfOther is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            showIndent(outfile, level)
            outfile.write('definitionOfOther = "%s",\n' % (self.definitionOfOther,))
        if self.priceType is not None and 'priceType' not in already_processed:
            already_processed.add('priceType')
            showIndent(outfile, level)
            outfile.write('priceType = %s,\n' % (self.priceType,))
        super(PriceAmount, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PriceAmount, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definitionOfOther', node)
        if value is not None and 'definitionOfOther' not in already_processed:
            already_processed.add('definitionOfOther')
            self.definitionOfOther = value
        value = find_attr_value_('priceType', node)
        if value is not None and 'priceType' not in already_processed:
            already_processed.add('priceType')
            self.priceType = value
        super(PriceAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PriceAmount, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PriceAmount


class FinishedProductType(ProductType):
    """Indicates that there has been some modification to the product."""
    subclass = None
    superclass = ProductType
    def __init__(self, ProductCode=None, ProductName=None, ProductDescription=None, GrossQuantity=None, Temperature=None, Gravity=None, NetQuantity=None, ProductCharacteristics=None, BlendOrAlterationIndicator=None, ComponentProduct=None, CompartmentInfo=None):
        super(FinishedProductType, self).__init__(ProductCode, ProductName, ProductDescription, GrossQuantity, Temperature, Gravity, NetQuantity, ProductCharacteristics, )
        self.BlendOrAlterationIndicator = _cast(None, BlendOrAlterationIndicator)
        if ComponentProduct is None:
            self.ComponentProduct = []
        else:
            self.ComponentProduct = ComponentProduct
        self.CompartmentInfo = CompartmentInfo
    def factory(*args_, **kwargs_):
        if FinishedProductType.subclass:
            return FinishedProductType.subclass(*args_, **kwargs_)
        else:
            return FinishedProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComponentProduct(self): return self.ComponentProduct
    def set_ComponentProduct(self, ComponentProduct): self.ComponentProduct = ComponentProduct
    def add_ComponentProduct(self, value): self.ComponentProduct.append(value)
    def insert_ComponentProduct(self, index, value): self.ComponentProduct[index] = value
    def get_CompartmentInfo(self): return self.CompartmentInfo
    def set_CompartmentInfo(self, CompartmentInfo): self.CompartmentInfo = CompartmentInfo
    def get_BlendOrAlterationIndicator(self): return self.BlendOrAlterationIndicator
    def set_BlendOrAlterationIndicator(self, BlendOrAlterationIndicator): self.BlendOrAlterationIndicator = BlendOrAlterationIndicator
    def hasContent_(self):
        if (
            self.ComponentProduct or
            self.CompartmentInfo is not None or
            super(FinishedProductType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='FinishedProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinishedProductType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='FinishedProductType'):
        super(FinishedProductType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FinishedProductType')
        if self.BlendOrAlterationIndicator is not None and 'BlendOrAlterationIndicator' not in already_processed:
            already_processed.add('BlendOrAlterationIndicator')
            outfile.write(' BlendOrAlterationIndicator=%s' % (quote_attrib(self.BlendOrAlterationIndicator), ))
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='FinishedProductType', fromsubclass_=False, pretty_print=True):
        super(FinishedProductType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ComponentProduct_ in self.ComponentProduct:
            ComponentProduct_.export(outfile, level, namespace_, name_='ComponentProduct', pretty_print=pretty_print)
        if self.CompartmentInfo is not None:
            self.CompartmentInfo.export(outfile, level, namespace_, name_='CompartmentInfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FinishedProductType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BlendOrAlterationIndicator is not None and 'BlendOrAlterationIndicator' not in already_processed:
            already_processed.add('BlendOrAlterationIndicator')
            showIndent(outfile, level)
            outfile.write('BlendOrAlterationIndicator = %s,\n' % (self.BlendOrAlterationIndicator,))
        super(FinishedProductType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FinishedProductType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ComponentProduct=[\n')
        level += 1
        for ComponentProduct_ in self.ComponentProduct:
            showIndent(outfile, level)
            outfile.write('model_.ComponentProduct(\n')
            ComponentProduct_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CompartmentInfo is not None:
            showIndent(outfile, level)
            outfile.write('CompartmentInfo=model_.CompartmentInfoType(\n')
            self.CompartmentInfo.exportLiteral(outfile, level, name_='CompartmentInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BlendOrAlterationIndicator', node)
        if value is not None and 'BlendOrAlterationIndicator' not in already_processed:
            already_processed.add('BlendOrAlterationIndicator')
            self.BlendOrAlterationIndicator = value
        super(FinishedProductType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComponentProduct':
            class_obj_ = self.get_class_obj_(child_, ProductType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ComponentProduct.append(obj_)
        elif nodeName_ == 'CompartmentInfo':
            obj_ = CompartmentInfoType.factory()
            obj_.build(child_)
            self.set_CompartmentInfo(obj_)
        super(FinishedProductType, self).buildChildren(child_, node, nodeName_, True)
# end class FinishedProductType


class VehicleInformation(VehicleInformationType):
    """Information about a vehicle involved in the load."""
    subclass = None
    superclass = VehicleInformationType
    def __init__(self, VehicleType=None, VehicleNumber=None):
        super(VehicleInformation, self).__init__(VehicleType, VehicleNumber, )
        pass
    def factory(*args_, **kwargs_):
        if VehicleInformation.subclass:
            return VehicleInformation.subclass(*args_, **kwargs_)
        else:
            return VehicleInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(VehicleInformation, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='VehicleInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VehicleInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='VehicleInformation'):
        super(VehicleInformation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VehicleInformation')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='VehicleInformation', fromsubclass_=False, pretty_print=True):
        super(VehicleInformation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='VehicleInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VehicleInformation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VehicleInformation, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VehicleInformation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VehicleInformation, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VehicleInformation


class OrderStatusResponseLineItemsType(OrderResponseLineItemsType):
    subclass = None
    superclass = OrderResponseLineItemsType
    def __init__(self, LineItemNumber=None, DocumentReference=None, PartnerInformation=None, CustomerSpecificInformation=None, Comment=None, RevisionNumber=None, ProductInformation=None, OrderQuantity=None, PackagingQuantity=None, LineItemPurposeCode=None, EngineeringChangeOrderIdentifier=None, BatchNumber=None, CountryOfOrigin=None, CountryOfFinalDestination=None, DeliveryTolerances=None, ShipmentTerms=None, ScheduleDateTime=None, ScheduleDateTimeRange=None, TransportInformation=None, RequestedDocument=None, Routing=None, SpecialServicesRequest=None, PackListRequirements=None, QuoteIdentifier=None, Label=None, ImportLicenseNeededFlag=None, ImportLicenseAvailableFlag=None, AccompanyingSampleCode=None, JobLocationClassCode=None, StatusCode=None, ResponseReason=None, ProprietaryShipmentTrackingIdentifier=None):
        super(OrderStatusResponseLineItemsType, self).__init__(LineItemNumber, DocumentReference, PartnerInformation, CustomerSpecificInformation, Comment, RevisionNumber, ProductInformation, OrderQuantity, PackagingQuantity, LineItemPurposeCode, EngineeringChangeOrderIdentifier, BatchNumber, CountryOfOrigin, CountryOfFinalDestination, DeliveryTolerances, ShipmentTerms, ScheduleDateTime, ScheduleDateTimeRange, TransportInformation, RequestedDocument, Routing, SpecialServicesRequest, PackListRequirements, QuoteIdentifier, Label, ImportLicenseNeededFlag, ImportLicenseAvailableFlag, AccompanyingSampleCode, JobLocationClassCode, StatusCode, ResponseReason, )
        self.ProprietaryShipmentTrackingIdentifier = ProprietaryShipmentTrackingIdentifier
    def factory(*args_, **kwargs_):
        if OrderStatusResponseLineItemsType.subclass:
            return OrderStatusResponseLineItemsType.subclass(*args_, **kwargs_)
        else:
            return OrderStatusResponseLineItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProprietaryShipmentTrackingIdentifier(self): return self.ProprietaryShipmentTrackingIdentifier
    def set_ProprietaryShipmentTrackingIdentifier(self, ProprietaryShipmentTrackingIdentifier): self.ProprietaryShipmentTrackingIdentifier = ProprietaryShipmentTrackingIdentifier
    def hasContent_(self):
        if (
            self.ProprietaryShipmentTrackingIdentifier is not None or
            super(OrderStatusResponseLineItemsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pidx:', name_='OrderStatusResponseLineItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderStatusResponseLineItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pidx:', name_='OrderStatusResponseLineItemsType'):
        super(OrderStatusResponseLineItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrderStatusResponseLineItemsType')
    def exportChildren(self, outfile, level, namespace_='pidx:', name_='OrderStatusResponseLineItemsType', fromsubclass_=False, pretty_print=True):
        super(OrderStatusResponseLineItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProprietaryShipmentTrackingIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProprietaryShipmentTrackingIdentifier>%s</%sProprietaryShipmentTrackingIdentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProprietaryShipmentTrackingIdentifier).encode(ExternalEncoding), input_name='ProprietaryShipmentTrackingIdentifier'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrderStatusResponseLineItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrderStatusResponseLineItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrderStatusResponseLineItemsType, self).exportLiteralChildren(outfile, level, name_)
        if self.ProprietaryShipmentTrackingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('ProprietaryShipmentTrackingIdentifier=%s,\n' % quote_python(self.ProprietaryShipmentTrackingIdentifier).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OrderStatusResponseLineItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProprietaryShipmentTrackingIdentifier':
            ProprietaryShipmentTrackingIdentifier_ = child_.text
            ProprietaryShipmentTrackingIdentifier_ = self.gds_validate_string(ProprietaryShipmentTrackingIdentifier_, node, 'ProprietaryShipmentTrackingIdentifier')
            self.ProprietaryShipmentTrackingIdentifier = ProprietaryShipmentTrackingIdentifier_
        super(OrderStatusResponseLineItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class OrderStatusResponseLineItemsType


GDSClassesMapping = {
    'TaxAmount': MonetaryType,
    'Width': QuantityType,
    'VoyageTripDateTimeRange': DateTimeRangeType,
    'RequestRequisitionReturnTotal': MonetaryType,
    'VolumeOutageQuantity': QuantityType,
    'PackageWeight': QuantityType,
    'ShippedQuantity': QuantityType,
    'AdjustedRoofQuantity': QuantityType,
    'BillOfLadingHeader': BillOfLadingHeaderType,
    'DriverInformation': DriverInformationType,
    'ScheduleDateTimeRange': DateTimeRangeType,
    'LetterOfCreditAmount': MonetaryType,
    'Length': QuantityType,
    'TimeWorked': QuantityType,
    'ShippingAmount': MonetaryType,
    'LowerLimit': QuantityType,
    'TareWeight': QuantityType,
    'SecondaryDriverID': SecondaryDriverIDType,
    'Tax': TaxType,
    'Warning': ErrorWarningType,
    'MinimumQuantity': QuantityType,
    'QuotedQuantity': QuantityType,
    'NetVolume': QuantityType,
    'GrossWeight': QuantityType,
    'InvoiceResponseReason': InvoiceResponseReasonType,
    'FieldTicketTotal': MonetaryType,
    'ProductGradeDescription': DescriptionType,
    'RequestRequisitionReturnQuantity': QuantityType,
    'InvoiceQuantity': QuantityType,
    'DiscountAmount': MonetaryType,
    'AverageFlowRate': QuantityType,
    'LineItemScheduleQuantity': QuantityType,
    'BillOfLadingDetails': BillOfLadingDetailsType,
    'FinishedProduct': FinishedProductType,
    'DateTimeRange': DateTimeRangeType,
    'PurgedQuantity': QuantityType,
    'ProductDescription': DescriptionType,
    'TaxBasisAmount': MonetaryType,
    'NetWeight': QuantityType,
    'SupplierInformation': CompanyInformationType,
    'LineItemGrossQuantity': QuantityType,
    'OrderChangeCancelLineItems': OrderLineItemsType,
    'ShipToInformation': ShipToInformationType,
    'DeferredAmount': MonetaryType,
    'OrderStatusRequestLineItems': OrderStatusLineItemsRequestType,
    'ThirdParty': CompanyInformationType,
    'FinalShipper': CompanyInformationType,
    'TankWaterQuantity': QuantityType,
    'LineItemNominationQuantity': QuantityType,
    'LetterOfCreditNegotiatedDateTimeRange': DateTimeRangeType,
    'TotalAmount': MonetaryType,
    'GaugeQuantity': QuantityType,
    'ExchangeOrThroughputPartnerInformation': CompanyInformationType,
    'UpperLimit': QuantityType,
    'SpecialServicesAmount': MonetaryType,
    'LineItemTotal': MonetaryType,
    'QuoteTotal': MonetaryType,
    'ComponentProduct': ProductType,
    'InvoiceTotal': MonetaryType,
    'NumberOfUnits': QuantityType,
    'VesselCapacityQuantity': QuantityType,
    'CreatedByPartner': PartnerEventAction,
    'ReadingQuantity': QuantityType,
    'OrderLineItems': OrderLineItemsType,
    'WellIdentifier': WellIdentifierType,
    'DiscountedAmountDue': MonetaryType,
    'Error': ErrorWarningType,
    'AdvisingBank': AdvisingBankType,
    'PartnerConfirmationStatus': PartnerConfirmationStatusType,
    'OrderStatusResponseLineItems': OrderStatusResponseLineItemsType,
    'Height': QuantityType,
    'MeterQuantity': QuantityType,
    'CustodyTicketQuantity': QuantityType,
    'AdjustmentQuantity': QuantityType,
    'GrossVolume': QuantityType,
    'ProductCharacteristics': ProductCharacteristicsType,
    'AllowanceOrChargeQuantity': QuantityType,
    'CompartmentInfo': CompartmentInfoType,
    'FieldTicketQuantity': QuantityType,
    'BillToInformation': BillToInformationType,
    'AdvancedShipmentNoticeLineItems': AdvancedShipmentNoticeLineItemsType,
    'ReceiptLineItems': ReceiptLineItemsType,
    'ChangedByPartner': PartnerEventAction,
    'PipelineEventInformation': PipelineEventInformationType,
    'CarrierInformation': CarrierInformationType,
    'ToPartner': CustodyPartnerType,
    'LetterOfCreditQuantity': LetterOfCreditQuantityType,
    'PackagingQuantity': QuantityType,
    'AllowanceOrChargeTotalAmount': MonetaryType,
    'LineItemWaterQuantity': QuantityType,
    'BillOfLadingSummary': BillOfLadingSummaryType,
    'OrderResponseLineItems': OrderResponseLineItemsType,
    'GrossTotalAmount': MonetaryType,
    'ActualQuantity': QuantityType,
    'AdvancedShipNoticeLineItems': AdvancedShipNoticeLineItemsType,
    'BillOfLadingCreate': BillOfLadingType,
    'LineItemNetQuantity': QuantityType,
    'OrderQuantity': QuantityType,
    'TankCapacityQuantity': QuantityType,
    'TermsDiscountAmount': MonetaryType,
    'CumulativeTotalQuantity': QuantityType,
    'TerminalInformation': TerminalInformationType,
    'MaximumQuantity': QuantityType,
    'FromPartner': CustodyPartnerType,
    'CorrectedQuantity': QuantityType,
    'LetterOfCreditVoyageDateTimeRange': DateTimeRangeType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BillOfLadingCreate'
        rootClass = BillOfLadingType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BillOfLadingCreate'
        rootClass = BillOfLadingType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    rootElement = rootObj.to_etree(None, name_=rootTag)
    content = etree_.tostring(rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BillOfLadingCreate'
        rootClass = BillOfLadingType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="BillOfLadingCreate",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BillOfLadingCreate'
        rootClass = BillOfLadingType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from BillOfLadingCreate import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import BillOfLadingCreate as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccountInformation",
    "AdditiveTypeIdentifier",
    "AddressInformation",
    "AdvancedShipNoticeLineItemsType",
    "AdvancedShipmentNoticeLineItemsType",
    "AdvisingBankType",
    "AllowanceOrCharge",
    "AllowanceOrChargePercent",
    "AllowanceOrChargeRate",
    "AlternativeCommunicationMethod",
    "AmbientTemperature",
    "Attachment",
    "AveragePressure",
    "AverageTemperature",
    "BatchNumber",
    "BillOfLadingDetailsType",
    "BillOfLadingHeaderType",
    "BillOfLadingSummaryType",
    "BillOfLadingType",
    "BillToInformationType",
    "Block",
    "BuyersCurrency",
    "CarrierInformationType",
    "ChangeOrderInformation",
    "CommodityCode",
    "CompanyInformationType",
    "CompartmentInfoType",
    "ContactIdentifier",
    "ContactInformation",
    "ConveyanceInformation",
    "CountryOfFinalDestination",
    "CountryOfOrigin",
    "CreditCardInformation",
    "CurrencyRates",
    "CustodyLocationIdentifier",
    "CustodyLocationInformation",
    "CustodyPartnerType",
    "CustodyTicketInformation",
    "CustodyTicketTimeLog",
    "CustodyTicketTimeLogEntry",
    "CustodyTransferInformation",
    "CustomerSpecificInformation",
    "DateTimeRangeType",
    "Deferred",
    "DeliveryTolerances",
    "DescriptionType",
    "Discounts",
    "DocumentDeliveryInformation",
    "DocumentReference",
    "DriverInformationType",
    "EffectiveDates",
    "ErrorClassification",
    "ErrorDescription",
    "ErrorWarningType",
    "ErrorsType",
    "ExceptionDescription",
    "FieldTicketInformation",
    "FinalDestinationLocationIdentifier",
    "FinalDestinationLocationInformation",
    "FinishedProductType",
    "FlashTemperature",
    "FreeFormText",
    "FreeTextType",
    "GPSCoordinates",
    "GaugeReadingMeasure",
    "GeographicalInformation",
    "Gravity",
    "GrossQuantity",
    "HazardousMaterialClassCode",
    "HazardousMaterials",
    "IntermodalService",
    "Intrastat",
    "InvoiceInformation",
    "InvoiceResponseReasonType",
    "JobLocationIdentifier",
    "JobLocationInformation",
    "LetterOfCreditInformation",
    "LetterOfCreditQuantityType",
    "LineItemAdditive",
    "LineItemIdentifier",
    "LineItemInformation",
    "LineItemMeasures",
    "LineItemPurposeCode",
    "LineItemsType",
    "LoadTenderInformation",
    "Location",
    "LocationCode",
    "ManufacturingIdentificationDetails",
    "MeasurementRange",
    "MeasurementType",
    "Meter",
    "ModeOfTransportation",
    "MonetaryType",
    "NetQuantity",
    "ObservedTemperature",
    "OffendingMessageComponent",
    "OrderChangeCancelLineItemsType",
    "OrderLineItemsType",
    "OrderResponseLineItemsType",
    "OrderStatusLineItemsRequestType",
    "OrderStatusResponseLineItemsType",
    "OriginLocationIdentifier",
    "OriginLocationInformation",
    "PackageDetail",
    "PackagingInformation",
    "PartnerConfirmationStatusType",
    "PartnerDefinedMeasure",
    "PartnerDefinedMeasureIdentifier",
    "PartnerEventAction",
    "PartnerIdentifier",
    "PartnerInformation",
    "PaymentTerms",
    "PersonnelInformation",
    "PipelineEventInformationType",
    "PortOfDischarge",
    "PortOfLoading",
    "PostalCountry",
    "PriceAmount",
    "PriceBasis",
    "Pricing",
    "PrimaryCurrency",
    "ProductCharacteristicsType",
    "ProductIdentifier",
    "ProductInformation",
    "ProductSubLineItems",
    "ProductType",
    "PurchaseOrderInformation",
    "PurchaseOrderReferenceInformation",
    "QuantityType",
    "QuoteRequestInformation",
    "RateOfExchangeDetail",
    "ReceiptLineItemsType",
    "ReferenceCurrency",
    "ReferenceInformation",
    "RequestQuoteResponse",
    "RequestedDocument",
    "ResultingOrderType",
    "RigIdentifier",
    "SampleMeasures",
    "SecondCurrency",
    "SecondaryDriverIDType",
    "SellersCurrency",
    "ServiceDateTime",
    "ShipNoticeEquipmentDetails",
    "ShipToInformationType",
    "ShipmentPackaging",
    "ShipmentTerms",
    "ShipmentTermsLocation",
    "SpecialInstructions",
    "SubTotalAmount",
    "SuccessType",
    "TankCloseMeasures",
    "TankHeight",
    "TankMeasures",
    "TankOpenMeasures",
    "TankTemperature",
    "TankWaterMeasure",
    "TargetCurrency",
    "TaxCertificateNumber",
    "TaxIdentifierNumber",
    "TaxInformation",
    "TaxLocation",
    "TaxSummary",
    "TaxType",
    "Telephone",
    "Temperature",
    "TerminalInformationType",
    "TransportInformation",
    "TransportMethod",
    "UnitPrice",
    "ValidityDates",
    "VehicleInformation",
    "VehicleInformationType",
    "VesselMeasures",
    "WarningsType",
    "WellIdentifierType",
    "WellInformation"
    ]
